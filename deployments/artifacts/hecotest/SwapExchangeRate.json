{
  "address": "0xD9C67dedda0F2948BfB28a351c171F86e6771827",
  "abi": [
    {
      "constant": true,
      "inputs": [
        {
          "internalType": "address",
          "name": "factory",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "ctokenFactory",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        },
        {
          "internalType": "address[]",
          "name": "path",
          "type": "address[]"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "getAmountsInUnderlying",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [
        {
          "internalType": "address",
          "name": "factory",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "ctokenFactory",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "internalType": "address[]",
          "name": "path",
          "type": "address[]"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "getAmountsOutUnderlying",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [
        {
          "internalType": "address",
          "name": "_ctoken",
          "type": "address"
        }
      ],
      "name": "getCurrentExchangeRate",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [
        {
          "internalType": "address",
          "name": "factory",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "ctokenFactory",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amountA",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "tokenA",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenB",
          "type": "address"
        }
      ],
      "name": "getLiquidityAmountUnderlying",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [
        {
          "internalType": "address",
          "name": "ctokenFactory",
          "type": "address"
        },
        {
          "internalType": "address[]",
          "name": "path",
          "type": "address[]"
        }
      ],
      "name": "path2cpath",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x29af9f17c99c52333e480d7237d7ffebc9a40de78d9dafc8fe7aa9da1753a3df",
  "receipt": {
    "to": null,
    "from": "0x9769713AA909C73914DaC551C8D434ad84DB9410",
    "contractAddress": "0xD9C67dedda0F2948BfB28a351c171F86e6771827",
    "transactionIndex": 2,
    "gasUsed": "878544",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x77d5fb6ac5abecbbd39cea2afa2ec3e6958fd331e133fe49871cd7ae4fe8d2e0",
    "transactionHash": "0x29af9f17c99c52333e480d7237d7ffebc9a40de78d9dafc8fe7aa9da1753a3df",
    "logs": [],
    "blockNumber": 7630612,
    "cumulativeGasUsed": "1004871",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "31dae08e0819e751891cd202ef830c96",
  "metadata": "{\"compiler\":{\"version\":\"0.5.16+commit.9c3226ce\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ctokenFactory\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"getAmountsInUnderlying\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ctokenFactory\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"getAmountsOutUnderlying\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ctoken\",\"type\":\"address\"}],\"name\":\"getCurrentExchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ctokenFactory\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getLiquidityAmountUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"ctokenFactory\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"path2cpath\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{\"getAmountsInUnderlying(address,address,uint256,address[],address)\":{\"details\":\"\\u7ed9\\u5b9a amountOut, \\u8ba1\\u7b97\\u8f93\\u5165\\u7684amountIn\",\"params\":{\"path\":\"token \\u6570\\u7ec4, \\u6ce8\\u610f: \\u5fc5\\u987b\\u662ftoken\\u7684\\u5730\\u5740!!!\"}},\"getAmountsOutUnderlying(address,address,uint256,address[],address)\":{\"details\":\"\\u7ed9\\u5b9a amountIn, \\u8ba1\\u7b97\\u80fd\\u591f\\u5151\\u6362\\u5f97\\u5230\\u7684amountOut\",\"params\":{\"path\":\"token \\u6570\\u7ec4, \\u6ce8\\u610f: \\u5fc5\\u987b\\u662ftoken\\u7684\\u5730\\u5740!!!\"}}}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/swap/heco/Router.sol\":\"SwapExchangeRate\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/GSN/Context.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor () internal { }\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x90a3995645af7562d84b9d69363ffa5ae7217714ab61e951bf7bc450f40e4061\"},\"@openzeppelin/contracts/ownership/Ownable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return _msgSender() == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\",\"keccak256\":\"0x6fb9d7889769d7cc161225f9ef7a90e468ba9788b253816f8d8b6894d3472c24\"},\"contracts/ebe/IEBEToken.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.5.16;\\r\\n\\r\\ninterface IEBEToken {\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function mint(address _to, uint256 _amount) external returns (bool);\\r\\n    // function reward(uint256 ebePerBlock) external view returns (uint256);\\r\\n    function reward(uint256 ebePerBlock, uint256 blockNumber) external view returns (uint256);\\r\\n    function getEbeReward(uint256 ebePerBlock, uint256 _lastRewardBlock) external view returns (uint256);\\r\\n}\\r\\n\",\"keccak256\":\"0x38f5c4efb0cd428bec67f698a7493d26f25ae64e7e19e8419b0a112c9371852a\"},\"contracts/swap/heco/Router.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU General Public License for more details.\\r\\n\\r\\n// You should have received a copy of the GNU General Public License\\r\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\r\\npragma solidity ^0.5.16;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/ownership/Ownable.sol\\\";\\r\\nimport \\\"../library/SafeMath.sol\\\";\\r\\nimport \\\"../interface/IERC20.sol\\\";\\r\\nimport \\\"../interface/IDeBankFactory.sol\\\";\\r\\nimport \\\"../interface/IDeBankPair.sol\\\";\\r\\nimport \\\"../interface/IDeBankRouter.sol\\\";\\r\\nimport \\\"../interface/IWHT.sol\\\";\\r\\nimport \\\"../interface/LErc20DelegatorInterface.sol\\\";\\r\\nimport \\\"../interface/ICToken.sol\\\";\\r\\n\\r\\nimport \\\"../../ebe/IEBEToken.sol\\\";\\r\\n\\r\\n// import \\\"../../compound/LHT.sol\\\";\\r\\n// import \\\"hardhat/console.sol\\\";\\r\\n\\r\\ninterface ILHT {\\r\\n    function mint() external payable returns (uint, uint);\\r\\n}\\r\\n\\r\\ninterface ISwapMining {\\r\\n    function swap(address account, address input, address output, uint256 fee) external returns (bool);\\r\\n}\\r\\n\\r\\n// interface IRewardToken {\\r\\n//     function reward(uint256 blockNumber) external view returns (uint256);\\r\\n// }\\r\\n\\r\\ncontract DeBankRouter is IDeBankRouter, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    address public factory;\\r\\n    address public WHT;\\r\\n    address public swapMining;\\r\\n    address public cWHT;\\r\\n    address[] public quoteTokens;\\r\\n    LErc20DelegatorInterface public ctokenFactory;\\r\\n\\r\\n    // \\u6240\\u6709\\u4ea4\\u6613\\u5bf9\\u4ea7\\u751f\\u7684\\u624b\\u7eed\\u8d39\\u6536\\u5165, \\u5404\\u4e2a\\u4ea4\\u6613\\u5bf9\\u6839\\u636e\\u5360\\u6bd4\\u5206\\u914d\\u6536\\u76ca\\r\\n    // uint public allPairFee;\\r\\n    // \\u4e0a\\u4e00\\u4e2a\\u5757\\u7684\\u603b\\u624b\\u7eed\\u8d39\\r\\n    // uint public allPairFeeLastBlock;\\r\\n    // \\u5f00\\u59cb\\u5206\\u914d\\u6536\\u76ca\\u7684\\u5757\\r\\n    // uint public startBlock;\\r\\n    // \\u8bb0\\u5f55\\u5f53\\u524d\\u624b\\u7eed\\u8d39\\u7684\\u5757\\u6570\\r\\n    // uint public currentBlock;\\r\\n\\r\\n    address public rewardToken;     // \\u6536\\u76ca token\\r\\n\\r\\n    uint256 public swapFeeTotal;       // \\u7d2f\\u8ba1\\u4ea4\\u6613\\u624b\\u7eed\\u8d39\\r\\n    uint256 public swapFeeCurrent;     // \\u7d2f\\u8ba1\\u4ea4\\u6613\\u624b\\u7eed\\u8d39 - \\u5df2\\u7ecf\\u63d0\\u53d6\\u4e86 reward \\u7684\\r\\n    uint256 public swapFeeLastBlock;   // \\u6700\\u540e\\u4e00\\u6b21 mint \\u7684\\u5757\\r\\n    uint256 public ebeRewards;         // \\u5f85\\u5206\\u914d\\u7684 ebe\\r\\n    // tokens created per block to all pair LP\\r\\n    // uint256 public lpPerBlock;      // LP \\u6bcf\\u5757\\u6536\\u76ca\\r\\n    // uint256 public traderPerBlock;  // \\u4ea4\\u6613\\u8005\\u6bcf\\u5757\\u6536\\u76ca\\r\\n    uint256 public ebePerBlock;        // lp \\u6bcf\\u5757\\u5206\\u914d\\u591a\\u5c11\\u4e2a ebe\\r\\n    // address public lpDepositAddr;   // compound \\u6d41\\u52a8\\u6027\\u62b5\\u62bc\\r\\n    // address public compAddr;        // compound unitroller\\r\\n    uint256 public feeAlloc;        // \\u624b\\u7eed\\u8d39\\u5206\\u914d\\u65b9\\u6848: 0: \\u5206\\u914d\\u7ed9LP; 1: \\u4e0d\\u5206\\u914d\\u7ed9LP, \\u5e73\\u53f0\\u6536\\u53d6\\u540e\\u5151\\u6362\\u4e3a anchorToken\\r\\n    // todo How many blocks are halved  182\\u5929 \\u5e94\\u8be5\\u5728 rewardToken \\u4e2d\\u5904\\u7406\\r\\n    // uint256 public halvingPeriod = 5256000;\\r\\n\\r\\n    modifier ensure(uint deadline) {\\r\\n        // solhint-disable-next-line\\r\\n        require(deadline >= block.timestamp, 'DeBankRouter: EXPIRED');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(address _factory, address _wht, address _cwht, address _ctokenFactory) public {\\r\\n        factory = _factory;\\r\\n        WHT = _wht;\\r\\n        cWHT = _cwht;\\r\\n        ctokenFactory = LErc20DelegatorInterface(_ctokenFactory);\\r\\n        // startBlock = _startBlock;\\r\\n        // heco \\u94fe\\u4e0a\\u7684 usdt\\r\\n        quoteTokens.push(IDeBankFactory(_factory).anchorToken()); // usdt\\r\\n        // todo \\u5e94\\u8be5\\u662f wht\\r\\n        quoteTokens.push(WHT); // _cwht); // wht\\r\\n        // quoteTokens.push();  // husd\\r\\n    }\\r\\n\\r\\n    function() external payable {\\r\\n        assert(msg.sender == WHT || msg.sender == cWHT);\\r\\n        // only accept HT via fallback from the WHT contract\\r\\n    }\\r\\n\\r\\n    function pairFor(address tokenA, address tokenB) public view returns (address pair) {\\r\\n        // pair = IDeBankFactory(factory).pairFor(tokenA, tokenB);\\r\\n        pair = IDeBankFactory(factory).getPair(tokenA, tokenB);\\r\\n    }\\r\\n\\r\\n    function setFeeAlloc(uint _feeAlloc) public onlyOwner {\\r\\n        require(_feeAlloc == 0 || _feeAlloc == 1, \\\"invalid param feeAlloc\\\");\\r\\n        feeAlloc = _feeAlloc;\\r\\n    }\\r\\n\\r\\n    function setSwapMining(address _swapMininng) public onlyOwner {\\r\\n        swapMining = _swapMininng;\\r\\n    }\\r\\n\\r\\n    function setCtokenFactory(address _ctokenFactory) public onlyOwner {\\r\\n        ctokenFactory = LErc20DelegatorInterface(_ctokenFactory);\\r\\n    }\\r\\n\\r\\n    function resetQuoteTokens(address[] memory tokens) public onlyOwner {\\r\\n        for (uint i; i < quoteTokens.length; i ++) {\\r\\n            quoteTokens.pop();\\r\\n        }\\r\\n        // quoteTokens.length = 0;\\r\\n        for (uint i; i < tokens.length; i ++) {\\r\\n            quoteTokens.push(tokens[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function addQuoteToken(address token) public onlyOwner {\\r\\n        quoteTokens.push(token);\\r\\n    }\\r\\n\\r\\n    // set reward token address\\r\\n    function setRewardToken(address _reword) external onlyOwner {\\r\\n        rewardToken = _reword;\\r\\n        // ebePerBlock = _ebePerBlock;\\r\\n    }\\r\\n\\r\\n    function setEbePerBlock(uint256 _ebePerBlock) external onlyOwner {\\r\\n        ebePerBlock = _ebePerBlock;\\r\\n    }\\r\\n\\r\\n    // function phase(uint256 blockNumber) public view returns (uint256) {\\r\\n    //     if (halvingPeriod == 0) {\\r\\n    //         return 0;\\r\\n    //     }\\r\\n    //     if (blockNumber > startBlock) {\\r\\n    //         return (blockNumber.sub(startBlock).sub(1)).div(halvingPeriod);\\r\\n    //     }\\r\\n    //     return 0;\\r\\n    // }\\r\\n\\r\\n    // \\u8ba1\\u7b97\\u5757\\u5956\\u52b1\\r\\n    function reward(uint256 blockNumber) public view returns (uint256) {\\r\\n        if (rewardToken == address(0) || feeAlloc == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        return IEBEToken(rewardToken).reward(ebePerBlock, blockNumber);\\r\\n    }\\r\\n\\r\\n    function pendingEBE() public view returns (uint256) {\\r\\n        if (rewardToken == address(0)) {\\r\\n            return 0;\\r\\n        }\\r\\n        return IEBEToken(rewardToken).getEbeReward(ebePerBlock, swapFeeLastBlock);\\r\\n    }\\r\\n\\r\\n    // \\u53ea\\u80fd pair \\u5730\\u5740\\u8c03\\u7528\\u8be5\\u65b9\\u6cd5\\r\\n    function mintEBEToken(address token0, address token1, uint256 _amount) external returns (uint) {\\r\\n        //\\r\\n        if (rewardToken == address(0) || feeAlloc == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        address pair = pairFor(token0, token1);\\r\\n        require(msg.sender == pair, \\\"pair not equal\\\");\\r\\n\\r\\n        if (swapFeeLastBlock < block.number) {\\r\\n            uint amt = IEBEToken(rewardToken).getEbeReward(ebePerBlock, swapFeeLastBlock);\\r\\n            IEBEToken(rewardToken).mint(address(this), amt);\\r\\n            swapFeeLastBlock = block.number;\\r\\n        }\\r\\n\\r\\n        if (_amount == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        // \\u5c06 pair \\u7684\\u6536\\u76ca\\u8f6c\\u7ed9 pair\\r\\n        uint ebeBalance = IERC20(rewardToken).balanceOf(address(this));\\r\\n        if (swapFeeCurrent >= _amount) {\\r\\n            uint part = _amount.mul(ebeBalance).div(swapFeeCurrent);\\r\\n            IEBEToken(rewardToken).transfer(pair, part);\\r\\n            return part;\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function _getOrCreateCtoken(address token) private returns (address ctoken) {\\r\\n        // ctoken = LErc20DelegatorInterface(IDeBankFactory(factory).lErc20DelegatorFactory()).getCTokenAddress(token);\\r\\n        ctoken = ctokenFactory.getCTokenAddress(token);\\r\\n        require(ctoken != address(0), \\\"get or create etoken failed\\\");\\r\\n    }\\r\\n\\r\\n    function _getCtoken(address token) private view returns (address ctoken) {\\r\\n        // ctoken = LErc20DelegatorInterface(IDeBankFactory(factory).lErc20DelegatorFactory()).getCTokenAddressPure(token);\\r\\n        ctoken = ctokenFactory.getCTokenAddressPure(token);\\r\\n        require(ctoken != address(0), \\\"get etoken failed\\\");\\r\\n    }\\r\\n\\r\\n    function _getTokenByCtoken(address ctoken) private view returns (address token) {\\r\\n        // token = LErc20DelegatorInterface(IDeBankFactory(factory).lErc20DelegatorFactory()).getTokenAddress(ctoken);\\r\\n        token = ctokenFactory.getTokenAddress(ctoken);\\r\\n        require(token != address(0), \\\"get token failed\\\");\\r\\n    }\\r\\n\\r\\n    // function _safeTransferCtoken(address token, address from, address to, uint amt) private {\\r\\n    //     TransferHelper.safeTransferFrom(_getCtoken(token), from, to, amt);\\r\\n    // }\\r\\n\\r\\n    // **** ADD LIQUIDITY ****\\r\\n\\r\\n    struct LiquidityLocalVars {\\r\\n        // uint amountToken;\\r\\n        // uint amountEth;\\r\\n        uint camountDesiredA;\\r\\n        uint camountDesiredB;\\r\\n        uint camountMinA;\\r\\n        uint camountMinB;\\r\\n\\r\\n        uint rateA;\\r\\n        uint rateB;\\r\\n        uint rateEth;\\r\\n        uint camountA;\\r\\n        uint camountB;\\r\\n        uint camountEth;\\r\\n\\r\\n        address tokenA;\\r\\n        address tokenB;\\r\\n        address ctokenA;\\r\\n        address ctokenB;\\r\\n    }\\r\\n\\r\\n    // tokenA tokenB \\u90fd\\u5fc5\\u987b\\u662f cToken\\r\\n    function _addLiquidity(\\r\\n        LiquidityLocalVars memory liquidity\\r\\n    ) internal returns (uint amountA, uint amountB) {\\r\\n        address ctokenA = liquidity.ctokenA;\\r\\n        address ctokenB = liquidity.ctokenB;\\r\\n        uint amountADesired  = liquidity.camountDesiredA;\\r\\n        uint amountBDesired = liquidity.camountDesiredB;\\r\\n        uint amountAMin = liquidity.camountMinA;\\r\\n        uint amountBMin = liquidity.camountMinB;\\r\\n        address tokenA =  liquidity.tokenA; // _getTokenByCtoken(ctokenA);\\r\\n        address tokenB =  liquidity.tokenB; // _getTokenByCtoken(ctokenB);\\r\\n\\r\\n        // create the pair if it doesn't exist yet\\r\\n        if (IDeBankFactory(factory).getPair(tokenA, tokenB) == address(0)) {\\r\\n            IDeBankFactory(factory).createPair(tokenA, tokenB, ctokenA, ctokenB);\\r\\n        }\\r\\n        (uint reserveA, uint reserveB) = IDeBankFactory(factory).getReserves(tokenA, tokenB);\\r\\n        if (reserveA == 0 && reserveB == 0) {\\r\\n            (amountA, amountB) = (amountADesired, amountBDesired);\\r\\n        } else {\\r\\n            uint amountBOptimal = IDeBankFactory(factory).quote(amountADesired, reserveA, reserveB);\\r\\n            // console.log(\\\"_addLiquidity: reserveA=%d  reserveB=%d\\\", reserveA, reserveB);\\r\\n            if (amountBOptimal <= amountBDesired) {\\r\\n                // console.log(\\\"_addLiquidity: amountBOptimal=%d  amountBDesired=%d  amountADesired=%d\\\",\\r\\n                //       amountBOptimal, amountBDesired, amountADesired);\\r\\n                require(amountBOptimal >= amountBMin, 'AddLiquidity: INSUFFICIENT_B_AMOUNT');\\r\\n                (amountA, amountB) = (amountADesired, amountBOptimal);\\r\\n            } else {\\r\\n                uint amountAOptimal = IDeBankFactory(factory).quote(amountBDesired, reserveB, reserveA);\\r\\n                // console.log(\\\"_addLiquidity: amountAOptimal=%d  amountADesired=%d  amountBDesired=%d\\\",\\r\\n                //       amountAOptimal, amountADesired, amountBDesired);\\r\\n                assert(amountAOptimal <= amountADesired);\\r\\n                require(amountAOptimal >= amountAMin, 'AddLiquidity: INSUFFICIENT_A_AMOUNT');\\r\\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // tokenA tokenB \\u90fd\\u662f cToken, amount \\u5747\\u4e3a ctoken \\u7684 amount\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external ensure(deadline) returns (uint amountA, uint amountB, uint liquidityAmt) {\\r\\n        // console.log(tokenA, tokenB);\\r\\n        // console.log(\\\"amountDesired:\\\", amountADesired, amountBDesired);\\r\\n        // console.log(\\\"amountMin:\\\", amountAMin, amountBMin);\\r\\n        LiquidityLocalVars memory liquidity;\\r\\n        liquidity.camountDesiredA = amountADesired;\\r\\n        liquidity.camountDesiredB = amountBDesired;\\r\\n        liquidity.camountMinA = amountAMin;\\r\\n        liquidity.camountMinB = amountBMin;\\r\\n        liquidity.ctokenA = tokenA;\\r\\n        liquidity.ctokenB = tokenB;\\r\\n        liquidity.tokenA = _getTokenByCtoken(tokenA);\\r\\n        liquidity.tokenB = _getTokenByCtoken(tokenB);\\r\\n        (amountA, amountB) = _addLiquidity(liquidity); // tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\\r\\n        address pair = pairFor(tokenA, tokenB);\\r\\n        // console.log(\\\"pair: %s\\\", pair);\\r\\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\\r\\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\\r\\n        // _safeTransferCtoken(tokenA, msg.sender, pair, amountA);\\r\\n        // _safeTransferCtoken(tokenB, msg.sender, pair, amountB);\\r\\n        liquidityAmt = IDeBankPair(pair).mint(to);\\r\\n    }\\r\\n\\r\\n    function _cTokenExchangeRate(address ctoken) private view returns(uint) {\\r\\n        uint rate = ICToken(ctoken).exchangeRateStored();\\r\\n        uint256 supplyRate = ICToken(ctoken).supplyRatePerBlock();\\r\\n        uint256 prevBlock = ICToken(ctoken).accrualBlockNumber();\\r\\n        rate += rate.mul(supplyRate).mul(block.number - prevBlock);\\r\\n        return rate;\\r\\n    }\\r\\n\\r\\n    // 0. \\u8ba1\\u7b97\\u9700\\u8981\\u591a\\u5c11amount\\r\\n    // 1. transfer token from msg.sender to router\\r\\n    // 2. mint ctoken\\r\\n    // 3. transfer ctoken to pair\\r\\n    // amt \\u662f Ctoken \\u6d41\\u52a8\\u6027\\u9700\\u8981\\u7684 amount\\r\\n    function _mintTransferCToken(address token, address ctoken, address pair, uint amt) private {\\r\\n        // uint er = _cTokenExchangeRate(ctoken);\\r\\n        // uint amt = camt * er / 10**18;\\r\\n\\r\\n        // console.log(\\\"before transfer\\\");\\r\\n        TransferHelper.safeTransferFrom(token, msg.sender, address(this), amt);\\r\\n        // console.log(\\\"transfer %s(%s) done: amt=%d\\\", token, ctoken, amt);\\r\\n        // uint b0 = ICToken(ctoken).balanceOf(address(this));\\r\\n        // mint \\u4e4b\\u524d\\u9700\\u8981 approve\\r\\n        ICToken(token).approve(address(ctoken), amt);\\r\\n        (uint ret, uint mintCAmt) = ICToken(ctoken).mint(amt);\\r\\n        ICToken(ctoken).approve(address(ctoken), 0);\\r\\n        // console.log(\\\"mint token to ctoken %s, amt: %d ret: %d\\\", ctoken, amt, ret);\\r\\n        require(ret == 0, \\\"mint failed\\\");\\r\\n        // uint b1 = ICToken(ctoken).balanceOf(address(this));\\r\\n        // uint mintCAmt = b1 - b0;\\r\\n        // uint mintCAmt = ICToken(ctoken).balanceOf(address(this));\\r\\n\\r\\n        // console.log(\\\"_mintTransferCToken:\\\", amt, mintCAmt);\\r\\n\\r\\n        if (address(this) != pair) {\\r\\n            TransferHelper.safeTransferFrom(ctoken, address(this), pair, mintCAmt);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _mintTransferEth(address pair, uint amt) private {\\r\\n        // uint b0 = ICToken(cWHT).balanceOf(address(this));\\r\\n        (uint ret, uint mintCAmt) = ILHT(cWHT).mint.value(amt)();\\r\\n        require(ret == 0, \\\"mint failed\\\");\\r\\n        // console.log(\\\"mint eth:\\\", mintCAmt);\\r\\n        // uint mintCAmt = ICToken(cWHT).balanceOf(address(this));\\r\\n        // uint mintCAmt = b1 - b0;\\r\\n        if (address(this) != pair) {\\r\\n            TransferHelper.safeTransferFrom(cWHT, address(this), pair, mintCAmt);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _amount2CAmount(uint amt, uint rate) private pure returns (uint) {\\r\\n        return amt.mul(10**18).div(rate);\\r\\n    }\\r\\n\\r\\n    function _camount2Amount(uint camt, uint rate) private pure returns (uint) {\\r\\n        return camt.mul(rate).div(10**18);\\r\\n    }\\r\\n\\r\\n    // tokenA tokenB \\u90fd\\u662f token\\r\\n    // 6/23 \\u5982\\u679c ctoken \\u4e0d\\u5b58\\u5728, \\u9700\\u8981\\u521b\\u5efa ctoken\\r\\n    function addLiquidityUnderlying(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\\r\\n        LiquidityLocalVars memory vars;\\r\\n\\r\\n        vars.ctokenA = _getOrCreateCtoken(tokenA);\\r\\n        vars.ctokenB = _getOrCreateCtoken(tokenB);\\r\\n        vars.tokenA = tokenA;\\r\\n        vars.tokenB = tokenB;\\r\\n        vars.rateA = _cTokenExchangeRate(vars.ctokenA);\\r\\n        vars.rateB = _cTokenExchangeRate(vars.ctokenB);\\r\\n        vars.camountDesiredA = _amount2CAmount(amountADesired, vars.rateA);\\r\\n        vars.camountDesiredB = _amount2CAmount(amountBDesired, vars.rateB);\\r\\n        vars.camountMinA = _amount2CAmount(amountAMin, vars.rateA);\\r\\n        vars.camountMinB = _amount2CAmount(amountBMin, vars.rateB);\\r\\n\\r\\n        (vars.camountA, vars.camountB) = _addLiquidity(vars); //.ctokenA,\\r\\n                // vars.ctokenB,\\r\\n                // vars.camountDesiredA,\\r\\n                // vars.camountDesiredB,\\r\\n                // vars.camountMinA,\\r\\n                // vars.camountMinB);\\r\\n        address pair = pairFor(tokenA, tokenB);\\r\\n        // mint token \\u5f97\\u5230 ctoken\\r\\n        amountA = _camount2Amount(vars.camountA, vars.rateA);\\r\\n        amountB = _camount2Amount(vars.camountB, vars.rateB);\\r\\n        // console.log(\\\"amountA: %d amountB: %d\\\", amountA, amountB);\\r\\n        _mintTransferCToken(tokenA, vars.ctokenA, pair, amountA);\\r\\n        _mintTransferCToken(tokenB, vars.ctokenB, pair, amountB);\\r\\n        // TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\\r\\n        // TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\\r\\n        // _safeTransferCtoken(tokenA, msg.sender, pair, amountA);\\r\\n        // _safeTransferCtoken(tokenB, msg.sender, pair, amountB);\\r\\n        // console.log('addLiquidityUnderlying: pair=%s', pair);\\r\\n        liquidity = IDeBankPair(pair).mint(to);\\r\\n    }\\r\\n\\r\\n    // token \\u662f token \\u800c\\u4e0d\\u662f ctoken\\r\\n    // \\u8fd9\\u4e2a\\u51fd\\u6570\\u5e94\\u8be5\\u4e0d\\u80fd\\u76f4\\u63a5\\u88ab\\u8c03\\u7528\\u4e86, \\u5982\\u679c\\u662f ctoken, \\u76f4\\u63a5\\u8c03\\u7528\\u4e0a\\u9762\\u7684\\u51fd\\u6570\\uff1b\\u5982\\u679c\\u662f token, \\u9700\\u8981\\u8c03\\u7528 todo\\r\\n    function addLiquidityETHUnderlying(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\\r\\n        address ctoken = _getOrCreateCtoken(token);\\r\\n        LiquidityLocalVars memory vars;\\r\\n        vars.rateA = _cTokenExchangeRate(ctoken);\\r\\n        vars.rateB = _cTokenExchangeRate(cWHT);\\r\\n        vars.camountDesiredA = _amount2CAmount(amountTokenDesired, vars.rateA);\\r\\n        vars.camountDesiredB = _amount2CAmount(msg.value, vars.rateB);\\r\\n        vars.camountMinA = _amount2CAmount(amountTokenMin, vars.rateA);\\r\\n        vars.camountMinB = _amount2CAmount(amountETHMin, vars.rateB);\\r\\n        vars.ctokenA = ctoken;\\r\\n        vars.ctokenB = cWHT;\\r\\n        vars.tokenA = token;\\r\\n        vars.tokenB = WHT;\\r\\n        (uint amountCToken, uint amountCETH) = _addLiquidity(vars);\\r\\n        //     ctoken,\\r\\n        //     cWHT,\\r\\n        //     vars.camountDesiredA,\\r\\n        //     vars.camountDesiredB,\\r\\n        //     vars.camountMinA,\\r\\n        //     vars.camountMinB\\r\\n        // );\\r\\n        address pair = pairFor(token, WHT);\\r\\n\\r\\n        amountToken = _camount2Amount(amountCToken, vars.rateA);\\r\\n        amountETH = _camount2Amount(amountCETH, vars.rateB);\\r\\n        // console.log(\\\"amountToken: %d amountETH: %d\\\", amountToken, amountETH);\\r\\n        _mintTransferCToken(token, ctoken, pair, amountToken);\\r\\n        // TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\\r\\n        // _safeTransferCtoken(token, msg.sender, pair, amountToken);\\r\\n        // IWHT(WHT).deposit.value(amountETH)();\\r\\n        _mintTransferEth(pair, amountETH);\\r\\n        // cWHT.value(amountETH).mint();\\r\\n        // assert(IWHT(WHT).transfer(pair, amountETH));\\r\\n        liquidity = IDeBankPair(pair).mint(to);\\r\\n        // refund dust eth, if any\\r\\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\\r\\n    }\\r\\n\\r\\n    // **** REMOVE LIQUIDITY ****\\r\\n    // tokenA tokenB \\u90fd\\u662f ctoken\\r\\n    function removeLiquidity(\\r\\n        address ctokenA,\\r\\n        address ctokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) public ensure(deadline) returns (uint amountA, uint amountB) {\\r\\n        address pair = pairFor(ctokenA, ctokenB);\\r\\n        IDeBankPair(pair).transferFrom(msg.sender, pair, liquidity);\\r\\n        // console.log(\\\"transfer Liquidity success\\\");\\r\\n        // send liquidity to pair\\r\\n        (uint amount0, uint amount1) = IDeBankPair(pair).burn(to);\\r\\n        address tokenA = _getTokenByCtoken(ctokenA);\\r\\n        address tokenB = _getTokenByCtoken(ctokenB);\\r\\n        (address token0,) = IDeBankFactory(factory).sortTokens(tokenA, tokenB);\\r\\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\\r\\n        require(amountA >= amountAMin, 'RemoveLiquidity: INSUFFICIENT_A_AMOUNT');\\r\\n        require(amountB >= amountBMin, 'RemoveLiquidity: INSUFFICIENT_B_AMOUNT');\\r\\n    }\\r\\n\\r\\n    // \\u8d4e\\u56de ctoken\\r\\n    function _redeemCToken(address ctoken, uint camt) private returns (uint) {\\r\\n        // uint b0 = IERC20(token).balanceOf(address(this));\\r\\n        // console.log(\\\"ctoken balance:\\\", ctoken, IERC20(ctoken).balanceOf(address(this)));\\r\\n        (uint err, uint amt, ) = ICToken(ctoken).redeem(camt);\\r\\n        require(err == 0, \\\"redeem failed\\\");\\r\\n        return amt;\\r\\n        // return IERC20(token).balanceOf(address(this));\\r\\n        // uint b1 = IERC20(token).balanceOf(address(this));\\r\\n        // console.log(b1, b0);\\r\\n        // require(b1 >= b0, \\\"redeem failed\\\");\\r\\n        // return b1.sub(b0);\\r\\n    }\\r\\n\\r\\n    // \\u8d4e\\u56de ctoken\\r\\n    function _redeemCEth(uint camt) private returns (uint) {\\r\\n        // uint b0 = IERC20(WHT).balanceOf(address(this));\\r\\n        (uint err, uint amt, ) = ICToken(cWHT).redeem(camt);\\r\\n        require(err == 0, \\\"redeem failed\\\");\\r\\n        return amt;\\r\\n        // uint b1 = IERC20(WHT).balanceOf(address(this));\\r\\n        // return b1.sub(b0);\\r\\n    }\\r\\n\\r\\n    function _redeemCTokenTransfer(address ctoken, address token, address to, uint camt) private returns (uint)  {\\r\\n        // console.log(\\\"_redeemCTokenTransfer: redeem amt: %d\\\", camt);\\r\\n        uint amt = _redeemCToken(ctoken, camt);\\r\\n        if (amt > 0) {\\r\\n            TransferHelper.safeTransfer(token, to, amt);\\r\\n        }\\r\\n        return amt;\\r\\n    }\\r\\n\\r\\n    function _redeemCETHTransfer(address to, uint camt) private returns (uint) {\\r\\n        uint amt = _redeemCEth(camt);\\r\\n        if (amt > 0) {\\r\\n            TransferHelper.safeTransferETH(to, amt);\\r\\n        }\\r\\n        return amt;\\r\\n    }\\r\\n\\r\\n    // tokenA tokenB \\u90fd\\u662f token amount\\u90fd\\u662f token \\u7684 amount\\r\\n    // \\u4ece ctoken redeem token \\u53ef\\u80fd\\u4f1a\\u5931\\u8d25(\\u989d\\u5ea6\\u4e0d\\u8db3), \\u56e0\\u6b64, \\r\\n    // \\u5728\\u8c03\\u7528\\u4e4b\\u524d, \\u524d\\u7aef\\u5fc5\\u987b\\u6821\\u9a8c\\u501f\\u8d37\\u6c60\\u4f59\\u989d\\u662f\\u5426\\u8db3\\u591f\\uff01\\uff01\\uff01\\r\\n    function removeLiquidityUnderlying(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) public ensure(deadline) returns (uint amountA, uint amountB) {\\r\\n        address pair = pairFor(tokenA, tokenB);\\r\\n        // \\u786e\\u4fdd\\u53ea\\u6709owner\\u53ef\\u4ee5\\u79fb\\u9664\\u6d41\\u52a8\\u6027\\r\\n        // require(IDeBankPair(pair).ownerAmountOf(to) >= liquidity, \\\"not owner or not enough\\\");\\r\\n\\r\\n        IDeBankPair(pair).transferFrom(msg.sender, pair, liquidity);\\r\\n        LiquidityLocalVars memory vars;\\r\\n        {\\r\\n            vars.tokenA = tokenA;\\r\\n            vars.tokenB = tokenB;\\r\\n            //  \\u5148\\u628a ctoken \\u53d1\\u9001\\u7ed9 router\\r\\n            (uint camount0, uint camount1) = IDeBankPair(pair).burn(address(this));\\r\\n            (address token0,) = IDeBankFactory(factory).sortTokens(vars.tokenA, vars.tokenB);\\r\\n            (vars.camountA, vars.camountB) = tokenA == token0 ? (camount0, camount1) : (camount1, camount0);\\r\\n        }\\r\\n        // console.log(\\\"camountA: %d camountB: %d\\\", vars.camountA, vars.camountB);\\r\\n        amountA = _redeemCTokenTransfer(_getCtoken(tokenA), tokenA, to, vars.camountA);\\r\\n        amountB = _redeemCTokenTransfer(_getCtoken(tokenB), tokenB, to, vars.camountB);\\r\\n\\r\\n        // console.log(\\\"amountA: %d amountB: %d\\\", amountA, amountB);\\r\\n        // TransferHelper.safeTransfer(tokenA, to, amountA);\\r\\n        // TransferHelper.safeTransfer(tokenB, to, amountB);\\r\\n        // address ctokenB = _getCtoken(tokenB);\\r\\n        // ICToken(ctokenA).redeem(camountA);\\r\\n        // ICToken(ctokenB).redeem(camountB);\\r\\n\\r\\n        require(amountA >= amountAMin, 'RemoveLiquidityUnderlying: INSUFFICIENT_A_AMOUNT');\\r\\n        require(amountB >= amountBMin, 'RemoveLiquidityUnderlying: INSUFFICIENT_B_AMOUNT');\\r\\n    }\\r\\n\\r\\n    // \\u5728\\u8c03\\u7528\\u4e4b\\u524d, \\u524d\\u7aef\\u5fc5\\u987b\\u6821\\u9a8c\\u501f\\u8d37\\u6c60\\u4f59\\u989d\\u662f\\u5426\\u8db3\\u591f\\uff01\\uff01\\uff01\\r\\n    function removeLiquidityETHUnderlying(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) public ensure(deadline) returns (uint amountToken, uint amountETH) {\\r\\n        LiquidityLocalVars memory vars;\\r\\n        vars.ctokenA = _getCtoken(token);\\r\\n        vars.rateA = _cTokenExchangeRate(vars.ctokenA);\\r\\n        vars.rateEth = _cTokenExchangeRate(cWHT);\\r\\n        uint camountTokenMin = _amount2CAmount(amountTokenMin, vars.rateA);\\r\\n        uint camountETHMin = _amount2CAmount(amountETHMin, vars.rateEth);\\r\\n        uint amountCToken;\\r\\n        uint amountCETH;\\r\\n        \\r\\n        (amountCToken, amountCETH) = removeLiquidity(\\r\\n            vars.ctokenA,\\r\\n            cWHT,\\r\\n            liquidity,\\r\\n            camountTokenMin,\\r\\n            camountETHMin,\\r\\n            address(this),\\r\\n            deadline\\r\\n        );\\r\\n        \\r\\n        amountToken = _redeemCTokenTransfer(vars.ctokenA, token, to, amountCToken);\\r\\n        // TransferHelper.safeTransfer(token, to, amountToken);\\r\\n        // IWHT(WHT).withdraw(amountETH);\\r\\n        amountETH = _redeemCETHTransfer(to, amountCETH);\\r\\n        // to.transfer(amountETH);\\r\\n        // TransferHelper.safeTransferETH(to, amountETH);\\r\\n    }\\r\\n\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB) {\\r\\n        address pair = pairFor(tokenA, tokenB);\\r\\n        uint value = approveMax ? uint(- 1) : liquidity;\\r\\n        IDeBankPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\r\\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\\r\\n    }\\r\\n\\r\\n    function removeLiquidityETHUnderlyingWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH) {\\r\\n        address pair = pairFor(token, WHT);\\r\\n        uint value = approveMax ? uint(- 1) : liquidity;\\r\\n        IDeBankPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\r\\n        (amountToken, amountETH) = removeLiquidityETHUnderlying(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\\r\\n    }\\r\\n\\r\\n    // \\u5151\\u6362\\u624b\\u7eed\\u8d39, \\u4e0d\\u6536\\u624b\\u7eed\\u8d39\\r\\n    function _swapFee(address input, address pair, uint feeIn, address feeTo) internal returns (uint feeOut) {\\r\\n        (uint reserve0, uint reserve1, ) = IDeBankPair(pair).getReserves();\\r\\n        address token0 = IDeBankPair(pair).token0();\\r\\n        if (input == token0) {\\r\\n            feeOut = feeIn.mul(reserve1).div(reserve0.add(feeIn));\\r\\n            IDeBankPair(pair).swapNoFee(0, feeOut, feeTo, 0);\\r\\n        } else {\\r\\n            feeOut = feeIn.mul(reserve0).div(reserve1.add(feeIn));\\r\\n            IDeBankPair(pair).swapNoFee(feeOut, 0, feeTo, 0);\\r\\n        }\\r\\n        // console.log(\\\"_swapFee: feeIn=%d feeOut=%d\\\", feeIn, feeOut);\\r\\n    }\\r\\n\\r\\n    struct SwapAnchorParam {\\r\\n        uint fr;            // fee rate\\r\\n        address input;\\r\\n        address cinput;\\r\\n        address pair;\\r\\n        address feeTo;\\r\\n        address anchorToken;\\r\\n    }\\r\\n\\r\\n    // \\u5c06\\u6536\\u5230\\u7684\\u624b\\u7eed\\u8d39 token \\u8f6c\\u6362\\u4e3a anchorToken\\r\\n    // input \\u4e3a token\\r\\n    // swap\\u540e\\u5f97\\u5230\\u7684\\u662f canchorToken, cUSDT\\r\\n    function _swapToCAnchorToken(\\r\\n                    SwapAnchorParam memory param,\\r\\n                    uint amountIn\\r\\n                )\\r\\n                internal\\r\\n                returns (uint feeIn, uint fee) {\\r\\n        // address feeTo = IDeBankFactory(factory).feeTo();\\r\\n        // uint amountIn = IERC20(_getCtoken(input)).balanceOf(pair);    // \\u8f93\\u5165\\u8f6c\\u5165\\r\\n        uint feeRate = param.fr;\\r\\n        address pair = param.pair;\\r\\n        address input = param.input;\\r\\n        address anchorToken = param.anchorToken;\\r\\n        address feeTo = param.feeTo;\\r\\n\\r\\n        // uint feeIn;\\r\\n        if (feeRate == 0) {\\r\\n            feeIn = IDeBankPair(pair).getFee(amountIn);\\r\\n        } else {\\r\\n            feeIn = IDeBankPair(pair).getFee(amountIn, feeRate - 1);\\r\\n        }\\r\\n        // console.log(\\\"amountIn: %d  feeIn: %d\\\", amountIn, feeIn);\\r\\n\\r\\n        if (input == anchorToken) {\\r\\n            // \\u76f4\\u63a5\\u6536\\r\\n            fee = feeIn;\\r\\n            IERC20(param.cinput).transfer(feeTo, fee);\\r\\n            // feeTotal = feeTotal.add(feeIn);\\r\\n        } else {\\r\\n            // \\u5151\\u6362\\u6210 anchorToken\\r\\n            address cinput = param.cinput; // _getCtoken(input);\\r\\n            for (uint i; i < quoteTokens.length; i ++) {\\r\\n                address token = quoteTokens[i];\\r\\n                address tPair = IDeBankFactory(factory).getPair(input, token);\\r\\n\\r\\n                // console.log(\\\"_swapToCAnchorToken: input=%s token=%s pair=%s\\\", input, token, tPair);\\r\\n                if (tPair != address(0)) {\\r\\n                    if (token == anchorToken) {\\r\\n                        // \\u5151\\u6362\\u6210\\u529f\\r\\n                        IERC20(cinput).transfer(tPair, feeIn);\\r\\n                        fee = _swapFee(input, tPair, feeIn, feeTo);\\r\\n                    } else {\\r\\n                        // \\u9700\\u8981\\u4e24\\u6b65\\u5151\\u6362\\r\\n                        // \\u7b2c\\u4e00\\u6b65, \\u5151\\u6362\\u4e3a\\u4e2d\\u95f4\\u5e01\\u79cd \\u4f8b\\u5982ht husd btc\\r\\n                        address pair2 = IDeBankFactory(factory).getPair(token, anchorToken);\\r\\n                        require(pair2 != address(0), \\\"quote coin has no pair to anchorToken\\\");\\r\\n                        IERC20(cinput).transfer(tPair, feeIn);\\r\\n                        uint fee1 = _swapFee(input, tPair, feeIn, pair2);\\r\\n                        // \\u7b2c\\u4e8c\\u6b65\\r\\n                        fee = _swapFee(token, pair2, fee1, feeTo);\\r\\n                    }\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // return fee;\\r\\n    }\\r\\n\\r\\n    function _updatePairFee(uint fee) private {\\r\\n        // \\u66f4\\u65b0\\u6240\\u6709\\u4ea4\\u6613\\u5bf9\\u7684\\u624b\\u7eed\\u8d39\\r\\n        // if (currentBlock == block.number) {\\r\\n        //     allPairFee += fee;\\r\\n        // } else {\\r\\n        //     //\\r\\n        //     allPairFeeLastBlock = allPairFee;\\r\\n        //     allPairFee = fee;\\r\\n        //     currentBlock = block.number;\\r\\n        // }\\r\\n        swapFeeTotal += fee;\\r\\n        swapFeeCurrent += fee;\\r\\n    }\\r\\n\\r\\n\\r\\n    // \\u5c06\\u624b\\u7eed\\u8d39\\u5151\\u6362\\u4e3a anchor token\\r\\n    // \\u5148\\u5c06\\u624b\\u7eed\\u8d39\\u6536\\u5b8c !!!\\r\\n    function _swap2(uint amtIn, address[] memory path, address _to) internal returns (uint256 amtOut, uint feeTotal) {\\r\\n        SwapAnchorParam memory param;\\r\\n\\r\\n        param.feeTo = IDeBankFactory(factory).feeTo();\\r\\n        require(param.feeTo != address(0), \\\"feeTo not set\\\");\\r\\n        param.anchorToken = IDeBankFactory(factory).anchorToken();\\r\\n        param.fr = IDeBankFactory(factory).feeRateOf(_to);\\r\\n\\r\\n        uint amountIn = amtIn;\\r\\n        uint fee;\\r\\n        // uint feeTotal;\\r\\n        for (uint i; i < path.length - 1; i++) {\\r\\n            param.input = path[i];\\r\\n            param.cinput = _getCtoken(param.input);\\r\\n            param.pair = IDeBankFactory(factory).getPair(path[i], path[i+1]);\\r\\n            // address feeTo = IDeBankFactory(factory).feeTo();\\r\\n            // uint amountOut = amounts[i + 1];\\r\\n            \\r\\n            // (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\\r\\n            // (uint feeIn, uint fee) = _swapToCAnchorToken(amountIn, input, pair, anchorToken, feeTo, fr);\\r\\n            // console.log(\\\"fee:\\\", fee);\\r\\n            // // if (fee > 0) {\\r\\n            //     feeTotal += fee;\\r\\n            // // }\\r\\n\\r\\n            // // transfer to pair\\r\\n\\r\\n            // amountIn = amountIn.sub(feeIn);\\r\\n            // // input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\\r\\n            // (uint amount0Out, uint amount1Out) = _calcAmountOut(input, pair, amountIn);\\r\\n            // IERC20(input).transfer(pair, amountIn);\\r\\n            address to = i < path.length - 2 ? address(this) : _to;\\r\\n            // IDeBankPair(pair).swapNoFee(\\r\\n            //     amount0Out, amount1Out, to, fee\\r\\n            // );\\r\\n            // amountIn = amount1Out;\\r\\n            (amtOut, fee) = _doSwapAnchorToken(param, amountIn, to);\\r\\n            feeTotal += fee;\\r\\n            amountIn = amtOut;\\r\\n        }\\r\\n\\r\\n        if (swapMining != address(0)) {\\r\\n            // \\u4ea4\\u6613\\u6316\\u77ff\\r\\n            ISwapMining(swapMining).swap(msg.sender, path[0], path[1], feeTotal);\\r\\n        }\\r\\n\\r\\n        if (feeTotal > 0) {\\r\\n            _updatePairFee(feeTotal);\\r\\n        }\\r\\n        // return amountIn;\\r\\n    }\\r\\n\\r\\n    function _doSwapAnchorToken(\\r\\n                    SwapAnchorParam memory param,\\r\\n                    uint amountIn,\\r\\n                    address to\\r\\n                )\\r\\n                internal\\r\\n                returns (uint, uint) {\\r\\n        address input = param.input;\\r\\n        address pair = param.pair;\\r\\n        // address anchorToken = param.anchorToken;\\r\\n        // uint fr = param.fr;\\r\\n\\r\\n        // console.log(\\\"before swapfee: balance: %d transfer: %d\\\", IERC20(param.cinput).balanceOf(address(this)), amountIn);\\r\\n        (uint feeIn, uint fee) = _swapToCAnchorToken(param, amountIn);\\r\\n        // transfer to pair\\r\\n\\r\\n        amountIn = amountIn.sub(feeIn);\\r\\n        // input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\\r\\n        (uint amount0Out, uint amount1Out, uint amountOut) = _calcAmountOut(input, pair, amountIn);\\r\\n        // console.log(\\\"amountIn: %d amount0Out: %d amount1Out: %d\\\", amountIn, amount0Out, amount1Out);\\r\\n        // console.log(\\\"balance: %d transfer: %d\\\", IERC20(param.cinput).balanceOf(address(this)), amountIn);\\r\\n        IERC20(param.cinput).transfer(pair, amountIn);\\r\\n        // console.log(\\\"before swap\\\");\\r\\n        // address to = i < path.length - 2 ? address(this) : _to;\\r\\n        IDeBankPair(pair).swapNoFee(\\r\\n            amount0Out, amount1Out, to, fee\\r\\n        );\\r\\n        // amountIn = amount1Out;\\r\\n        // return ()\\r\\n        return (amountOut, fee);\\r\\n    }\\r\\n\\r\\n    function _calcAmountOut(\\r\\n                    address input,\\r\\n                    address pair,\\r\\n                    uint amtIn\\r\\n                )\\r\\n                internal\\r\\n                view\\r\\n                returns (uint out0, uint out1, uint out) {\\r\\n        address token0 = IDeBankPair(pair).token0(); // IDeBankFactory(factory).sortTokens(input, output);\\r\\n        (uint reserve0, uint reserve1,) = IDeBankPair(pair).getReserves();\\r\\n        if (input == token0) {\\r\\n            out0 = 0;\\r\\n            out1 = amtIn.mul(reserve1) / (reserve0 + amtIn);\\r\\n            out = out1;\\r\\n        } else {\\r\\n            out1 = 0;\\r\\n            out0 = amtIn.mul(reserve0) / (reserve1 + amtIn);\\r\\n            out = out0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // **** SWAP ****\\r\\n    // amounts \\u4e3a ctoken \\u7684 amount\\r\\n    // path \\u4e2d\\u7684 token \\u5747\\u4e3a token, \\u8c03\\u7528\\u524d\\u8bf7\\u8f6c\\u6362\\uff01\\uff01\\uff01\\r\\n    // requires the initial amount to have already been sent to the first pair\\r\\n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal {\\r\\n        // uint feeTotal;  // by anchorToken\\r\\n        // address anchorToken = IDeBankFactory(factory).anchorToken();\\r\\n        // address[] memory path = _cpath2path(cpath);\\r\\n\\r\\n        // console.log(\\\"_swap ....\\\");\\r\\n        for (uint i; i < path.length - 1; i++) {\\r\\n            (address input, address output) = (path[i], path[i + 1]);\\r\\n            (address token0,) = IDeBankFactory(factory).sortTokens(input, output);\\r\\n            // address pair = IDeBankFactory(factory).getPair(path[i], path[i + 1]);\\r\\n            // address feeTo = IDeBankFactory(factory).feeTo();\\r\\n            // uint feeRate = IDeBankPair(pair).feeRate();\\r\\n            uint amountOut = amounts[i + 1];\\r\\n            // uint amountIn = IERC20(pair).balanceOf(pair);    // \\u8f93\\u5165\\u8f6c\\u5165\\r\\n            // uint feeIn = IDeBankPair(pair).getFee(amountIn);\\r\\n\\r\\n            // feeTotal = feeTotal.add();\\r\\n            // if (feeTotal > 0) {\\r\\n            //     // \\u5206\\u914dLP\\u624b\\u7eed\\u8d39\\u5956\\u52b1\\r\\n            // }\\r\\n\\r\\n            \\r\\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\\r\\n            address to = i < path.length - 2 ? pairFor(output, path[i + 2]) : _to;\\r\\n            // if (feeAlloc == 1) {\\r\\n            //     // \\u6536\\u624b\\u7eed\\u8d39, \\u5e76\\u5c06\\u624b\\u7eed\\u8d39\\u5151\\u6362\\u4e3a canchorToken(cUSDT)\\r\\n            //     uint fee = _swapToCAnchorToken(amounts[i], input, pair, anchorToken);\\r\\n            //     console.log(\\\"fee:\\\", fee);\\r\\n            //     if (fee > 0) {\\r\\n            //         _updatePairFee(fee);\\r\\n            //     }\\r\\n\\r\\n            //     if (swapMining != address(0)) {\\r\\n            //         // \\u4ea4\\u6613\\u6316\\u77ff\\r\\n            //         ISwapMining(swapMining).swap(msg.sender, input, output, fee);\\r\\n            //     }\\r\\n\\r\\n            //     // transfer to pair\\r\\n            //     IDeBankPair(pairFor(input, output)).swapNoFee(\\r\\n            //         amount0Out, amount1Out, to, fee\\r\\n            //     );\\r\\n            // } else {\\r\\n                IDeBankPair(pairFor(input, output)).swap(\\r\\n                    amount0Out, amount1Out, to, new bytes(0)\\r\\n                );\\r\\n            // }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _path2cpath(address[] memory path) private view returns (address[] memory) {\\r\\n        address[] memory cpath = new address[](path.length);\\r\\n        for (uint i = 0; i < path.length; i ++) {\\r\\n            cpath[i] = _getCtoken(path[i]);\\r\\n        }\\r\\n        return cpath;\\r\\n    }\\r\\n\\r\\n    function _cpath2path(address[] memory cpath) private view returns (address[] memory) {\\r\\n        address[] memory path = new address[](cpath.length);\\r\\n        for (uint i = 0; i < cpath.length; i ++) {\\r\\n            path[i] = _getTokenByCtoken(cpath[i]);\\r\\n        }\\r\\n        return path;\\r\\n    }\\r\\n\\r\\n    // amount token \\u5747\\u4e3a ctoken\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata cpath,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external ensure(deadline) returns (uint[] memory amounts, uint fee) {\\r\\n        // console.log('swapExactTokensForTokens ....');\\r\\n        address[] memory path = _cpath2path(cpath);\\r\\n        amounts = IDeBankFactory(factory).getAmountsOut(amountIn, path, to);\\r\\n        // console.log(amounts[0], amounts[1]);\\r\\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\\r\\n        // _safeTransferCtoken(\\r\\n        //     path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\\r\\n        // );\\r\\n        if (feeAlloc == 0) {\\r\\n            TransferHelper.safeTransferFrom(cpath[0], msg.sender, pairFor(path[0], path[1]), amounts[0]);\\r\\n            _swap(amounts, path, to);\\r\\n        } else {\\r\\n            TransferHelper.safeTransferFrom(cpath[0], msg.sender, address(this), amounts[0]);\\r\\n            (, fee) = _swap2(amountIn, path, to);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // amount token \\u5747\\u4e3a ctoken\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata cpath,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external ensure(deadline) returns (uint[] memory amounts, uint fee) {\\r\\n        // console.log('swapTokensForExactTokens ....');\\r\\n        address[] memory path = _cpath2path(cpath);\\r\\n        amounts = IDeBankFactory(factory).getAmountsIn(amountOut, path, to);\\r\\n        require(amounts[0] <= amountInMax, 'Router: EXCESSIVE_INPUT_AMOUNT');\\r\\n        // _safeTransferCtoken(\\r\\n        //     path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\\r\\n        // );\\r\\n        if (feeAlloc == 0) {\\r\\n            TransferHelper.safeTransferFrom(cpath[0], msg.sender, pairFor(path[0], path[1]), amounts[0]);\\r\\n            _swap(amounts, path, to);\\r\\n        } else {\\r\\n            TransferHelper.safeTransferFrom(cpath[0], msg.sender, address(this), amounts[0]);\\r\\n            (, fee) = _swap2(amounts[0], path, to);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _swapExactTokensForTokensUnderlying(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] memory path,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool ethIn,\\r\\n        bool ethOut\\r\\n    ) private ensure(deadline) returns (uint[] memory amounts) {\\r\\n        // console.log('_swapExactTokensForTokensUnderlying ....');\\r\\n        address[] memory cpath = _path2cpath(path);\\r\\n        address mintTo;\\r\\n        if (feeAlloc == 0) {\\r\\n            mintTo = pairFor(path[0], path[1]);\\r\\n        } else {\\r\\n            mintTo = address(this);\\r\\n        }\\r\\n        if (ethIn) {\\r\\n            _mintTransferEth(mintTo, amountIn);\\r\\n        } else {\\r\\n            _mintTransferCToken(path[0], cpath[0], mintTo, amountIn);\\r\\n        }\\r\\n        // console.log(\\\"mint transfer ok: %d\\\", amountIn);\\r\\n\\r\\n        SwapLocalVars memory vars;\\r\\n        vars.amountIn = amountIn;\\r\\n        vars.rate0 = _cTokenExchangeRate(cpath[0]);\\r\\n        vars.rate1 = _cTokenExchangeRate(cpath[0]);\\r\\n        uint camtIn = _amount2CAmount(amountIn, vars.rate0);\\r\\n        uint camtOut;\\r\\n        // _safeTransferCtoken(\\r\\n        //     path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\\r\\n        // );\\r\\n\\r\\n        // TransferHelper.safeTransferFrom(path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]);\\r\\n        // \\u5148\\u5c06 ctoken \\u8f6c\\u7ed9 router\\r\\n        if (feeAlloc == 0) {\\r\\n            uint[] memory camounts = IDeBankFactory(factory).getAmountsOut(camtIn, path, to);\\r\\n            // console.log(\\\"_swapExactTokensForTokensUnderlying: in/out: %d %d\\\", camounts[0], camounts[camounts.length-1]);\\r\\n\\r\\n            // console.log(\\\"camounts: \\\", camounts[0], camounts[1]);\\r\\n            camtOut = camounts[camounts.length-1];\\r\\n            vars.amountOut = _camount2Amount(camtOut, vars.rate1);\\r\\n            require(vars.amountOut >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\\r\\n            _swap(camounts, path, address(this));\\r\\n        } else {\\r\\n            (camtOut, ) = _swap2(camtIn, path, address(this));\\r\\n            require(vars.amountOut >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\\r\\n        }\\r\\n\\r\\n        // vars.amountOut = \\r\\n        uint idx = path.length - 1;\\r\\n        if (ethOut) {\\r\\n            _redeemCETHTransfer(to, camtOut);\\r\\n        } else {\\r\\n            _redeemCTokenTransfer(cpath[idx], path[idx], to, camtOut);\\r\\n        }\\r\\n\\r\\n        amounts = new uint[](path.length);\\r\\n        amounts[0] = amountIn;\\r\\n        amounts[idx] = _camount2Amount(camtOut, vars.rate1);\\r\\n    }\\r\\n\\r\\n    // amount token \\u5747\\u4e3a token\\r\\n    // \\u8c03\\u7528\\u8005\\u9700\\u8981\\u9a8c\\u8bc1\\u501f\\u8d37\\u6c60\\u4e2d\\u7684 path[path.length-1] \\u7684\\u8d44\\u91d1\\u8db3\\u591f\\uff01\\uff01\\uff01\\r\\n    function swapExactTokensForTokensUnderlying(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external ensure(deadline) returns (uint[] memory amounts) {\\r\\n        // console.log('swapExactTokensForTokensUnderlying ....');\\r\\n        amounts = _swapExactTokensForTokensUnderlying(amountIn, amountOutMin, path, to, deadline, false, false);\\r\\n        // address[] memory cpath = _path2cpath(path);\\r\\n        // uint rate0 = _cTokenExchangeRate(cpath[0]);\\r\\n        // uint rate1 = _cTokenExchangeRate(cpath[0]);\\r\\n        // uint camtIn = _amount2CAmount(amountIn, rate0);\\r\\n        // uint[] memory camounts = IDeBankFactory(factory).getAmountsOut(camtIn, path);\\r\\n        // console.log(camounts[0], camounts[1]);\\r\\n        // uint amountOut = _camount2Amount(camounts[camounts.length - 1], rate1);\\r\\n        // require(amountOut >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\\r\\n        // // _safeTransferCtoken(\\r\\n        // //     path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\\r\\n        // // );\\r\\n        // _mintTransferCToken(path[0], cpath[0], pairFor(path[0], path[1]), amountIn);\\r\\n        // // TransferHelper.safeTransferFrom(path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]);\\r\\n        // _swap(camounts, path, to);\\r\\n        // uint idx = path.length - 1;\\r\\n        // _redeemCTokenTransfer(cpath[idx], path[idx], to, camounts[idx]);\\r\\n\\r\\n        // amounts = new uint[](path.length);\\r\\n        // amounts[0] = amountIn;\\r\\n        // amounts[idx] = amountOut;\\r\\n    }\\r\\n\\r\\n    struct SwapLocalVars {\\r\\n        uint rate0;\\r\\n        uint rate1;\\r\\n        uint amountIn;\\r\\n        uint amountOut;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    function _swapTokensForExactTokensUnderlying(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] memory path,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool ethIn,\\r\\n        bool ethOut\\r\\n    ) private ensure(deadline) returns (uint[] memory amounts) {\\r\\n        // console.log('_swapTokensForExactTokensUnderlying ....');\\r\\n        address[] memory cpath = _path2cpath(path);\\r\\n        SwapLocalVars memory vars;\\r\\n\\r\\n        vars.rate0 = _cTokenExchangeRate(cpath[0]);\\r\\n        vars.rate1 = _cTokenExchangeRate(cpath[path.length-1]);\\r\\n        uint camtOut = _amount2CAmount(amountOut, vars.rate1);\\r\\n        uint[] memory camounts = IDeBankFactory(factory).getAmountsIn(camtOut, path, to);\\r\\n        console.log(\\\"camounts:\\\", camounts[0], camounts[1], camtOut);\\r\\n        \\r\\n        vars.amountIn = _camount2Amount(camounts[0], vars.rate0);\\r\\n        // \\u4e0a\\u4e00\\u6b65\\u4e2d\\u820d\\u53bb\\u7684 1\\r\\n        vars.amountIn = vars.amountIn.add(1);\\r\\n        // console.log(\\\"amountIn:\\\", vars.amountIn);\\r\\n        require(vars.amountIn <= amountInMax, 'Router: EXCESSIVE_INPUT_AMOUNT');\\r\\n        // _safeTransferCtoken(\\r\\n        //     path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\\r\\n        // );\\r\\n        if (ethIn) {\\r\\n            _mintTransferEth(pairFor(path[0], path[1]), vars.amountIn);\\r\\n        } else {\\r\\n            _mintTransferCToken(path[0], cpath[0], pairFor(path[0], path[1]), vars.amountIn);\\r\\n        }\\r\\n        console.log(\\\"mint transfer ok: %d\\\", vars.amountIn);\\r\\n        // TransferHelper.safeTransferFrom(path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]);\\r\\n        // \\u5148\\u8f6c\\u7ed9 router, \\u518d\\u7531 router redeem \\u540e, \\u8f6c\\u7ed9 to\\r\\n        _swap(camounts, path, address(this));\\r\\n        uint idx = path.length - 1;\\r\\n        if (ethOut) {\\r\\n            _redeemCETHTransfer(to, camounts[idx]);\\r\\n        } else {\\r\\n            _redeemCTokenTransfer(cpath[idx], path[idx], to, camounts[idx]);\\r\\n        }\\r\\n        console.log(\\\"redeem transfer ok: %d\\\", camounts[idx]);\\r\\n\\r\\n        amounts = new uint[](path.length);\\r\\n        amounts[0] = vars.amountIn;\\r\\n        amounts[idx] = amountOut;\\r\\n    }\\r\\n\\r\\n    // amount token \\u5747\\u4e3a ctoken\\r\\n    function swapTokensForExactTokensUnderlying(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external ensure(deadline) returns (uint[] memory amounts) {\\r\\n        // console.log('swapTokensForExactTokensUnderlying ....');\\r\\n        amounts = _swapTokensForExactTokensUnderlying(amountOut, amountInMax, path, to, deadline, false, false);\\r\\n        // address[] memory cpath = _path2cpath(path);\\r\\n        // uint rate0 = _cTokenExchangeRate(cpath[0]);\\r\\n        // uint rate1 = _cTokenExchangeRate(cpath[0]);\\r\\n        // uint camtOut = _amount2CAmount(amountOut, rate1);\\r\\n        // uint[] memory camounts = IDeBankFactory(factory).getAmountsIn(camtOut, path);\\r\\n        \\r\\n        // uint amountIn = _camount2Amount(camounts[0], rate0);\\r\\n        // require(amountIn <= amountInMax, 'Router: EXCESSIVE_INPUT_AMOUNT');\\r\\n        // // _safeTransferCtoken(\\r\\n        // //     path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\\r\\n        // // );\\r\\n        // _mintTransferCToken(path[0], cpath[0], pairFor(path[0], path[1]), amountIn);\\r\\n        // // TransferHelper.safeTransferFrom(path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]);\\r\\n        // _swap(camounts, path, to);\\r\\n        // uint idx = path.length - 1;\\r\\n        // _redeemCTokenTransfer(cpath[idx], path[idx], to, camounts[idx]);\\r\\n\\r\\n        // amounts = new uint[](path.length);\\r\\n        // amounts[0] = amountIn;\\r\\n        // amounts[idx] = amountOut;\\r\\n    }\\r\\n    */\\r\\n\\r\\n    function swapExactETHForTokensUnderlying(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        ensure(deadline)\\r\\n        returns (uint[] memory amounts)\\r\\n    {\\r\\n        // console.log('swapExactETHForTokensUnderlying: %d ....', msg.value);\\r\\n        require(path[0] == WHT, 'Router: INVALID_PATH');\\r\\n        amounts = _swapExactTokensForTokensUnderlying(msg.value, amountOutMin, path, to, deadline, true, false);\\r\\n        // amounts = IDeBankFactory(factory).getAmountsOut(msg.value, path);\\r\\n        // require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\\r\\n        // IWHT(WHT).deposit.value(amounts[0])();\\r\\n        // assert(IWHT(WHT).transfer(pairFor(path[0], path[1]), amounts[0]));\\r\\n        // _swap(amounts, path, to);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    function swapTokensForExactETHUnderlying(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        ensure(deadline)\\r\\n        returns (uint[] memory amounts)\\r\\n    {\\r\\n        // console.log('swapTokensForExactETH ....');\\r\\n        require(path[path.length - 1] == WHT, 'Router: INVALID_PATH');\\r\\n        amounts = _swapTokensForExactTokensUnderlying(amountOut, amountInMax, path, to, deadline, false, true);\\r\\n        // amounts = IDeBankFactory(factory).getAmountsIn(amountOut, path);\\r\\n        // require(amounts[0] <= amountInMax, 'Router: EXCESSIVE_INPUT_AMOUNT');\\r\\n        // _safeTransferCtoken(\\r\\n        //     path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\\r\\n        // );\\r\\n        // _swap(amounts, path, address(this));\\r\\n        // IWHT(WHT).withdraw(amounts[amounts.length - 1]);\\r\\n        // TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\r\\n    }\\r\\n    */\\r\\n\\r\\n    function swapExactTokensForETHUnderlying(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        ensure(deadline)\\r\\n        returns (uint[] memory amounts)\\r\\n    {\\r\\n        // console.log('swapExactTokensForETHUnderlying ....');\\r\\n        require(path[path.length - 1] == WHT, 'Router: INVALID_PATH');\\r\\n        amounts = _swapExactTokensForTokensUnderlying(amountIn, amountOutMin, path, to, deadline, false, true);\\r\\n        // amounts = IDeBankFactory(factory).getAmountsOut(amountIn, path);\\r\\n        // require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\\r\\n        // _safeTransferCtoken(\\r\\n        //     path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\\r\\n        // );\\r\\n        // _swap(amounts, path, address(this));\\r\\n        // IWHT(WHT).withdraw(amounts[amounts.length - 1]);\\r\\n        // TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n    function swapETHForExactTokensUnderlying(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        ensure(deadline)\\r\\n        returns (uint[] memory amounts)\\r\\n    {\\r\\n        // console.log('swapETHForExactTokensUnderlying ....');\\r\\n        require(path[0] == WHT, 'Router: INVALID_PATH');\\r\\n        amounts = _swapTokensForExactTokensUnderlying(amountOut, msg.value, path, to, deadline, true, false);\\r\\n        // amounts = IDeBankFactory(factory).getAmountsIn(amountOut, path);\\r\\n        // require(amounts[0] <= msg.value, 'Router: EXCESSIVE_INPUT_AMOUNT');\\r\\n        // IWHT(WHT).deposit{value : amounts[0]}();\\r\\n        // assert(IWHT(WHT).transfer(pairFor(path[0], path[1]), amounts[0]));\\r\\n        // _swap(amounts, path, to);\\r\\n        // // refund dust eth, if any\\r\\n        // if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\\r\\n    }\\r\\n    */\\r\\n\\r\\n    function adminTransfer(address token, address to, uint amt) external onlyOwner {\\r\\n        if (token == address(0)) {\\r\\n          TransferHelper.safeTransferETH(to, amt);\\r\\n        } else {\\r\\n          TransferHelper.safeTransferFrom(token, address(this), to, amt);\\r\\n        }\\r\\n    }\\r\\n    // **** SWAP (supporting fee-on-transfer tokens) ****\\r\\n    // requires the initial amount to have already been sent to the first pair\\r\\n    // function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal {\\r\\n    //     for (uint i; i < path.length - 1; i++) {\\r\\n    //         (address input, address output) = (path[i], path[i + 1]);\\r\\n    //         (address token0,) = IDeBankFactory(factory).sortTokens(input, output);\\r\\n    //         IDeBankPair pair = IDeBankPair(pairFor(input, output));\\r\\n    //         uint amountInput;\\r\\n    //         uint amountOutput;\\r\\n    //         {// scope to avoid stack too deep errors\\r\\n    //             (uint reserve0, uint reserve1,) = pair.getReserves();\\r\\n    //             (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\r\\n    //             amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\\r\\n    //             amountOutput = IDeBankFactory(factory).getAmountOut(amountInput, reserveInput, reserveOutput);\\r\\n    //         }\\r\\n    //         if (swapMining != address(0)) {\\r\\n    //             ISwapMining(swapMining).swap(msg.sender, input, output, amountOutput);\\r\\n    //         }\\r\\n    //         (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\\r\\n    //         address to = i < path.length - 2 ? pairFor(output, path[i + 2]) : _to;\\r\\n    //         pair.swap(amount0Out, amount1Out, to, new bytes(0));\\r\\n    //     }\\r\\n    // }\\r\\n\\r\\n    // function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n    //     uint amountIn,\\r\\n    //     uint amountOutMin,\\r\\n    //     address[] calldata path,\\r\\n    //     address to,\\r\\n    //     uint deadline\\r\\n    // ) external ensure(deadline) {\\r\\n    //     TransferHelper.safeTransferFrom(\\r\\n    //         path[0], msg.sender, pairFor(path[0], path[1]), amountIn\\r\\n    //     );\\r\\n    //     uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\\r\\n    //     _swapSupportingFeeOnTransferTokens(path, to);\\r\\n    //     require(\\r\\n    //         IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\\r\\n    //         'Router: INSUFFICIENT_OUTPUT_AMOUNT'\\r\\n    //     );\\r\\n    // }\\r\\n\\r\\n    // function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n    //     uint amountOutMin,\\r\\n    //     address[] calldata path,\\r\\n    //     address to,\\r\\n    //     uint deadline\\r\\n    // )\\r\\n    // external\\r\\n    // payable\\r\\n    // ensure(deadline)\\r\\n    // {\\r\\n    //     require(path[0] == WHT, 'Router: INVALID_PATH');\\r\\n    //     uint amountIn = msg.value;\\r\\n    //     IWHT(WHT).deposit.value(amountIn)();\\r\\n    //     assert(IWHT(WHT).transfer(pairFor(path[0], path[1]), amountIn));\\r\\n    //     uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\\r\\n    //     _swapSupportingFeeOnTransferTokens(path, to);\\r\\n    //     require(\\r\\n    //         IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\\r\\n    //         'Router: INSUFFICIENT_OUTPUT_AMOUNT'\\r\\n    //     );\\r\\n    // }\\r\\n\\r\\n    // function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n    //     uint amountIn,\\r\\n    //     uint amountOutMin,\\r\\n    //     address[] calldata path,\\r\\n    //     address to,\\r\\n    //     uint deadline\\r\\n    // )\\r\\n    // external\\r\\n    // ensure(deadline)\\r\\n    // {\\r\\n    //     require(path[path.length - 1] == WHT, 'Router: INVALID_PATH');\\r\\n    //     TransferHelper.safeTransferFrom(\\r\\n    //         path[0], msg.sender, pairFor(path[0], path[1]), amountIn\\r\\n    //     );\\r\\n    //     _swapSupportingFeeOnTransferTokens(path, address(this));\\r\\n    //     uint amountOut = IERC20(WHT).balanceOf(address(this));\\r\\n    //     require(amountOut >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\\r\\n    //     IWHT(WHT).withdraw(amountOut);\\r\\n    //     TransferHelper.safeTransferETH(to, amountOut);\\r\\n    // }\\r\\n\\r\\n    // **** LIBRARY FUNCTIONS ****\\r\\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) public view returns (uint256 amountB) {\\r\\n        return IDeBankFactory(factory).quote(amountA, reserveA, reserveB);\\r\\n    }\\r\\n\\r\\n    // function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) public view returns (uint256 amountOut){\\r\\n    //     return IDeBankFactory(factory).getAmountOut(amountIn, reserveIn, reserveOut);\\r\\n    // }\\r\\n\\r\\n    // function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) public view returns (uint256 amountIn){\\r\\n    //     return IDeBankFactory(factory).getAmountIn(amountOut, reserveIn, reserveOut);\\r\\n    // }\\r\\n\\r\\n    function getAmountsOut(uint256 amountIn, address[] memory path, address to) public view returns (uint256[] memory amounts) {\\r\\n        return IDeBankFactory(factory).getAmountsOut(amountIn, path, to);\\r\\n    }\\r\\n\\r\\n    function getAmountsIn(uint256 amountOut, address[] memory path, address to) public view returns (uint256[] memory amounts) {\\r\\n        return IDeBankFactory(factory).getAmountsIn(amountOut, path, to);\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\nlibrary SwapExchangeRate {\\r\\n    using SafeMath for uint;\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    function getCurrentExchangeRate(address _ctoken) public view returns (uint256) {\\r\\n        ICToken ctoken = ICToken(_ctoken);\\r\\n\\r\\n        uint rate = ctoken.exchangeRateStored();\\r\\n        uint supplyRate = ctoken.supplyRatePerBlock();\\r\\n        uint lastBlock = ctoken.accrualBlockNumber();\\r\\n        uint blocks = block.number.sub(lastBlock);\\r\\n        uint inc = rate.mul(supplyRate).mul(blocks);\\r\\n        return rate.add(inc);\\r\\n    }\\r\\n\\r\\n    // function getCtoken(address ctokenFactory, address token) public view returns (address ctoken) {\\r\\n    //     // ctoken = LErc20DelegatorInterface(IDeBankFactory(factory).lErc20DelegatorFactory()).getCTokenAddressPure(token);\\r\\n    //     ctoken = LErc20DelegatorInterface(ctokenFactory).getCTokenAddressPure(token);\\r\\n    // }\\r\\n\\r\\n    function path2cpath(\\r\\n                    address ctokenFactory,\\r\\n                    address[] memory path\\r\\n                )\\r\\n                public\\r\\n                view\\r\\n                returns (address[] memory) {\\r\\n        address[] memory cpath = new address[](path.length);\\r\\n\\r\\n        for (uint i = 0; i < path.length; i ++) {\\r\\n            cpath[i] = LErc20DelegatorInterface(ctokenFactory).getCTokenAddressPure(path[i]);\\r\\n        }\\r\\n        return cpath;\\r\\n    }\\r\\n\\r\\n\\r\\n    // \\u83b7\\u53d6\\u6dfb\\u52a0\\u6d41\\u52a8\\u6027\\u7684\\u6570\\u91cf\\r\\n    function getLiquidityAmountUnderlying(\\r\\n                    address factory,\\r\\n                    address ctokenFactory,\\r\\n                    uint256 amountA,\\r\\n                    address tokenA,\\r\\n                    address tokenB\\r\\n                )\\r\\n                public\\r\\n                view\\r\\n                returns (uint256) {\\r\\n        (uint ra, uint rb) = IDeBankFactory(factory).getReserves(tokenA, tokenB);\\r\\n        uint rateA;\\r\\n        uint rateB;\\r\\n        {\\r\\n            // avoid stack too deep\\r\\n            address ctokenA = LErc20DelegatorInterface(ctokenFactory).getCTokenAddressPure(tokenA);\\r\\n            address ctokenB = LErc20DelegatorInterface(ctokenFactory).getCTokenAddressPure(tokenB);\\r\\n            rateA = getCurrentExchangeRate(ctokenA);\\r\\n            rateB = getCurrentExchangeRate(ctokenB);\\r\\n        }\\r\\n        // uint cAmtA = amountA.mul(e18).div(rateA);\\r\\n        // uint cAmtB = cAmtA.mul(rb).div(ra);\\r\\n        // uint amtB = cAmtB.mul(rateB).div(e18);\\r\\n        // return amtB;\\r\\n\\r\\n        return amountA.mul(rb).mul(rateB).div(rateA).div(ra);\\r\\n    }\\r\\n\\r\\n    /// @dev \\u7ed9\\u5b9a amountIn, \\u8ba1\\u7b97\\u80fd\\u591f\\u5151\\u6362\\u5f97\\u5230\\u7684amountOut\\r\\n    /// @param path token \\u6570\\u7ec4, \\u6ce8\\u610f: \\u5fc5\\u987b\\u662ftoken\\u7684\\u5730\\u5740!!!\\r\\n    function getAmountsOutUnderlying(\\r\\n                    address factory,\\r\\n                    address ctokenFactory,\\r\\n                    uint256 amountIn,\\r\\n                    address[] memory path,\\r\\n                    address to\\r\\n                )\\r\\n                public\\r\\n                view\\r\\n                returns (uint256[] memory amounts, uint256 amountOut) {\\r\\n        //\\r\\n        address[] memory cpath = path2cpath(ctokenFactory, path);\\r\\n        uint256 rateIn = getCurrentExchangeRate(cpath[0]);\\r\\n        uint256 cAmtIn = amountIn.mul(1e18).div(rateIn);\\r\\n        amounts = IDeBankFactory(factory).getAmountsOut(cAmtIn, path, to);\\r\\n        // console.log(\\\"cAmtIn: %d amountOut: %d\\\", cAmtIn, amounts[1]);\\r\\n        uint256 rateOut = getCurrentExchangeRate(cpath[cpath.length-1]);\\r\\n        amountOut = amounts[amounts.length-1].mul(rateOut).div(1e18);\\r\\n    }\\r\\n\\r\\n    /// @dev \\u7ed9\\u5b9a amountOut, \\u8ba1\\u7b97\\u8f93\\u5165\\u7684amountIn\\r\\n    /// @param path token \\u6570\\u7ec4, \\u6ce8\\u610f: \\u5fc5\\u987b\\u662ftoken\\u7684\\u5730\\u5740!!!\\r\\n    function getAmountsInUnderlying(\\r\\n                    address factory,\\r\\n                    address ctokenFactory,\\r\\n                    uint256 amountOut,\\r\\n                    address[] memory path,\\r\\n                    address to\\r\\n                )\\r\\n                public\\r\\n                view\\r\\n                returns (uint256[] memory amounts, uint256 amountIn) {\\r\\n        //\\r\\n        address[] memory cpath = path2cpath(ctokenFactory, path);\\r\\n        uint256 rateOut = getCurrentExchangeRate(cpath[cpath.length-1]);\\r\\n        uint256 cAmtOut = amountOut.mul(1e18).div(rateOut);\\r\\n        amounts = IDeBankFactory(factory).getAmountsIn(cAmtOut, path, to);\\r\\n        uint256 rateIn = getCurrentExchangeRate(cpath[0]);\\r\\n        amountIn = amounts[0].mul(rateIn).div(1e18);\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\r\\nlibrary TransferHelper {\\r\\n    function safeApprove(address token, address to, uint value) internal {\\r\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\r\\n    }\\r\\n\\r\\n    function safeTransfer(address token, address to, uint value) internal {\\r\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\r\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\r\\n    }\\r\\n\\r\\n    function safeTransferETH(address to, uint value) internal {\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success,) = to.call.value(value)(new bytes(0));\\r\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x5a1ff8a8f4847992de66e825d170eb83c15a91cb096caa5e3cf7e2516ec77ad7\"},\"contracts/swap/interface/ICToken.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU General Public License for more details.\\r\\n\\r\\n// You should have received a copy of the GNU General Public License\\r\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity ^0.5.16;\\r\\n\\r\\ninterface ICToken {\\r\\n\\r\\n    function mint(uint mintAmount) external returns (uint, uint);\\r\\n    function redeem(uint redeemTokens) external returns (uint, uint, uint);\\r\\n\\r\\n    function transfer(address dst, uint amount) external returns (bool);\\r\\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\\r\\n    function approve(address spender, uint amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function balanceOfUnderlying(address owner) external returns (uint);\\r\\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\\r\\n    function borrowRatePerBlock() external view returns (uint);\\r\\n    function supplyRatePerBlock() external view returns (uint);\\r\\n    function totalBorrowsCurrent() external returns (uint);\\r\\n    function borrowBalanceCurrent(address account) external returns (uint);\\r\\n    function borrowBalanceStored(address account) external view returns (uint);\\r\\n    function exchangeRateCurrent() external returns (uint);\\r\\n    function exchangeRateStored() external view returns (uint);\\r\\n    function getCash() external view returns (uint);\\r\\n    function accrueInterest() external returns (uint);\\r\\n    function accrualBlockNumber() external view returns (uint);\\r\\n    // function getCash() virtual external view returns (uint);\\r\\n    // function accrueInterest() virtual public returns (uint);\\r\\n    // function seize(address liquidator, address borrower, uint seizeTokens) virtual external returns (uint);\\r\\n\\r\\n}\\r\\n\",\"keccak256\":\"0xa6cd8367024a151c89ff5fc2b7d823beb0b8cee78b3e1fa2128ca669abe9ae42\"},\"contracts/swap/interface/IDeBankFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU General Public License for more details.\\r\\n\\r\\n// You should have received a copy of the GNU General Public License\\r\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\r\\npragma solidity ^0.5.16;\\r\\n\\r\\nimport \\\"./LErc20DelegatorInterface.sol\\\";\\r\\n\\r\\ninterface IDeBankFactory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n\\r\\n    function router() external view returns (address);\\r\\n\\r\\n    function compAddr() external view returns (address);\\r\\n    \\r\\n    // function feeToSetter() external view returns (address);\\r\\n\\r\\n    function lpFeeRate() external view returns (uint256);\\r\\n\\r\\n    // function lErc20DelegatorFactory() external view returns (LErc20DelegatorInterface);\\r\\n\\r\\n    function anchorToken() external view returns (address);\\r\\n\\r\\n    function feeRateOf(address to) external view returns (uint);\\r\\n\\r\\n    function mintFreeAddress(address addr) external view returns (bool);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB, address ctoken0, address ctoken1) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n\\r\\n    // function setFeeToSetter(address) external;\\r\\n\\r\\n    function setFeeToRate(uint256) external;\\r\\n\\r\\n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, address token1);\\r\\n\\r\\n    function pairFor(address tokenA, address tokenB) external view returns (address pair);\\r\\n\\r\\n    function getReserves(address tokenA, address tokenB) external view returns (uint256 reserveA, uint256 reserveB);\\r\\n\\r\\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint256 amountB);\\r\\n\\r\\n    // function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountOut);\\r\\n\\r\\n    // function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountIn);\\r\\n\\r\\n    function getAmountsOut(uint256 amountIn, address[] calldata path, address to) external view returns (uint256[] memory amounts);\\r\\n\\r\\n    function getAmountsIn(uint256 amountOut, address[] calldata path, address to) external view returns (uint256[] memory amounts);\\r\\n\\r\\n    // function amountToCTokenAmt(address ctoken, uint amountIn) external view returns (uint cAmountIn);\\r\\n    // function ctokenAmtToAmount(address ctoken, uint cAmountOut) external view returns (uint amountOut);\\r\\n\\r\\n    function setPairFeeRate(address pair, uint feeRate) external;\\r\\n\\r\\n    function getReservesFeeRate(address tokenA, address tokenB, address to) external view returns (uint reserveA, uint reserveB, uint feeRate, bool outAnchorToken);\\r\\n\\r\\n    function getAmountOutFeeRate(uint amountIn, uint reserveIn, uint reserveOut, uint feeRate) external view returns (uint amountOut);\\r\\n\\r\\n    function getAmountInFeeRate(uint amountOut, uint reserveIn, uint reserveOut, uint feeRate) external pure returns (uint amountIn);\\r\\n\\r\\n    function getAmountOutFeeRateAnchorToken(uint amountIn, uint reserveIn, uint reserveOut, uint feeRate) external pure returns (uint amountOut);\\r\\n\\r\\n    function setAnchorToken(address _token) external;\\r\\n\\r\\n    function setUserFeeRate(address user, uint feeRate) external;\\r\\n}\\r\\n\",\"keccak256\":\"0xf3f7f728a157b346a909251985af9796553b18a54352f210610403ecff53704d\"},\"contracts/swap/interface/IDeBankPair.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU General Public License for more details.\\r\\n\\r\\n// You should have received a copy of the GNU General Public License\\r\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\r\\npragma solidity ^0.5.16;\\r\\n\\r\\ninterface IDeBankPair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n\\r\\n    function symbol() external pure returns (string memory);\\r\\n\\r\\n    function decimals() external pure returns (uint8);\\r\\n\\r\\n    function totalSupply() external view returns (uint);\\r\\n\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n\\r\\n    // function ownerAmountOf(address owner) external view returns (uint);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n\\r\\n    function factory() external view returns (address);\\r\\n\\r\\n    function feeRate() external view returns (uint);\\r\\n\\r\\n    function token0() external view returns (address);\\r\\n\\r\\n    function token1() external view returns (address);\\r\\n\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    // \\u66f4\\u65b0\\u7528\\u6237\\u7684 ebe \\u6536\\u76ca\\r\\n    function withdrawEBEReward(address to) external returns (uint);\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    // function mintCToken(address to) external returns (uint liquidity);\\r\\n\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n\\r\\n    function swapNoFee(uint amount0Out, uint amount1Out, address to, uint fee) external;\\r\\n\\r\\n    function skim(address to) external;\\r\\n\\r\\n    function sync() external;\\r\\n\\r\\n    function price(address token, uint256 baseDecimal) external view returns (uint256);\\r\\n\\r\\n    function initialize(address, address, address, address) external;\\r\\n    function updateFeeRate(uint256 _feeRate) external;\\r\\n    // initialize ctoken address\\r\\n    // function initializeCTokenAddress(address, address) external;\\r\\n\\r\\n    function getFee(uint256 amt) external view returns (uint256);\\r\\n    function getFee(uint256 amt, uint fr) external view returns (uint256);\\r\\n\\r\\n    // function updateFeeRate(_feeRate) external;\\r\\n}\\r\\n\",\"keccak256\":\"0x6687356877b5c02b543db6d3e4724c90ed6bfd4d73435f6fb1f0eefc6ac021a3\"},\"contracts/swap/interface/IDeBankRouter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU General Public License for more details.\\r\\n\\r\\n// You should have received a copy of the GNU General Public License\\r\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\r\\npragma solidity ^0.5.16;\\r\\n\\r\\ninterface IDeBankRouter {\\r\\n    function factory() external view returns (address);\\r\\n\\r\\n    function WHT() external view returns (address);\\r\\n\\r\\n    function swapFeeTotal() external view returns (uint);\\r\\n\\r\\n    function reward(uint256 blockNumber) external view returns (uint256);\\r\\n\\r\\n    function rewardToken() external view returns (address);\\r\\n\\r\\n    // \\u5f53\\u524d\\u5e73\\u53f0\\u6240\\u6709\\u672a\\u5206\\u914d\\u624b\\u7eed\\u8d39\\u603b\\u6570\\r\\n    function swapFeeCurrent() external view returns(uint256);\\r\\n\\r\\n    function pendingEBE() external view returns (uint256);\\r\\n\\r\\n    function mintEBEToken(address token0, address token1, uint256 _amount) external returns (uint);\\r\\n\\r\\n    // function lpDepositAddr() external view returns (address);\\r\\n    \\r\\n    // function compAddr() external view returns (address);\\r\\n\\r\\n    // function startBlock() external view returns (uint);\\r\\n\\r\\n    function swapMining() external view returns (address);\\r\\n\\r\\n    // function getBlockRewards(uint256 _lastRewardBlock) external view returns (uint256);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n\\r\\n    function addLiquidityUnderlying(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n\\r\\n    function addLiquidityETHUnderlying(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n\\r\\n    function removeLiquidityUnderlying(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n\\r\\n    function removeLiquidityETHUnderlying(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n\\r\\n    function removeLiquidityETHUnderlyingWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts, uint fee);\\r\\n\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts, uint fee);\\r\\n\\r\\n    function swapExactTokensForTokensUnderlying(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n\\r\\n    // function swapTokensForExactTokensUnderlying(\\r\\n    //     uint amountOut,\\r\\n    //     uint amountInMax,\\r\\n    //     address[] calldata path,\\r\\n    //     address to,\\r\\n    //     uint deadline\\r\\n    // ) external returns (uint[] memory amounts);\\r\\n\\r\\n    function swapExactETHForTokensUnderlying(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    // function swapTokensForExactETHUnderlying(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n    //     external\\r\\n    //     returns (uint[] memory amounts);\\r\\n\\r\\n    function swapExactTokensForETHUnderlying(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    // function swapETHForExactTokensUnderlying(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n    //     external\\r\\n    //     payable\\r\\n    //     returns (uint[] memory amounts);\\r\\n    // function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n    // external\\r\\n    // payable\\r\\n    // returns (uint[] memory amounts);\\r\\n\\r\\n    // function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n    // external\\r\\n    // returns (uint[] memory amounts);\\r\\n\\r\\n    // function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n    // external\\r\\n    // returns (uint[] memory amounts);\\r\\n\\r\\n    // function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n    // external\\r\\n    // payable\\r\\n    // returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external view returns (uint256 amountB);\\r\\n\\r\\n    // function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountOut);\\r\\n\\r\\n    // function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountIn);\\r\\n\\r\\n    function getAmountsOut(uint256 amountIn, address[] calldata path, address to) external view returns (uint256[] memory amounts);\\r\\n\\r\\n    function getAmountsIn(uint256 amountOut, address[] calldata path, address to) external view returns (uint256[] memory amounts);\\r\\n\\r\\n    // function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n    //     address token,\\r\\n    //     uint liquidity,\\r\\n    //     uint amountTokenMin,\\r\\n    //     uint amountETHMin,\\r\\n    //     address to,\\r\\n    //     uint deadline\\r\\n    // ) external returns (uint amountETH);\\r\\n\\r\\n    // function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n    //     address token,\\r\\n    //     uint liquidity,\\r\\n    //     uint amountTokenMin,\\r\\n    //     uint amountETHMin,\\r\\n    //     address to,\\r\\n    //     uint deadline,\\r\\n    //     bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    // ) external returns (uint amountETH);\\r\\n\\r\\n    // function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n    //     uint amountIn,\\r\\n    //     uint amountOutMin,\\r\\n    //     address[] calldata path,\\r\\n    //     address to,\\r\\n    //     uint deadline\\r\\n    // ) external;\\r\\n\\r\\n    // function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n    //     uint amountOutMin,\\r\\n    //     address[] calldata path,\\r\\n    //     address to,\\r\\n    //     uint deadline\\r\\n    // ) external payable;\\r\\n\\r\\n    // function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n    //     uint amountIn,\\r\\n    //     uint amountOutMin,\\r\\n    //     address[] calldata path,\\r\\n    //     address to,\\r\\n    //     uint deadline\\r\\n    // ) external;\\r\\n}\\r\\n\",\"keccak256\":\"0x051dc391ac5fabe026da3d93d923b20cf44fb21ac37b704b124e112571416d57\"},\"contracts/swap/interface/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU General Public License for more details.\\r\\n\\r\\n// You should have received a copy of the GNU General Public License\\r\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\r\\npragma solidity ^0.5.16;\\r\\n\\r\\ninterface IERC20 {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    function totalSupply() external view returns (uint);\\r\\n\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n}\\r\\n\",\"keccak256\":\"0x6af6c0ec0fad3bcd6dec9d55b9449d41f167a76dcffd2d031d95b8584234a96f\"},\"contracts/swap/interface/IWHT.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU General Public License for more details.\\r\\n\\r\\n// You should have received a copy of the GNU General Public License\\r\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\r\\npragma solidity ^0.5.16;\\r\\n\\r\\ninterface IWHT {\\r\\n    function deposit() external payable;\\r\\n\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n\\r\\n    function withdraw(uint) external;\\r\\n}\",\"keccak256\":\"0x6705de506bd6793b02ea1232da806105dd8848fb109f8438752f5f0ad50937f4\"},\"contracts/swap/interface/LErc20DelegatorInterface.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.5.16;\\r\\n// import \\\"./CTokenInterfaces.sol\\\";\\r\\n\\r\\ncontract LErc20DelegatorInterface {\\r\\n      function delegateToInitialize(address underlying_,\\r\\n                address comptroller_,\\r\\n                address interestRateModel_,\\r\\n                uint initialExchangeRateMantissa_,\\r\\n                string memory name_,\\r\\n                string memory symbol_,\\r\\n                uint8 decimals_,\\r\\n                address payable admin_,\\r\\n                address implementation_,\\r\\n                bytes memory becomeImplementationData) public {}\\r\\n\\r\\n      // get or create ctoken\\r\\n      function getCTokenAddress(address token) external returns (address cToken);\\r\\n      function getCTokenAddressPure(address cToken) external view returns (address);\\r\\n      function getTokenAddress(address cToken) external view returns (address);\\r\\n}\",\"keccak256\":\"0x0ec2ea88c8e362374d0bf6560f1a2fbf077418bf244d67601714c5bd0bef738c\"},\"contracts/swap/library/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU General Public License for more details.\\r\\n\\r\\n// You should have received a copy of the GNU General Public License\\r\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\r\\npragma solidity >=0.5.16;\\r\\n\\r\\nlibrary SafeMath {\\r\\n    uint256 constant WAD = 10 ** 18;\\r\\n    uint256 constant RAY = 10 ** 27;\\r\\n\\r\\n    function wad() public pure returns (uint256) {\\r\\n        return WAD;\\r\\n    }\\r\\n\\r\\n    function ray() public pure returns (uint256) {\\r\\n        return RAY;\\r\\n    }\\r\\n\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a <= b ? a : b;\\r\\n    }\\r\\n\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a >= b ? a : b;\\r\\n    }\\r\\n\\r\\n    function sqrt(uint256 a) internal pure returns (uint256 b) {\\r\\n        if (a > 3) {\\r\\n            b = a;\\r\\n            uint256 x = a / 2 + 1;\\r\\n            while (x < b) {\\r\\n                b = x;\\r\\n                x = (a / x + x) / 2;\\r\\n            }\\r\\n        } else if (a != 0) {\\r\\n            b = 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function wmul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mul(a, b) / WAD;\\r\\n    }\\r\\n\\r\\n    function wmulRound(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return add(mul(a, b), WAD / 2) / WAD;\\r\\n    }\\r\\n\\r\\n    function rmul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mul(a, b) / RAY;\\r\\n    }\\r\\n\\r\\n    function rmulRound(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return add(mul(a, b), RAY / 2) / RAY;\\r\\n    }\\r\\n\\r\\n    function wdiv(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(mul(a, WAD), b);\\r\\n    }\\r\\n\\r\\n    function wdivRound(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return add(mul(a, WAD), b / 2) / b;\\r\\n    }\\r\\n\\r\\n    function rdiv(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(mul(a, RAY), b);\\r\\n    }\\r\\n\\r\\n    function rdivRound(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return add(mul(a, RAY), b / 2) / b;\\r\\n    }\\r\\n\\r\\n    function wpow(uint256 x, uint256 n) internal pure returns (uint256) {\\r\\n        uint256 result = WAD;\\r\\n        while (n > 0) {\\r\\n            if (n % 2 != 0) {\\r\\n                result = wmul(result, x);\\r\\n            }\\r\\n            x = wmul(x, x);\\r\\n            n /= 2;\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256) {\\r\\n        uint256 result = RAY;\\r\\n        while (n > 0) {\\r\\n            if (n % 2 != 0) {\\r\\n                result = rmul(result, x);\\r\\n            }\\r\\n            x = rmul(x, x);\\r\\n            n /= 2;\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x0c7e1a7a5da3ee30685e48bab7278850c145f9e4dd607ab4852e14c3c4de6477\"}},\"version\":1}",
  "bytecode": "0x610ef0610026600b82828239805160001a60731461001957fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100615760003560e01c80635c4410d3146100665780638f56ed841461018d578063c61e0e3c14610259578063d848411f1461035a578063f53e73b9146103b2575b600080fd5b610132600480360360a081101561007c57600080fd5b6001600160a01b03823581169260208101359091169160408201359190810190608081016060820135600160201b8111156100b657600080fd5b8201836020820111156100c857600080fd5b803590602001918460208302840111600160201b831117156100e957600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250929550505090356001600160a01b031691506103d89050565b6040518080602001838152602001828103825284818151815260200191508051906020019060200280838360005b83811015610178578181015183820152602001610160565b50505050905001935050505060405180910390f35b610132600480360360a08110156101a357600080fd5b6001600160a01b03823581169260208101359091169160408201359190810190608081016060820135600160201b8111156101dd57600080fd5b8201836020820111156101ef57600080fd5b803590602001918460208302840111600160201b8311171561021057600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250929550505090356001600160a01b031691506106019050565b61030a6004803603604081101561026f57600080fd5b6001600160a01b038235169190810190604081016020820135600160201b81111561029957600080fd5b8201836020820111156102ab57600080fd5b803590602001918460208302840111600160201b831117156102cc57600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295506107e8945050505050565b60408051602080825283518183015283519192839290830191858101910280838360005b8381101561034657818101518382015260200161032e565b505050509050019250505060405180910390f35b6103a0600480360360a081101561037057600080fd5b506001600160a01b03813581169160208101358216916040820135916060810135821691608090910135166108f2565b60408051918252519081900360200190f35b6103a0600480360360208110156103c857600080fd5b50356001600160a01b0316610ac5565b6060600060606103e887866107e8565b90506000610409826000815181106103fc57fe5b6020026020010151610ac5565b90506000610435826104298a670de0b6b3a764000063ffffffff610c6016565b9063ffffffff610cc016565b9050896001600160a01b031663d2b364c68289896040518463ffffffff1660e01b81526004018084815260200180602001836001600160a01b03166001600160a01b03168152602001828103825284818151815260200191508051906020019060200280838360005b838110156104b657818101518382015260200161049e565b5050505090500194505050505060006040518083038186803b1580156104db57600080fd5b505afa1580156104ef573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052602081101561051857600080fd5b8101908080516040519392919084600160201b82111561053757600080fd5b90830190602082018581111561054c57600080fd5b82518660208202830111600160201b8211171561056857600080fd5b82525081516020918201928201910280838360005b8381101561059557818101518382015260200161057d565b50505050905001604052505050945060006105b9846001865103815181106103fc57fe5b90506105f1670de0b6b3a7640000610429838960018b5103815181106105db57fe5b6020026020010151610c6090919063ffffffff16565b9450505050509550959350505050565b60606000606061061187866107e8565b90506000610628826001845103815181106103fc57fe5b90506000610648826104298a670de0b6b3a764000063ffffffff610c6016565b9050896001600160a01b0316630c49bd138289896040518463ffffffff1660e01b81526004018084815260200180602001836001600160a01b03166001600160a01b03168152602001828103825284818151815260200191508051906020019060200280838360005b838110156106c95781810151838201526020016106b1565b5050505090500194505050505060006040518083038186803b1580156106ee57600080fd5b505afa158015610702573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052602081101561072b57600080fd5b8101908080516040519392919084600160201b82111561074a57600080fd5b90830190602082018581111561075f57600080fd5b82518660208202830111600160201b8211171561077b57600080fd5b82525081516020918201928201910280838360005b838110156107a8578181015183820152602001610790565b50505050905001604052505050945060006107c9846000815181106103fc57fe5b90506105f1670de0b6b3a764000061042983896000815181106105db57fe5b6060808251604051908082528060200260200182016040528015610816578160200160208202803883390190505b50905060005b83518110156108e857846001600160a01b031663e297943e85838151811061084057fe5b60200260200101516040518263ffffffff1660e01b815260040180826001600160a01b03166001600160a01b0316815260200191505060206040518083038186803b15801561088e57600080fd5b505afa1580156108a2573d6000803e3d6000fd5b505050506040513d60208110156108b857600080fd5b505182518390839081106108c857fe5b6001600160a01b039092166020928302919091019091015260010161081c565b5090505b92915050565b6040805163354aedbd60e21b81526001600160a01b03848116600483015283811660248301528251600093849384938b169263d52bb6f492604480840193919291829003018186803b15801561094757600080fd5b505afa15801561095b573d6000803e3d6000fd5b505050506040513d604081101561097157600080fd5b5080516020918201516040805163714bca1f60e11b81526001600160a01b038a81166004830152915193965091945060009384938493928d169263e297943e926024808301939192829003018186803b1580156109cd57600080fd5b505afa1580156109e1573d6000803e3d6000fd5b505050506040513d60208110156109f757600080fd5b50516040805163714bca1f60e11b81526001600160a01b038a811660048301529151929350600092918d169163e297943e91602480820192602092909190829003018186803b158015610a4957600080fd5b505afa158015610a5d573d6000803e3d6000fd5b505050506040513d6020811015610a7357600080fd5b50519050610a8082610ac5565b9350610a8b81610ac5565b9250610ab79150859050610429848185610aab8e8a63ffffffff610c6016565b9063ffffffff610c6016565b9a9950505050505050505050565b6000808290506000816001600160a01b031663182df0f56040518163ffffffff1660e01b815260040160206040518083038186803b158015610b0657600080fd5b505afa158015610b1a573d6000803e3d6000fd5b505050506040513d6020811015610b3057600080fd5b505160408051630ae9d70b60e41b815290519192506000916001600160a01b0385169163ae9d70b0916004808301926020929190829003018186803b158015610b7857600080fd5b505afa158015610b8c573d6000803e3d6000fd5b505050506040513d6020811015610ba257600080fd5b505160408051636c540baf60e01b815290519192506000916001600160a01b03861691636c540baf916004808301926020929190829003018186803b158015610bea57600080fd5b505afa158015610bfe573d6000803e3d6000fd5b505050506040513d6020811015610c1457600080fd5b505190506000610c2a438363ffffffff610d0216565b90506000610c4282610aab878763ffffffff610c6016565b9050610c54858263ffffffff610d4416565b98975050505050505050565b600082610c6f575060006108ec565b82820282848281610c7c57fe5b0414610cb95760405162461bcd60e51b8152600401808060200182810382526021815260200180610e9b6021913960400191505060405180910390fd5b9392505050565b6000610cb983836040518060400160405280601a81526020017f536166654d6174683a206469766973696f6e206279207a65726f000000000000815250610d9e565b6000610cb983836040518060400160405280601e81526020017f536166654d6174683a207375627472616374696f6e206f766572666c6f770000815250610e40565b600082820183811015610cb9576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b60008183610e2a5760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b83811015610def578181015183820152602001610dd7565b50505050905090810190601f168015610e1c5780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b506000838581610e3657fe5b0495945050505050565b60008184841115610e925760405162461bcd60e51b8152602060048201818152835160248401528351909283926044909101919085019080838360008315610def578181015183820152602001610dd7565b50505090039056fe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f77a265627a7a7231582043878548c205dc04ce7841370a517658fe303de735ca5d43ab77297ddb66c16a64736f6c63430005100032",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100615760003560e01c80635c4410d3146100665780638f56ed841461018d578063c61e0e3c14610259578063d848411f1461035a578063f53e73b9146103b2575b600080fd5b610132600480360360a081101561007c57600080fd5b6001600160a01b03823581169260208101359091169160408201359190810190608081016060820135600160201b8111156100b657600080fd5b8201836020820111156100c857600080fd5b803590602001918460208302840111600160201b831117156100e957600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250929550505090356001600160a01b031691506103d89050565b6040518080602001838152602001828103825284818151815260200191508051906020019060200280838360005b83811015610178578181015183820152602001610160565b50505050905001935050505060405180910390f35b610132600480360360a08110156101a357600080fd5b6001600160a01b03823581169260208101359091169160408201359190810190608081016060820135600160201b8111156101dd57600080fd5b8201836020820111156101ef57600080fd5b803590602001918460208302840111600160201b8311171561021057600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250929550505090356001600160a01b031691506106019050565b61030a6004803603604081101561026f57600080fd5b6001600160a01b038235169190810190604081016020820135600160201b81111561029957600080fd5b8201836020820111156102ab57600080fd5b803590602001918460208302840111600160201b831117156102cc57600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295506107e8945050505050565b60408051602080825283518183015283519192839290830191858101910280838360005b8381101561034657818101518382015260200161032e565b505050509050019250505060405180910390f35b6103a0600480360360a081101561037057600080fd5b506001600160a01b03813581169160208101358216916040820135916060810135821691608090910135166108f2565b60408051918252519081900360200190f35b6103a0600480360360208110156103c857600080fd5b50356001600160a01b0316610ac5565b6060600060606103e887866107e8565b90506000610409826000815181106103fc57fe5b6020026020010151610ac5565b90506000610435826104298a670de0b6b3a764000063ffffffff610c6016565b9063ffffffff610cc016565b9050896001600160a01b031663d2b364c68289896040518463ffffffff1660e01b81526004018084815260200180602001836001600160a01b03166001600160a01b03168152602001828103825284818151815260200191508051906020019060200280838360005b838110156104b657818101518382015260200161049e565b5050505090500194505050505060006040518083038186803b1580156104db57600080fd5b505afa1580156104ef573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052602081101561051857600080fd5b8101908080516040519392919084600160201b82111561053757600080fd5b90830190602082018581111561054c57600080fd5b82518660208202830111600160201b8211171561056857600080fd5b82525081516020918201928201910280838360005b8381101561059557818101518382015260200161057d565b50505050905001604052505050945060006105b9846001865103815181106103fc57fe5b90506105f1670de0b6b3a7640000610429838960018b5103815181106105db57fe5b6020026020010151610c6090919063ffffffff16565b9450505050509550959350505050565b60606000606061061187866107e8565b90506000610628826001845103815181106103fc57fe5b90506000610648826104298a670de0b6b3a764000063ffffffff610c6016565b9050896001600160a01b0316630c49bd138289896040518463ffffffff1660e01b81526004018084815260200180602001836001600160a01b03166001600160a01b03168152602001828103825284818151815260200191508051906020019060200280838360005b838110156106c95781810151838201526020016106b1565b5050505090500194505050505060006040518083038186803b1580156106ee57600080fd5b505afa158015610702573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052602081101561072b57600080fd5b8101908080516040519392919084600160201b82111561074a57600080fd5b90830190602082018581111561075f57600080fd5b82518660208202830111600160201b8211171561077b57600080fd5b82525081516020918201928201910280838360005b838110156107a8578181015183820152602001610790565b50505050905001604052505050945060006107c9846000815181106103fc57fe5b90506105f1670de0b6b3a764000061042983896000815181106105db57fe5b6060808251604051908082528060200260200182016040528015610816578160200160208202803883390190505b50905060005b83518110156108e857846001600160a01b031663e297943e85838151811061084057fe5b60200260200101516040518263ffffffff1660e01b815260040180826001600160a01b03166001600160a01b0316815260200191505060206040518083038186803b15801561088e57600080fd5b505afa1580156108a2573d6000803e3d6000fd5b505050506040513d60208110156108b857600080fd5b505182518390839081106108c857fe5b6001600160a01b039092166020928302919091019091015260010161081c565b5090505b92915050565b6040805163354aedbd60e21b81526001600160a01b03848116600483015283811660248301528251600093849384938b169263d52bb6f492604480840193919291829003018186803b15801561094757600080fd5b505afa15801561095b573d6000803e3d6000fd5b505050506040513d604081101561097157600080fd5b5080516020918201516040805163714bca1f60e11b81526001600160a01b038a81166004830152915193965091945060009384938493928d169263e297943e926024808301939192829003018186803b1580156109cd57600080fd5b505afa1580156109e1573d6000803e3d6000fd5b505050506040513d60208110156109f757600080fd5b50516040805163714bca1f60e11b81526001600160a01b038a811660048301529151929350600092918d169163e297943e91602480820192602092909190829003018186803b158015610a4957600080fd5b505afa158015610a5d573d6000803e3d6000fd5b505050506040513d6020811015610a7357600080fd5b50519050610a8082610ac5565b9350610a8b81610ac5565b9250610ab79150859050610429848185610aab8e8a63ffffffff610c6016565b9063ffffffff610c6016565b9a9950505050505050505050565b6000808290506000816001600160a01b031663182df0f56040518163ffffffff1660e01b815260040160206040518083038186803b158015610b0657600080fd5b505afa158015610b1a573d6000803e3d6000fd5b505050506040513d6020811015610b3057600080fd5b505160408051630ae9d70b60e41b815290519192506000916001600160a01b0385169163ae9d70b0916004808301926020929190829003018186803b158015610b7857600080fd5b505afa158015610b8c573d6000803e3d6000fd5b505050506040513d6020811015610ba257600080fd5b505160408051636c540baf60e01b815290519192506000916001600160a01b03861691636c540baf916004808301926020929190829003018186803b158015610bea57600080fd5b505afa158015610bfe573d6000803e3d6000fd5b505050506040513d6020811015610c1457600080fd5b505190506000610c2a438363ffffffff610d0216565b90506000610c4282610aab878763ffffffff610c6016565b9050610c54858263ffffffff610d4416565b98975050505050505050565b600082610c6f575060006108ec565b82820282848281610c7c57fe5b0414610cb95760405162461bcd60e51b8152600401808060200182810382526021815260200180610e9b6021913960400191505060405180910390fd5b9392505050565b6000610cb983836040518060400160405280601a81526020017f536166654d6174683a206469766973696f6e206279207a65726f000000000000815250610d9e565b6000610cb983836040518060400160405280601e81526020017f536166654d6174683a207375627472616374696f6e206f766572666c6f770000815250610e40565b600082820183811015610cb9576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b60008183610e2a5760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b83811015610def578181015183820152602001610dd7565b50505050905090810190601f168015610e1c5780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b506000838581610e3657fe5b0495945050505050565b60008184841115610e925760405162461bcd60e51b8152602060048201818152835160248401528351909283926044909101919085019080838360008315610def578181015183820152602001610dd7565b50505090039056fe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f77a265627a7a7231582043878548c205dc04ce7841370a517658fe303de735ca5d43ab77297ddb66c16a64736f6c63430005100032",
  "devdoc": {
    "methods": {
      "getAmountsInUnderlying(address,address,uint256,address[],address)": {
        "details": "给定 amountOut, 计算输入的amountIn",
        "params": {
          "path": "token 数组, 注意: 必须是token的地址!!!"
        }
      },
      "getAmountsOutUnderlying(address,address,uint256,address[],address)": {
        "details": "给定 amountIn, 计算能够兑换得到的amountOut",
        "params": {
          "path": "token 数组, 注意: 必须是token的地址!!!"
        }
      }
    }
  },
  "userdoc": {
    "methods": {}
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}