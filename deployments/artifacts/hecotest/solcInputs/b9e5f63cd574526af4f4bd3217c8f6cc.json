{
  "language": "Solidity",
  "sources": {
    "contracts/swap/aggressive2/StepSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./library/SafeMath.sol\";\r\nimport \"./library/DataTypes.sol\";\r\nimport \"./library/SwapFlag.sol\";\r\nimport \"./library/PathFinder.sol\";\r\nimport \"./interface/IWETH.sol\";\r\nimport \"./interface/ICToken.sol\";\r\nimport \"./interface/ILHT.sol\";\r\nimport \"./interface/ICTokenFactory.sol\";\r\nimport \"./interface/IFactory.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./Exchanges.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\n// 分步骤 swap, 可能的步骤\r\n// 0. despot eth/ht\r\n// 1. withdraw weth/wht\r\n// 2. mint token (compound)\r\n// 3. mint wht/ht (compound)\r\n// 4. redeem ctoken (compound)\r\n// 5. redeem wht/ht (compound)\r\n// 6. uniswap v1\r\n// 7. uniswap v2\r\n// 8. curve stable\r\n// 9. uniswap v3\r\n// \r\n//\r\n// tokenIn的情况:\r\n// 1. ht\r\n// 2. token\r\n// 3. ctoken\r\n//\r\n// tokenOut的情况:\r\n// 1. ht\r\n// 2. token\r\n// 3. ctoken\r\n// 4. cht\r\n//\r\n//\r\n// uniswap 只需要提供 router 地址，router 合约有 factory 地址\r\n// \r\n// exchange 的类型\r\n// 1. uniswap v1\r\n// 2. uniswap v2, direct by pair 直接使用pair交易\r\n// 3. uniswap v2, 使用router交易, 因为mdex可以交易挖矿\r\n// 4. curve\r\n//\r\n\r\ncontract StepSwapStorage {\r\n    mapping(uint => DataTypes.Exchange) public swaps;  // \r\n    uint public exchangeCount;  // exchange 数量\r\n    IWETH public weth;\r\n    ILHT public ceth;  // compound eth\r\n    ICTokenFactory public ctokenFactory;\r\n\r\n    uint internal constant _HALF_MAX_UINT = uint(-1) >> 1;                            // 0x8fffffffffff...\r\n}\r\n\r\n// contract StepSwap is BaseStepSwap {\r\ncontract StepSwap is Ownable, StepSwapStorage {\r\n    using SafeMath for uint;\r\n    using SafeMath for uint256;\r\n    using SwapFlag for DataTypes.SwapFlagMap;\r\n    \r\n    constructor(address _weth, address _ceth, address _factory) public {\r\n        weth = IWETH(_weth);\r\n        ceth = ILHT(_ceth);\r\n        ctokenFactory = ICTokenFactory(_factory);\r\n    }\r\n\r\n    receive() external payable {\r\n\r\n    }\r\n\r\n    function isTokenToken(address token) public view returns (bool) {\r\n        address ctoken = ctokenFactory.getCTokenAddressPure(token);\r\n        // 有对应的 ctoken 时, 一定是 token\r\n        if (ctoken != address(0)) {\r\n            return true;\r\n        }\r\n        // 没有对应的 ctoken 时, 有可能 token 是 ctoken, 也有可能是 token 没有对应的 ctoken 地址\r\n        if (ctokenFactory.getTokenAddress(token) != address(0)) {\r\n            // 是 ctoken, 存在对应的 token 地址\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _getCTokenAddressPure(address token) internal view returns (address ctoken) {\r\n        if (token == address(0)) {\r\n            return address(ceth);\r\n        }\r\n        return ctokenFactory.getCTokenAddressPure(token);\r\n    }\r\n\r\n    function _getTokenAddressPure(address ctoken) internal view returns (address token) {\r\n        if (token == address(ceth)) {\r\n            return address(0);\r\n        }\r\n        return ctokenFactory.getTokenAddress(ctoken);\r\n    }\r\n\r\n    /// @dev 根据入参交易对, midTokens, complex 计算 flag, routes, path列表, cpath列表\r\n    // 参数 midTokens 中不能包含 tokenIn/tokenOut 相同的 token\r\n    function getRoutesPaths(\r\n                    DataTypes.QuoteParams memory args\r\n                )\r\n                public\r\n                view\r\n                returns (\r\n                    // uint flag,\r\n                    uint routes,\r\n                    address[][] memory paths,\r\n                    address[][] memory cpaths,\r\n                    DataTypes.Exchange[] memory exchanges\r\n                    ) {\r\n        (routes, exchanges) = calcExchangeRoutes(args.midTokens.length, args.complex);\r\n\r\n        address ti = args.tokenIn;\r\n        address to = args.tokenOut;\r\n        address cti = args.tokenIn;\r\n        address cto = args.tokenOut;\r\n        if (args.tokenIn == address(0)) {\r\n            // flag = flag | SwapFlag.FLAG_TOKEN_IN_ETH;\r\n            cti = address(ceth);\r\n        } else if (isTokenToken(args.tokenIn)) {\r\n            // flag = flag | SwapFlag.FLAG_TOKEN_TOKEN;\r\n            cti = _getCTokenAddressPure(ti);\r\n        } else {\r\n            // flag = flag | SwapFlag.FLAG_TOKEN_CTOKEN;\r\n            ti = ctokenFactory.getTokenAddress(cti);\r\n        }\r\n\r\n        if (args.tokenOut == address(0)) {\r\n            // flag = flag | SwapFlag.FLAG_TOKEN_OUT_ETH;\r\n            cto = address(ceth);\r\n        } else if (isTokenToken(args.tokenOut)) {\r\n            // both token\r\n            require(isTokenToken(args.tokenIn) || args.tokenIn == address(0), \"both token in/out should be token\");\r\n            cto = _getCTokenAddressPure(to);\r\n        } else {\r\n            // both ctoken\r\n            require(isTokenToken(args.tokenIn) == false || args.tokenIn == address(0), \"both token in/out should be etoken\");\r\n            to = ctokenFactory.getTokenAddress(cto);\r\n        }\r\n\r\n        // flag = flag | ((args.mainRoutes & 0xff) << SwapFlag._SHIFT_MAIN_ROUTES);\r\n        // flag = flag | ((args.complex & 0x3) << SwapFlag._SHIFT_COMPLEX_LEVEL);\r\n        // flag = flag | (args.parts & 0xff);\r\n        // if (args.allowPartial) {\r\n        //     flag = flag | SwapFlag._MASK_PARTIAL_FILL;\r\n        // }\r\n        // if (args.allowBurnchi) {\r\n        //     flag = flag | SwapFlag._MASK_PARTIAL_FILL;\r\n        // }\r\n\r\n        if (ti == address(0)) {\r\n            ti = address(weth);\r\n        }\r\n        if (to == address(0)) {\r\n            to = address(weth);\r\n        }\r\n        // 排除 midToken 中与 tokenIn/tokenOut 相同的 token\r\n        address[] memory midCTokens = new address[](args.midTokens.length);\r\n        for (uint i = 0; i < args.midTokens.length; i ++) {\r\n            midCTokens[i] = _getCTokenAddressPure(args.midTokens[i]);\r\n        }\r\n        address[][] memory tmp = Exchanges.allPaths(ti, to, args.midTokens, args.complex);\r\n        paths = allSwapPaths(tmp);\r\n        tmp = Exchanges.allPaths(cti, cto, midCTokens, args.complex);\r\n        cpaths = allSwapPaths(tmp);\r\n    }\r\n\r\n    function allSwapPaths(\r\n                    address[][] memory ps\r\n                )\r\n                public\r\n                view\r\n                returns (address[][] memory paths) {\r\n        uint total = 0;\r\n        for (uint i = 0; i < exchangeCount; i ++) {\r\n            DataTypes.Exchange storage ex = swaps[i];\r\n\r\n            if (ex.contractAddr == address(0)) {\r\n                continue;\r\n            }\r\n            // DataTypes.Exchange memory ex = exchanges[i];\r\n            if (Exchanges.isUniswapLikeExchange(ex.exFlag)) {\r\n                total += ps.length;\r\n            } else {\r\n                // curve, etc\r\n                total ++;\r\n            }\r\n        }\r\n        paths = new address[][](total);\r\n        uint pIdx = 0;\r\n        for (uint i = 0; i < exchangeCount; i ++) {\r\n            DataTypes.Exchange storage ex = swaps[i];\r\n\r\n            if (ex.contractAddr == address(0)) {\r\n                continue;\r\n            }\r\n            if (Exchanges.isUniswapLikeExchange(ex.exFlag)) {\r\n                for (uint j = 0; j < ps.length; j ++) {\r\n                    paths[pIdx] = ps[j];\r\n                    pIdx ++;\r\n                }\r\n            } else {\r\n                // curve, etc\r\n                paths[pIdx] = new address[](1);\r\n                pIdx ++;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev 获取交易所的 reserve 数据及 exchangeRate\r\n    function getSwapReserveRates(\r\n                DataTypes.QuoteParams memory args\r\n            )\r\n            public\r\n            view\r\n            returns (DataTypes.SwapReserveRates memory params) {\r\n        require(exchangeCount > 0, \"no exchanges\");\r\n        // uint flag;\r\n        (\r\n            // flag,\r\n            params.routes,\r\n            params.paths,\r\n            params.cpaths,\r\n            params.exchanges\r\n        ) = getRoutesPaths(args);\r\n\r\n        console.log(\"routes: %d paths: %d exchanges: %d\", params.routes, params.paths.length, params.exchanges.length);\r\n        if (isTokenToken(args.tokenIn) || isTokenToken(args.tokenOut)) {\r\n            address ctokenIn = _getCTokenAddressPure(args.tokenIn);\r\n            address ctokenOut = _getCTokenAddressPure(args.tokenOut);\r\n            params.isEToken  = false;\r\n            params.tokenIn   = args.tokenIn;\r\n            params.tokenOut  = args.tokenOut;\r\n            params.etokenIn  = ctokenIn;\r\n            params.etokenOut = ctokenOut;\r\n            params.rateIn    = Exchanges.calcCTokenExchangeRate(ICToken(ctokenIn));\r\n            params.rateOut   = Exchanges.calcCTokenExchangeRate(ICToken(ctokenOut));\r\n        } else {\r\n            params.isEToken  = true;\r\n            params.etokenIn  = args.tokenIn;\r\n            params.etokenOut = args.tokenOut;\r\n            params.tokenIn   = ctokenFactory.getTokenAddress(args.tokenIn);\r\n            params.tokenOut  = ctokenFactory.getTokenAddress(args.tokenOut);\r\n            params.rateIn    = Exchanges.calcCTokenExchangeRate(ICToken(args.tokenIn));\r\n            params.rateOut   = Exchanges.calcCTokenExchangeRate(ICToken(args.tokenOut));\r\n        }\r\n\r\n        // console.log(\"exchange rate done\");\r\n        // params.routes = routes;\r\n        // params.paths = paths;\r\n        // params.cpaths = cpaths;\r\n        // params.exchanges = exchanges;\r\n\r\n        params.fees = new uint[](params.routes);\r\n        params.reserves = new uint[][][](params.routes);\r\n        for (uint i = 0; i < params.paths.length; i ++) {\r\n            DataTypes.Exchange memory ex = params.exchanges[i];\r\n            address[] memory path = params.paths[i];\r\n\r\n            // if (ex.contractAddr == address(0)) {\r\n            //     params.reserves[i] = new uint[](path.length);\r\n            //     continue;\r\n            // }\r\n\r\n            if (Exchanges.isUniswapLikeExchange(ex.exFlag)) {\r\n                if (Exchanges.isEBankExchange(ex.exFlag)) { // 必须先于 UniswapLike 的判断\r\n                    // todo set exchange fee\r\n                    params.fees[i] = 30;\r\n                    params.reserves[i] = Exchanges.getReserves(ex.contractAddr, params.cpaths[i]);\r\n                } else {\r\n                    // set exchange fee\r\n                    params.fees[i] = 30;\r\n                    params.reserves[i] = Exchanges.getReserves(ex.contractAddr, path);\r\n                }\r\n            } else {\r\n                // curve todo\r\n                params.fees[i] = 4;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev 根据入参, 生成交易参数\r\n    function buildSwapRouteSteps(\r\n                    DataTypes.SwapReserveRates memory args\r\n                )\r\n                public\r\n                view\r\n                returns (DataTypes.SwapParams memory params) {\r\n        uint steps = args.swapRoutes;\r\n\r\n        params.amountIn = args.amountIn;\r\n        if (args.isEToken) {\r\n            params.tokenIn = args.etokenIn;\r\n            params.tokenOut = args.etokenOut;\r\n            // etoken 且不完全由ebank 兑换时, step 增加两步: redeem 和 mint, mint 不计入 step 中\r\n            if (args.allEbank == false) {\r\n                steps += 1;\r\n            }\r\n        } else {\r\n            params.tokenIn = args.tokenIn;\r\n            params.tokenOut = args.tokenOut;\r\n        }\r\n        params.isEToken = args.isEToken;\r\n\r\n        uint stepIdx = 0;\r\n        params.steps = new DataTypes.StepExecuteParams[](steps);\r\n        if (args.isEToken && args.allEbank == false) {\r\n            // redeem to token\r\n            params.steps[stepIdx] = _buildCompoundRedeemStep(args.amountIn.sub(args.ebankAmt), args.etokenIn);\r\n            stepIdx ++;\r\n        }\r\n\r\n        if (args.ebankAmt > 0) {\r\n            // build ebank swap\r\n            address ebankRouter = _getEBankContract();\r\n            address[] memory path;\r\n            address[] memory cpath;\r\n            uint i = 0;\r\n            for (; i < args.distributes.length; i ++) {\r\n                if (args.distributes[i] == 0) {\r\n                    continue;\r\n                }\r\n\r\n                DataTypes.Exchange memory ex = args.exchanges[i];\r\n                if (Exchanges.isEBankExchange(ex.exFlag)) {\r\n                    path = args.paths[i];\r\n                    cpath = args.cpaths[i];\r\n                    break;\r\n                }\r\n            }\r\n            console.log(\"build ebank step: amt=%d\", args.ebankAmt);\r\n            require(i != args.distributes.length, \"no ebank\");\r\n            params.steps[stepIdx] = buildEbankSwapStep(\r\n                                                ebankRouter,\r\n                                                path,\r\n                                                cpath,\r\n                                                args.ebankAmt,\r\n                                                args.isEToken\r\n                                            );\r\n            stepIdx ++;\r\n        }\r\n\r\n        for (uint i = 0; i < args.distributes.length; i ++) {\r\n            if (args.distributes[i] == 0) {\r\n                continue;\r\n            }\r\n\r\n            DataTypes.Exchange memory ex = args.exchanges[i];\r\n            if (Exchanges.isEBankExchange(ex.exFlag)) {\r\n                continue;\r\n            }\r\n\r\n            if (Exchanges.isUniswapLikeExchange(ex.exFlag)) {\r\n                params.steps[stepIdx] = buildUniSwapStep(\r\n                                            ex.contractAddr,\r\n                                            args.paths[i],\r\n                                            args.distributes[i],\r\n                                            true\r\n                                        );\r\n            } else {\r\n                // todo curve, etc\r\n                DataTypes.StepExecuteParams memory step;\r\n                step.flag = 0;\r\n                params.steps[stepIdx] = step;\r\n            }\r\n\r\n            stepIdx ++;\r\n        }\r\n\r\n        // if (args.isEToken && args.allEbank == false) {\r\n        //     //\r\n        //     params.step[stepIdx] = _buildCompoundMintStep(0, args.etokenOut);\r\n        // }\r\n        params.block = block.number;\r\n    }\r\n\r\n    function _isETH(address token) private view returns (bool) {\r\n        if (token == address(weth) || token == address(0)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function _isCETH(address token) private view returns (bool) {\r\n        if (token == address(ceth) || token == address(0)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// 构建 ebank swap 参数\r\n    function buildEbankSwapStep(\r\n                    address router,\r\n                    address[] memory path,\r\n                    address[] memory cpath,\r\n                    uint256 amtIn,\r\n                    bool isEToken                // 是否是 token in token out\r\n                )\r\n                public\r\n                view\r\n                returns (DataTypes.StepExecuteParams memory step) {\r\n        DataTypes.UniswapRouterParam memory rp;\r\n        if (!isEToken) {\r\n            // underlying swap\r\n            address tokenIn = cpath[0];\r\n            address tokenOut = cpath[cpath.length-1];\r\n\r\n            if (_isCETH(tokenIn)) {\r\n                step.flag = DataTypes.STEP_EBANK_ROUTER_ETH_TOKENS;\r\n            } else if (_isCETH(tokenOut)) {\r\n                step.flag = DataTypes.STEP_EBANK_ROUTER_TOKENS_ETH;\r\n            } else {\r\n                step.flag = DataTypes.STEP_EBANK_ROUTER_TOKENS_TOKENS;\r\n            }\r\n            // underlying 时, path 必须是 token\r\n            rp.path = path;\r\n        } else {\r\n            step.flag = DataTypes.STEP_EBANK_ROUTER_CTOKENS_CTOKENS;\r\n            rp.path = cpath;\r\n        }\r\n\r\n        rp.contractAddr = router;\r\n        rp.amount = amtIn;\r\n\r\n        step.data = abi.encode(rp);\r\n    }\r\n\r\n    /// 构建 uniswap swap 参数\r\n    function buildUniSwapStep(\r\n                    address router,\r\n                    address[] memory path,\r\n                    uint256 amtIn,\r\n                    bool useRouter\r\n                )\r\n                public\r\n                view\r\n                returns (DataTypes.StepExecuteParams memory step) {\r\n            require(useRouter, \"must be router\");\r\n        // if (useRouter) {\r\n            address tokenIn = path[0];\r\n            address tokenOut = path[path.length-1];\r\n\r\n            if (_isETH(tokenIn)) {\r\n                step.flag = DataTypes.STEP_UNISWAP_ROUTER_ETH_TOKENS;\r\n            } else if (_isETH(tokenOut)) {\r\n                step.flag = DataTypes.STEP_UNISWAP_ROUTER_TOKENS_ETH;\r\n            } else {\r\n                step.flag = DataTypes.STEP_UNISWAP_ROUTER_TOKENS_TOKENS;\r\n            }\r\n            DataTypes.UniswapRouterParam memory rp;\r\n            rp.contractAddr = router;\r\n            rp.amount = amtIn;\r\n            rp.path = path;\r\n\r\n            step.data = abi.encode(rp);\r\n        // } else {\r\n            // IFactory factory = IFactory(IRouter(router).factory());\r\n            // DataTypes.UniswapPairParam memory rp;\r\n            // rp.amount = amtIn;\r\n            \r\n            // rp.pairs = new address[](path.length-1);\r\n            // for (uint i = 0; i < path.length-2; i ++) {\r\n            //     rp.pairs[i] = factory.getPair(path[i], path[i+1]);\r\n            // }\r\n\r\n            // step.flag = DataTypes.STEP_UNISWAP_PAIR_SWAP;\r\n            // step.data = abi.encode(rp);\r\n        // }\r\n    }\r\n\r\n    // 如果已经有 approve, 返回; 如果没有 approve, 执行 approve\r\n    function _approve(IERC20 tokenIn, address spender) private {\r\n        if (tokenIn.allowance(address(this), spender) < _HALF_MAX_UINT) {\r\n            tokenIn.approve(spender, uint(-1));\r\n        }\r\n    }\r\n\r\n    /*\r\n    function _doPairStep(address tokenIn, address tokenOut, uint amt, uint[] memory pairs) private {\r\n        if (tokenIn == address(0)) {\r\n            //\r\n            weth.deposit{value: amt}();\r\n            tokenIn = address(weth);\r\n        }\r\n        \r\n        TransferHelper.safeTransfer(tokenIn, pairs[i], amt);\r\n        uint amount = amt;\r\n\r\n        for (uint i = 0; i < pairs.length; i ++) {\r\n            address to;\r\n            bool reversed = (pairs[i] & DataTypes.REVERSE_SWAP_MASK) > 0;\r\n            address pair = address(pairs[i] & ADDRESS_MASK);\r\n\r\n            if (i == pairs.length - 1) {\r\n                to = address(this);\r\n            } else {\r\n                to = address(pairs[i+1] & ADDRESS_MASK);\r\n            }\r\n\r\n            if (reversed) {\r\n                IPair(pair).swap(0, amount, to, new bytes(0));\r\n            } else {\r\n                IPair(pair).swap(amount, 0, to, new bytes(0));\r\n            }\r\n        }\r\n\r\n        if (tokenOut == address(0)) {\r\n            //\r\n            weth.withdraw(IERC20(weth).balanceOf(address(this)));\r\n        }\r\n    }\r\n    */\r\n\r\n    function _doRouterSetp(uint flag, address tokenIn, address router, uint amt, address[] memory path, uint deadline) private {\r\n        // approve, swap\r\n            // DataTypes.UniswapRouterParam memory param = abi.decode(step.data, (DataTypes.UniswapRouterParam));\r\n            // address router = param.contractAddr;\r\n        console.log(\"_doRouterSetp flag:\", flag);\r\n        if (flag == DataTypes.STEP_UNISWAP_ROUTER_ETH_TOKENS || flag == DataTypes.STEP_EBANK_ROUTER_ETH_TOKENS) {\r\n            // eth\r\n            if (amt == 0) {\r\n                amt = address(this).balance;\r\n            }\r\n            if (flag == DataTypes.STEP_UNISWAP_ROUTER_ETH_TOKENS) {\r\n                IRouter(router).swapExactETHForTokens{value: amt}(0, path, address(this), deadline);\r\n            } else {\r\n                IDeBankRouter(router).swapExactETHForTokensUnderlying{value: amt}(0, path, address(this), deadline);\r\n            }\r\n        } else {\r\n            if (amt == 0) {\r\n                amt = IERC20(tokenIn).balanceOf(address(this));\r\n            }\r\n            // approve\r\n            _approve(IERC20(tokenIn), router);\r\n            if (flag == DataTypes.STEP_UNISWAP_ROUTER_TOKENS_TOKENS) {\r\n                console.log(\"uniswap token->token:\", path.length, amt, IERC20(tokenIn).balanceOf(address(this)));\r\n                IRouter(router).swapExactTokensForTokens(amt, 0, path, address(this), deadline);\r\n            } else if (flag == DataTypes.STEP_UNISWAP_ROUTER_TOKENS_ETH) {\r\n                IRouter(router).swapExactTokensForETH(amt, 0, path, address(this), deadline);\r\n            } else if (flag == DataTypes.STEP_EBANK_ROUTER_CTOKENS_CTOKENS) {\r\n                console.log(\"ebank ctoken->ctoken:\", path.length, amt, IERC20(tokenIn).balanceOf(address(this)));\r\n                IDeBankRouter(router).swapExactTokensForTokens(amt, 0, path, address(this), deadline);\r\n            } else if (flag == DataTypes.STEP_EBANK_ROUTER_TOKENS_TOKENS) {\r\n                console.log(\"ebank token->token:\", path.length, amt, IERC20(tokenIn).balanceOf(address(this)));\r\n                IDeBankRouter(router).swapExactTokensForTokensUnderlying(amt, 0, path, address(this), deadline);\r\n            } else {\r\n                // STEP_EBANK_ROUTER_TOKENS_ETH\r\n                require(flag == DataTypes.STEP_EBANK_ROUTER_TOKENS_ETH, \"invalid flag\");\r\n                IDeBankRouter(router).swapExactTokensForETHUnderlying(amt, 0, path, address(this), deadline);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /// @dev 根据参数执行兑换\r\n    // 用户需要授权\r\n    function unoswap(DataTypes.SwapParams memory args) public payable {\r\n        address tokenIn = args.tokenIn;\r\n\r\n        if (tokenIn == address(0)) {\r\n            require(msg.value >= args.amountIn, \"not enough value\");\r\n        } else {\r\n            // transfer\r\n            TransferHelper.safeTransferFrom(tokenIn, msg.sender, address(this), args.amountIn);\r\n        }\r\n\r\n        console.log(\"transfer to stepswap success, steps: %d amountIn: %d\", args.steps.length, args.amountIn);\r\n\r\n        address tokenOut = args.tokenOut;\r\n        // solhint-disable-next-line\r\n        uint deadline = block.timestamp + 600;\r\n        if (args.isEToken) {\r\n            // 是否需要 redeem\r\n            uint stepIdx = 0;\r\n            uint endIdx = args.steps.length;\r\n            bool redeemMint = false;\r\n            uint total = 0;   // total redeemed\r\n            uint originAmt = 0;\r\n            if (args.steps[0].flag == DataTypes.STEP_COMPOUND_REDEEM_TOKEN) {\r\n                redeemMint = true;\r\n                stepIdx ++;\r\n                endIdx -= 1;\r\n                DataTypes.CompoundRedeemParam memory rp = abi.decode(args.steps[0].data, (DataTypes.CompoundRedeemParam));\r\n                // _approve(tokenIn, spender);\r\n                ICToken(rp.ctoken).redeem(rp.amount);\r\n                originAmt = rp.amount;\r\n                if (rp.ctoken == address(ceth)) {\r\n                    total = address(this).balance;\r\n                } else {\r\n                    address token = ctokenFactory.getTokenAddress(rp.ctoken);\r\n                    total = IERC20(token).balanceOf(address(this));\r\n                }\r\n            }\r\n\r\n            // 如果有 ebank swap, 必定在第一个\r\n            if (args.amountIn > originAmt) {\r\n                _approve(IERC20(tokenIn), address(this));\r\n                DataTypes.UniswapRouterParam memory param = abi.decode(args.steps[stepIdx].data, (DataTypes.UniswapRouterParam));\r\n                IDeBankRouter(param.contractAddr).swapExactTokensForTokens(param.amount, 0, param.path, address(this), deadline);\r\n                stepIdx ++;\r\n            }\r\n\r\n            address ctokenIn = _getTokenAddressPure(tokenIn);\r\n            for (; stepIdx < endIdx; stepIdx ++) {\r\n                // 根据不同情况, 计算不同的交易数量\r\n                uint amount = 0;\r\n                DataTypes.StepExecuteParams memory step = args.steps[stepIdx];\r\n                // if (step.flag == DataTypes.STEP_UNISWAP_PAIR_SWAP) {\r\n                //     DataTypes.UniswapPairParam memory param = abi.decode(step.data, (DataTypes.UniswapPairParam));\r\n                //     if (stepIdx != endIdx - 1) {\r\n                //         amount = param.amount.mul(total).div(originAmt);\r\n                //     }\r\n                //     _doPairStep(ctokenIn, amount, param.pairs);\r\n                // } else {\r\n                    DataTypes.UniswapRouterParam memory param = abi.decode(step.data, (DataTypes.UniswapRouterParam));\r\n                    if (stepIdx != endIdx - 1) {\r\n                        amount = param.amount.mul(total).div(originAmt);\r\n                    }\r\n                    _doRouterSetp(step.flag, ctokenIn, param.contractAddr, amount, param.path, deadline);\r\n                // }\r\n            }\r\n\r\n            if (redeemMint) {\r\n                // mint to ctoken\r\n                if (tokenOut == address(ceth)) {\r\n                    uint amt = address(this).balance;\r\n                    ceth.mint{value: amt}();\r\n                } else {\r\n                    address token = ctokenFactory.getTokenAddress(tokenOut);\r\n                    _approve(IERC20(token), tokenOut);\r\n                    ICToken(tokenOut).mint(IERC20(token).balanceOf(address(this)));\r\n                }\r\n            }\r\n        } else {\r\n            // 没有 redeem/mint操作, 不需要考虑 amount 转换的问题\r\n            console.log(\"steps:\", args.steps.length);\r\n            for (uint i = 0; i < args.steps.length; i ++) {\r\n                uint flag = args.steps[i].flag;\r\n                console.log(\"swap %d %d\", i, flag);\r\n                DataTypes.StepExecuteParams memory step = args.steps[i];\r\n                // if (flag == DataTypes.STEP_UNISWAP_PAIR_SWAP) {\r\n                //     DataTypes.UniswapPairParam memory param = abi.decode(step.data, (DataTypes.UniswapPairParam));\r\n                //     _doPairStep(tokenIn, param.amount, param.pairs);\r\n                // } else {\r\n                    DataTypes.UniswapRouterParam memory param = abi.decode(step.data, (DataTypes.UniswapRouterParam));\r\n                    _doRouterSetp(flag, tokenIn, param.contractAddr, param.amount, param.path, deadline);\r\n                // }\r\n            }\r\n        }\r\n\r\n        /// \r\n        // transfer to user\r\n        if (args.tokenOut == address(0)) {\r\n            uint balance = address(this).balance;\r\n            require(balance >= args.minAmt, \"less than minAmt\");\r\n            console.log(\"eth balance:\", balance);\r\n            TransferHelper.safeTransferETH(msg.sender, balance);\r\n        } else {\r\n            uint balance = IERC20(tokenOut).balanceOf(address(this));\r\n            require(balance >= args.minAmt, \"less than minAmt\");\r\n            console.log(\"token balance:\", balance);\r\n            TransferHelper.safeTransfer(tokenOut, msg.sender, balance);\r\n        }\r\n    }\r\n\r\n    /// @dev 在给定中间交易对数量和复杂度的情况下, 有多少种兑换路径\r\n    function calcExchangeRoutes(\r\n                    uint midTokens,\r\n                    uint complexLevel\r\n                )\r\n                public\r\n                view\r\n                returns (uint total, DataTypes.Exchange[] memory exchanges) {\r\n        uint i;\r\n\r\n        // 计算一共有多少个 exchange routes\r\n        for (i = 0; i < exchangeCount; i ++) {\r\n            DataTypes.Exchange storage ex = swaps[i];\r\n\r\n            if (ex.contractAddr == address(0)) {\r\n                continue;\r\n            }\r\n\r\n            total += Exchanges.getExchangeRoutes(ex.exFlag, midTokens, complexLevel);\r\n        }\r\n        exchanges = new DataTypes.Exchange[](total);\r\n        uint exIdx = 0;\r\n        for (i = 0; i < exchangeCount; i ++) {\r\n            DataTypes.Exchange storage ex = swaps[i];\r\n\r\n            if (ex.contractAddr == address(0)) {\r\n                continue;\r\n            }\r\n\r\n            uint count = Exchanges.getExchangeRoutes(ex.exFlag, midTokens, complexLevel);\r\n            for (uint j = 0; j < count; j ++) {\r\n                exchanges[exIdx].exFlag = ex.exFlag;\r\n                exchanges[exIdx].contractAddr = ex.contractAddr;\r\n                exIdx ++;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /// @dev 扣除 gas 费用后得到的\r\n    /// @param amounts 未计算 gas 时兑换得到的数量\r\n    /// @param gas gas, 单位 GWei\r\n    /// @param tokenPriceGWei token 的价格相对于 GWei 的价格 token/ht * gas. 例如 tokenOut 为 usdt, eth 的价格为 2000 usdt, 此时, 将消耗的 gas 折算为\r\n    ///                       usdt, 然后再 amounts 中扣减\r\n    function _deductGasFee(\r\n                uint[] memory amounts,\r\n                uint gas,\r\n                uint tokenPriceGWei\r\n            )\r\n            internal\r\n            pure\r\n            returns(int[] memory) {\r\n        uint val = gas.mul(tokenPriceGWei);\r\n        int256[] memory deducted = new int256[](amounts.length);\r\n\r\n        for (uint i = 1; i < amounts.length; i ++) {\r\n            uint amt = amounts[i];\r\n            // if (amt > val) {\r\n                deducted[i] = int256(amt) - int256(val);\r\n            // } else {\r\n                // 负数\r\n                // deducted[i] = int256(amt).sub(int256(val));\r\n            // }\r\n        }\r\n\r\n        return deducted;\r\n    }\r\n\r\n    /// amt * part / totalParts\r\n    function _partAmount(uint amt, uint part, uint totalParts) private pure returns (uint) {\r\n        return amt.mul(part).div(totalParts);\r\n    }\r\n\r\n    function _getEBankContract() private view returns (address ebank) {\r\n        for (uint i = 0; i < exchangeCount; i ++) {\r\n            DataTypes.Exchange memory ex = swaps[i];\r\n            if (ex.exFlag == Exchanges.EXCHANGE_EBANK_EX && ex.contractAddr != address(0)) {\r\n                ebank = ex.contractAddr;\r\n                break;\r\n            }\r\n        }\r\n        require(ebank != address(0), \"not found ebank\");\r\n        return ebank;\r\n    }\r\n\r\n    function _buildCompoundMintStep(\r\n                uint amt,\r\n                address ctoken\r\n            )\r\n            private \r\n            view\r\n            returns (DataTypes.StepExecuteParams memory step) {\r\n        address token = ctokenFactory.getTokenAddress(ctoken);\r\n\r\n        // todo 是否可以用 weth 来做判断\r\n        if (token == address(0) || token == address(weth)) {\r\n            step.flag = DataTypes.STEP_COMPOUND_MINT_CETH;\r\n        } else {\r\n            step.flag = DataTypes.STEP_COMPOUND_MINT_CTOKEN;\r\n        }\r\n        DataTypes.CompoundRedeemParam memory rp;\r\n        rp.amount = amt;\r\n        rp.ctoken = ctoken;\r\n\r\n        step.data = abi.encode(rp);\r\n    }\r\n\r\n    /// @dev 构建 redeem 步骤的合约地址及参数\r\n    /// @param amt redeem amount, if 0, redeem all(balanceOf(address(this)))\r\n    function _buildCompoundRedeemStep(\r\n                uint amt,\r\n                address ctoken\r\n            )\r\n            private \r\n            pure\r\n            returns (DataTypes.StepExecuteParams memory step) {\r\n        // eth 和 token 都是调用同一个方法 redeem, 且参数相同, 因此，使用同一个 flag\r\n        step.flag = DataTypes.STEP_COMPOUND_REDEEM_TOKEN;\r\n        // }\r\n        DataTypes.CompoundRedeemParam memory rp;\r\n        rp.amount = amt;\r\n        rp.ctoken = ctoken;\r\n\r\n        step.data = abi.encode(rp);\r\n    }\r\n\r\n\r\n    function _buildEBankRouteStep(\r\n                uint flag,\r\n                uint amt,\r\n                address ebank,\r\n                address[] memory path\r\n                // bool direct\r\n            )\r\n            private \r\n            pure\r\n            returns (DataTypes.StepExecuteParams memory step) {\r\n        step.flag = flag;\r\n        DataTypes.UniswapRouterParam memory rp;\r\n        rp.amount = amt;\r\n        rp.contractAddr = ebank;\r\n        // if (direct) {\r\n        //     rp.to = sd.to;\r\n        // } else {\r\n            // rp.to = address(this);\r\n        // }\r\n        rp.path = path;\r\n        step.data = abi.encode(rp);\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    \r\n\r\n    function addSwap(uint flag, address addr) external onlyOwner {\r\n        DataTypes.Exchange storage ex = swaps[exchangeCount];\r\n        ex.exFlag = flag;\r\n        ex.contractAddr = addr;\r\n\r\n        exchangeCount ++;\r\n    }\r\n\r\n    function removeSwap(uint i) external onlyOwner {\r\n        DataTypes.Exchange storage ex = swaps[i];\r\n\r\n        ex.contractAddr = address(0);\r\n    }\r\n\r\n    function setWETH(address _weth) external onlyOwner {\r\n        weth = IWETH(_weth);\r\n    }\r\n\r\n    function setCETH(address _ceth) external onlyOwner {\r\n        ceth = ILHT(_ceth);\r\n    }\r\n\r\n    function setCtokenFactory(address factory) external onlyOwner {\r\n        ctokenFactory = ICTokenFactory(factory);\r\n    }\r\n}\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success,) = to.call{value: value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n"
    },
    "contracts/swap/aggressive2/library/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity >=0.6.12;\r\n\r\nlibrary SafeMath {\r\n    uint256 constant WAD = 10 ** 18;\r\n    uint256 constant RAY = 10 ** 27;\r\n\r\n    function wad() public pure returns (uint256) {\r\n        return WAD;\r\n    }\r\n\r\n    function ray() public pure returns (uint256) {\r\n        return RAY;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a <= b ? a : b;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function sqrt(uint256 a) internal pure returns (uint256 b) {\r\n        if (a > 3) {\r\n            b = a;\r\n            uint256 x = a / 2 + 1;\r\n            while (x < b) {\r\n                b = x;\r\n                x = (a / x + x) / 2;\r\n            }\r\n        } else if (a != 0) {\r\n            b = 1;\r\n        }\r\n    }\r\n\r\n    function wmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mul(a, b) / WAD;\r\n    }\r\n\r\n    function wmulRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, b), WAD / 2) / WAD;\r\n    }\r\n\r\n    function rmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mul(a, b) / RAY;\r\n    }\r\n\r\n    function rmulRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, b), RAY / 2) / RAY;\r\n    }\r\n\r\n    function wdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(mul(a, WAD), b);\r\n    }\r\n\r\n    function wdivRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, WAD), b / 2) / b;\r\n    }\r\n\r\n    function rdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(mul(a, RAY), b);\r\n    }\r\n\r\n    function rdivRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, RAY), b / 2) / b;\r\n    }\r\n\r\n    function wpow(uint256 x, uint256 n) internal pure returns (uint256) {\r\n        uint256 result = WAD;\r\n        while (n > 0) {\r\n            if (n % 2 != 0) {\r\n                result = wmul(result, x);\r\n            }\r\n            x = wmul(x, x);\r\n            n /= 2;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256) {\r\n        uint256 result = RAY;\r\n        while (n > 0) {\r\n            if (n % 2 != 0) {\r\n                result = rmul(result, x);\r\n            }\r\n            x = rmul(x, x);\r\n            n /= 2;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n"
    },
    "contracts/swap/aggressive2/library/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @title DataTypes library\r\n * @author ebankex\r\n * @notice Provides data types and functions to perform step swap calculations\r\n * @dev DataTypes are used for aggressive swap within multi swap exchanges.\r\n **/\r\n\r\nlibrary DataTypes {\r\n    // 步骤执行的动作类型\r\n    uint256 public constant STEP_DEPOSIT_ETH           = 0x0000000001; // prettier-ignore\r\n    uint256 public constant STEP_WITHDRAW_WETH         = 0x0000000002; // prettier-ignore\r\n    uint256 public constant STEP_COMPOUND_MINT_CTOKEN  = 0x0000000003; // prettier-ignore\r\n    uint256 public constant STEP_COMPOUND_MINT_CETH    = 0x0000000004; // prettier-ignore\r\n    uint256 public constant STEP_COMPOUND_REDEEM_TOKEN = 0x0000000005; // prettier-ignore\r\n    // uint256 public constant STEP_COMPOUND_REDEEM_ETH   = 0x0000000006; // prettier-ignore\r\n    uint256 public constant STEP_AAVE_DEPOSIT_ATOKEN   = 0x0000000007; // prettier-ignore\r\n    uint256 public constant STEP_AAVE_DEPOSIT_WETH     = 0x0000000008; // prettier-ignore\r\n    uint256 public constant STEP_AAVE_WITHDRAW_TOKEN   = 0x0000000009; // prettier-ignore\r\n    uint256 public constant STEP_AAVE_WITHDRAW_ETH     = 0x000000000a; // prettier-ignore\r\n\r\n    // uint256 public constant STEP_UNISWAP_PAIR_SWAP              = 0x0000000100; // prettier-ignore\r\n    uint256 public constant STEP_UNISWAP_ROUTER_TOKENS_TOKENS   = 0x000000011; // prettier-ignore\r\n    uint256 public constant STEP_UNISWAP_ROUTER_ETH_TOKENS      = 0x000000012; // prettier-ignore\r\n    uint256 public constant STEP_UNISWAP_ROUTER_TOKENS_ETH      = 0x000000013; // prettier-ignore\r\n    uint256 public constant STEP_EBANK_ROUTER_CTOKENS_CTOKENS   = 0x000000014;  // prettier-ignore same to STEP_UNISWAP_ROUTER_TOKENS_TOKENS\r\n    uint256 public constant STEP_EBANK_ROUTER_TOKENS_TOKENS     = 0x000000015;  // prettier-ignore underlying\r\n    uint256 public constant STEP_EBANK_ROUTER_ETH_TOKENS        = 0x000000016;  // prettier-ignore underlying\r\n    uint256 public constant STEP_EBANK_ROUTER_TOKENS_ETH        = 0x000000017;  // prettier-ignore underlying\r\n\r\n    uint256 public constant REVERSE_SWAP_MASK = 0x8000000000000000000000000000000000000000000000000000000000000000;\r\n    uint256 public constant ADDRESS_MASK      = 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff; // prettier-ignore\r\n\r\n    // todo slip, 16 bit, 分母: 10000\r\n    struct SwapFlagMap {\r\n        // bit 0-7 parts, 8 bit\r\n        // bit 8-63: flag token in/out, 64 bit\r\n        // bit 72-79 max main part, 8 bit\r\n        // bit 80-81 complex level, 2 bit\r\n        // bit 82    allow partial fill\r\n        // bit 83    allow burnChi\r\n        uint256 data;\r\n    }\r\n\r\n    /// @dev 询价 计算最佳兑换路径的入参\r\n    struct RoutePathParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        address[] midTokens;      // should always be token\r\n        uint256 mainRoutes;           // distributeCounts\r\n        uint256 complex;\r\n        uint256 parts;\r\n        bool allowPartial;\r\n        bool allowBurnchi;\r\n    }\r\n\r\n    /// @dev 询价 计算最佳兑换路径的入参\r\n    struct QuoteParams {\r\n        address to;\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint256 amountIn;\r\n        address[] midTokens;      // should always be token\r\n        uint256 mainRoutes;           // distributeCounts\r\n        uint256 complex;\r\n        uint256 parts;\r\n        // uint256 routes;           // distributeCounts\r\n        bool allowPartial;\r\n        bool allowBurnchi;\r\n        // uint256 tokenPriceGWei;\r\n        // address fromAddress;\r\n        // address dstReceiver;\r\n        // address[] midTokens;      // should always be token\r\n        // Exchange[]  exchanges;\r\n        // address[][] paths;        // 由 midTokens 和 复杂度计算得到的所有 path 列表\r\n        // address[][] cpaths;       // 由 midCTokens 和 复杂度计算得到的所有 cpath 列表\r\n        // SwapFlagMap flag;\r\n    }\r\n\r\n    // swap reserves; exchange rates\r\n    struct SwapReserveRates {\r\n        bool isEToken;\r\n        bool allowBurnchi;\r\n        bool allEbank;                  // 是否全部都由 ebank 兑换\r\n        uint256 ebankAmt;\r\n        uint256 amountIn;\r\n        uint256 swapRoutes;             // 最终经过多少个 route 来兑换\r\n        address tokenIn;\r\n        address tokenOut;\r\n        address etokenIn;\r\n        address etokenOut;\r\n        uint256 routes;                 // distributeCounts 交易所数量 * 路径数量\r\n        uint256 rateIn;\r\n        uint256 rateOut;\r\n        uint256[]  fees;\r\n        Exchange[]  exchanges;\r\n        address[][] paths;        // 由 midTokens 和 复杂度计算得到的所有 path 列表\r\n        address[][] cpaths;       // 由 midCTokens 和 复杂度计算得到的所有 cpath 列表\r\n        uint256[][][] reserves;     // [routes][path]\r\n        uint256[] distributes;    // 各个 swap 路径分配的兑换数量, 对于 ebank 是 etoken 的数量， 其他 swap 是 token 数量\r\n    }\r\n\r\n    struct UniswapRouterParam {\r\n        uint256 amount;\r\n        address contractAddr;\r\n        // address to;\r\n        address[] path;\r\n    }\r\n\r\n    struct CompoundRedeemParam {\r\n        uint256 amount;\r\n        // address to;\r\n        address ctoken;\r\n    }\r\n\r\n    struct UniswapPairParam {\r\n        uint256 amount;\r\n        address[] pairs;\r\n    }\r\n\r\n    // struct \r\n    struct StepExecuteParams {\r\n        uint256 flag;           // step execute flag 指示用哪种步骤去执行\r\n        bytes   data;\r\n    }\r\n\r\n    /// @dev 兑换 入参\r\n    struct SwapParams {\r\n        // address to;\r\n        // address tokenIn;\r\n        // address tokenOut;\r\n        // uint256 amountIn;\r\n        // uint256 amountOut;\r\n        // uint256 tokenPriceGWei;\r\n        // address fromAddress;\r\n        // address dstReceiver;\r\n        // address[] midTokens;  // should always be token\r\n        // SwapFlagMap flag;\r\n        // SwapFlagMap flag;\r\n        bool isEToken;\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint256 amountIn;\r\n        uint256 minAmt;\r\n        uint256 block;   // 计算结果的 block\r\n        StepExecuteParams[] steps;\r\n    }\r\n\r\n    /// @dev Exchange 交易所合约地址及交易所类型\r\n    struct Exchange {\r\n        uint exFlag;\r\n        address contractAddr;\r\n    }\r\n\r\n\r\n    /// @dev 计算各个交易所的每个parts的return\r\n    struct SwapDistributes {\r\n        bool        isCtoken;     // 买入、卖出的币是否是 ctoken\r\n        // bool     ctokenOut;    // 买到的币是否是 ctoken\r\n        address     to;           // 交易者地址\r\n        address     tokenIn;\r\n        address     tokenOut;\r\n        uint256     parts;        // 交易量拆分为多少份\r\n        uint256     rateIn;       // token in exchange rate\r\n        uint256     rateOut;      // token out exchange rate\r\n        uint[]      amounts;      // split into parts\r\n        uint[]      cAmounts;     // mint to ctoken amounts\r\n        // address[]   midTokens;    // middle token list\r\n        // address[]   midCTokens;   // middle ctoken list\r\n        address[][] paths;        // 由 midTokens 和 复杂度计算得到的所有 path 列表\r\n        address[][] cpaths;       // 由 midCTokens 和 复杂度计算得到的所有 cpath 列表\r\n\r\n        uint[]      gases;          // gas 费用估算\r\n        uint[]      pathIdx;        // 使用的 path 序号\r\n        uint[][]    distributes;    // 一级为交易路径, 二级为该交易路径的所有parts对应的return\r\n        int256[][]  netDistributes; // distributes - gases\r\n        Exchange[]  exchanges;\r\n    }\r\n}\r\n"
    },
    "contracts/swap/aggressive2/library/SwapFlag.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./DataTypes.sol\";\r\n\r\nlibrary SwapFlag {\r\n    uint256 public constant FLAG_TOKEN_IN_ETH          = 0x000000000100; // prettier-ignore\r\n    uint256 public constant FLAG_TOKEN_TOKEN           = 0x000000000200; // prettier-ignore\r\n    uint256 public constant FLAG_TOKEN_CTOKEN          = 0x000000000400; // prettier-ignore\r\n    uint256 public constant FLAG_TOKEN_OUT_ETH         = 0x000000000800; // prettier-ignore\r\n    // uint256 public constant FLAG_TOKEN_OUT_TOKEN       = 0x000000001000; // prettier-ignore\r\n    // uint256 public constant FLAG_TOKEN_OUT_CTOKEN      = 0x000000002000; // prettier-ignore\r\n    // uint256 public constant FLAG_TOKEN_OUT_CETH        = 0x0000000040; // prettier-ignore\r\n\r\n    uint256 internal constant _MASK_PARTS           = 0x00000000000000000000ff; // prettier-ignore\r\n    uint256 internal constant _MASK_MAIN_ROUTES     = 0x00ff000000000000000000; // prettier-ignore\r\n    uint256 internal constant _MASK_COMPLEX_LEVEL   = 0x0300000000000000000000; // prettier-ignore\r\n    uint256 internal constant _MASK_PARTIAL_FILL    = 0x0400000000000000000000; // prettier-ignore\r\n    uint256 internal constant _MASK_BURN_CHI        = 0x0800000000000000000000; // prettier-ignore\r\n\r\n    // uint256 internal constant _SHIFT_PARTS          = 64; // prettier-ignore\r\n    uint256 internal constant _SHIFT_MAIN_ROUTES    = 72; // prettier-ignore\r\n    uint256 internal constant _SHIFT_COMPLEX_LEVEL  = 80; // prettier-ignore\r\n\r\n    /// @dev if token in/out is token\r\n    function tokenIsToken(DataTypes.SwapFlagMap memory self) public pure returns (bool) {\r\n        return (self.data & FLAG_TOKEN_TOKEN) != 0;\r\n    }\r\n\r\n    function tokenIsToken(uint flag) public pure returns (bool) {\r\n        return (flag & FLAG_TOKEN_TOKEN) != 0;\r\n    }\r\n    \r\n    /// @dev if token in/out is ctoken\r\n    function tokenIsCToken(DataTypes.SwapFlagMap memory self) public pure returns (bool) {\r\n        return (self.data & FLAG_TOKEN_CTOKEN) != 0;\r\n    }\r\n\r\n    /// @dev if token in is ETH\r\n    function tokenInIsETH(DataTypes.SwapFlagMap memory self) public pure returns (bool) {\r\n        return (self.data & FLAG_TOKEN_IN_ETH) != 0;\r\n    }\r\n\r\n    /// @dev if token out is ETH\r\n    function tokenOutIsETH(DataTypes.SwapFlagMap memory self) public pure returns (bool) {\r\n        return (self.data & FLAG_TOKEN_OUT_ETH) != 0;\r\n    }\r\n\r\n    /// @dev get param split parts\r\n    function getParts(DataTypes.SwapFlagMap memory self) public pure returns (uint256) {\r\n        return (self.data & _MASK_PARTS);\r\n    }\r\n\r\n    /// @dev get param main routes max port\r\n    function getMainRoutes(DataTypes.SwapFlagMap memory self) public pure returns (uint256) {\r\n        return (self.data & _MASK_MAIN_ROUTES) >> _SHIFT_MAIN_ROUTES;\r\n    }\r\n\r\n    /// @dev get param complex level\r\n    function getComplexLevel(DataTypes.SwapFlagMap memory self) public pure returns (uint256) {\r\n        return (self.data & _MASK_COMPLEX_LEVEL) >> _SHIFT_COMPLEX_LEVEL;\r\n    }\r\n\r\n    /// @dev get param allow partial fill\r\n    function allowPartialFill(DataTypes.SwapFlagMap memory self) public pure returns (bool) {\r\n        return (self.data & _MASK_PARTIAL_FILL) != 0;\r\n    }\r\n\r\n    /// @dev get param burn CHI\r\n    function burnCHI(DataTypes.SwapFlagMap memory self) public pure returns (bool) {\r\n        return (self.data & _MASK_BURN_CHI) != 0;\r\n    }\r\n}\r\n"
    },
    "contracts/swap/aggressive2/library/PathFinder.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\n/// @dev 寻找最优路径\r\n\r\nlibrary PathFinder {\r\n    function findBestDistribution(\r\n        uint256 s,                // parts\r\n        int256[][] memory amounts // exchangesReturns\r\n    )\r\n        public\r\n        view\r\n        returns(\r\n            int256 returnAmount,\r\n            uint256[] memory distribution\r\n        )\r\n    {\r\n        uint256 n = amounts.length;\r\n\r\n        int256[][] memory answer = new int256[][](n); // int[n][s+1]\r\n        uint256[][] memory parent = new uint256[][](n); // int[n][s+1]\r\n\r\n        for (uint i = 0; i < n; i++) {\r\n            answer[i] = new int256[](s + 1);\r\n            parent[i] = new uint256[](s + 1);\r\n        }\r\n        // console.log(\"amounts length:\", n, s, amounts[0].length);\r\n\r\n        for (uint j = 0; j <= s; j++) {\r\n            answer[0][j] = amounts[0][j];\r\n            for (uint i = 1; i < n; i++) {\r\n                answer[i][j] = 0;\r\n            }\r\n            parent[0][j] = 0;\r\n        }\r\n        // console.log(\"amounts length 2:\", n, s, amounts[0].length);\r\n\r\n        for (uint i = 1; i < n; i++) {\r\n            for (uint j = 0; j <= s; j++) {\r\n                answer[i][j] = answer[i - 1][j];\r\n                parent[i][j] = j;\r\n\r\n                for (uint k = 1; k <= j; k++) {\r\n                    if (answer[i - 1][j - k] + amounts[i][k] > answer[i][j]) {\r\n                        answer[i][j] = answer[i - 1][j - k] + amounts[i][k];\r\n                        parent[i][j] = j - k;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        console.log(\"amounts length 3:\", n, s, amounts[0].length);\r\n\r\n        distribution = new uint256[](n);\r\n\r\n        uint256 partsLeft = s;\r\n        for (uint curExchange = n - 1; partsLeft > 0; curExchange--) {\r\n            distribution[curExchange] = partsLeft - parent[curExchange][partsLeft];\r\n            partsLeft = parent[curExchange][partsLeft];\r\n        }\r\n\r\n        returnAmount = (answer[n - 1][s] <= 0) ? int256(0) : answer[n - 1][s];\r\n        console.log(\"return amount:\", uint(returnAmount));\r\n        for (uint i = 0; i < n; i ++) {\r\n            console.log(\"distribution[%d]: %d %d\", i, distribution[i], uint(amounts[i][s]));\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/swap/aggressive2/interface/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.12;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\n\r\nabstract contract IWETH is IERC20 {\r\n    function deposit() external virtual payable;\r\n\r\n    function withdraw(uint256 amount) external virtual;\r\n}\r\n"
    },
    "contracts/swap/aggressive2/interface/ICToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface ICToken {\r\n\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n\r\n    function transfer(address dst, uint amount) external returns (bool);\r\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function balanceOfUnderlying(address owner) external returns (uint);\r\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\r\n    function borrowRatePerBlock() external view returns (uint);\r\n    function supplyRatePerBlock() external view returns (uint);\r\n    function totalBorrowsCurrent() external returns (uint);\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function borrowBalanceStored(address account) external view returns (uint);\r\n    function exchangeRateCurrent() external returns (uint);\r\n    function exchangeRateStored() external view returns (uint);\r\n    function getCash() external view returns (uint);\r\n    function accrueInterest() external returns (uint);\r\n    function accrualBlockNumber() external view returns (uint);\r\n    // function getCash() virtual external view returns (uint);\r\n    // function accrueInterest() virtual public returns (uint);\r\n    // function seize(address liquidator, address borrower, uint seizeTokens) virtual external returns (uint);\r\n\r\n}\r\n"
    },
    "contracts/swap/aggressive2/interface/ILHT.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface ILHT {\r\n\r\n    function mint() external payable returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n\r\n    function transfer(address dst, uint amount) external returns (bool);\r\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function balanceOfUnderlying(address owner) external returns (uint);\r\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\r\n    function borrowRatePerBlock() external view returns (uint);\r\n    function supplyRatePerBlock() external view returns (uint);\r\n    function totalBorrowsCurrent() external returns (uint);\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function borrowBalanceStored(address account) external view returns (uint);\r\n    function exchangeRateCurrent() external returns (uint);\r\n    function exchangeRateStored() external view returns (uint);\r\n    function getCash() external view returns (uint);\r\n    function accrueInterest() external returns (uint);\r\n    function accrualBlockNumber() external view returns (uint);\r\n    // function getCash() virtual external view returns (uint);\r\n    // function accrueInterest() virtual public returns (uint);\r\n    // function seize(address liquidator, address borrower, uint seizeTokens) virtual external returns (uint);\r\n\r\n}\r\n"
    },
    "contracts/swap/aggressive2/interface/ICTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.12;\r\n\r\n\r\ninterface ICTokenFactory {\r\n    // 根据 token 地址获取对应的 ctoken 地址\r\n    function getCTokenAddressPure(address token) external view returns (address);\r\n\r\n    // 根据 ctoken 地址获取对应的 token 地址\r\n    function getTokenAddress(address cToken) external view returns (address);\r\n}\r\n"
    },
    "contracts/swap/aggressive2/interface/IFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface IFactory {\r\n\r\n    function router() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function getReserves(address tokenA, address tokenB) external view returns (uint256 reserveA, uint256 reserveB);\r\n    \r\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountOut);\r\n    \r\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\r\n}\r\n"
    },
    "contracts/swap/aggressive2/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.12;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n"
    },
    "contracts/swap/aggressive2/Exchanges.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./interface/IWETH.sol\";\r\nimport \"./interface/ICToken.sol\";\r\nimport \"./interface/IFactory.sol\";\r\nimport \"./interface/IRouter.sol\";\r\nimport \"./interface/IDeBankRouter.sol\";\r\nimport \"./interface/IDeBankFactory.sol\";\r\nimport \"./interface/ICurve.sol\";\r\nimport \"./library/SafeMath.sol\";\r\nimport \"./library/DataTypes.sol\";\r\nimport \"./library/SwapFlag.sol\";\r\n\r\n// import \"hardhat/console.sol\";\r\n// import \"./interface/IAToken.sol\";\r\n\r\n/**\r\n * @title Exchanges library 计算能够 mint 、赎回、兑换多少\r\n * @author ebankex\r\n * @notice Provides data types and functions to perform step swap calculations\r\n * @dev Exchanges are used for aggressive swap within multi swap exchanges.\r\n **/\r\n\r\nlibrary Exchanges {\r\n    using SafeMath for uint;\r\n    using SafeMath for uint256;\r\n    using SwapFlag for DataTypes.SwapFlagMap;\r\n\r\n    uint constant public MAX_COMPLEX_LEVEL = 3;\r\n\r\n    uint constant public EXCHANGE_UNISWAP_V2 = 1;  // prettier-ignore\r\n    uint constant public EXCHANGE_UNISWAP_V3 = 2;  // prettier-ignore\r\n    uint constant public EXCHANGE_EBANK_EX   = 3;  // prettier-ignore\r\n    uint constant public EXCHANGE_CURVE      = 4;  // prettier-ignore\r\n\r\n    uint constant public SWAP_EBANK_CTOKENS_CTOKENS      = 1;  // prettier-ignore\r\n    uint constant public SWAP_EBANK_TOKENS_TOKENS        = 1;  // prettier-ignore\r\n    uint constant public SWAP_EBANK_ETH_TOKENS           = 1;  // prettier-ignore\r\n    uint constant public SWAP_EBANK_TOKENS_ETH           = 1;  // prettier-ignore\r\n\r\n    /// @dev 根据 midToken 数量, complexLevel 计算类 uniswap 交易所有多少个交易路径: 1 + P(midTokens, 1) + P(midTokens, 2) + .... + P(midTokens, complex)\r\n    /// complexLevel: 一次兑换时, 中间token的数量。例如为 2 时，可以的兑换路径为 a-m1-m2-b, a-m2-m1-b 或者 a-m1-b a-m2-b\r\n    /// 仅对于uniswap类的交易所, 其他类型交易所例如 curve 不适用\r\n    function uniswapRoutes(uint midTokens, uint complexLevel) internal pure returns (uint) {\r\n        uint count = 1;\r\n\r\n        if (complexLevel > MAX_COMPLEX_LEVEL) {\r\n            complexLevel = MAX_COMPLEX_LEVEL;\r\n        }\r\n\r\n        if (complexLevel >= midTokens) {\r\n            complexLevel = midTokens;\r\n        }\r\n        for (uint i = 1; i <= complexLevel; i ++) {\r\n            uint p = 1;\r\n            for (uint j = 0; j < i; j ++) {\r\n                p = p * (midTokens-j);\r\n            }\r\n            count += p;\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    /// @dev _itemInArray item 是否在数组 vec 中\r\n    function _itemInArray(address[] memory vec, address item) private pure returns (bool) {\r\n        for (uint i = 0; i < vec.length; i ++) {\r\n            if (item == vec[i]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @dev 递归计算特定 complex 下 paths 数组: P(midTokens, complex)\r\n    function calcPathComplex(\r\n                address[][] memory paths,\r\n                uint idx,\r\n                uint complex,\r\n                address token1,\r\n                address[] memory midTokens,\r\n                address[] memory path\r\n            )\r\n            internal\r\n            pure\r\n            returns (uint) {\r\n        if (complex == 0) {\r\n            address[] memory npath = new address[](path.length+1);\r\n            for (uint i = 0; i < path.length; i ++) {\r\n                npath[i] = path[i];\r\n            }\r\n            npath[npath.length-1] = token1;\r\n            paths[idx] = npath;\r\n            return idx+1;\r\n        }\r\n\r\n        for (uint i = 0; i < midTokens.length; i ++) {\r\n            address[] memory npath = new address[](path.length+1);\r\n            for (uint ip = 0; ip < path.length; ip ++) {\r\n                npath[ip] = path[ip];\r\n            }\r\n            address midToken = midTokens[i];\r\n            npath[npath.length-1] = midToken;\r\n\r\n            uint nMidLen = 0;\r\n            for (uint j = 0; j < midTokens.length; j ++) {\r\n                address mid = midTokens[j];\r\n                if (_itemInArray(npath, mid) == false) {\r\n                    nMidLen ++;\r\n                }\r\n            }\r\n            address[] memory nMidTokens = new address[](nMidLen);\r\n            uint midIdx = 0;\r\n            for (uint j = 0; j < midTokens.length; j ++) {\r\n                address mid = midTokens[j];\r\n                if (_itemInArray(npath, mid) == false) {\r\n                    nMidTokens[midIdx] = mid;\r\n                    midIdx ++;\r\n                }\r\n            }\r\n            idx = calcPathComplex(paths, idx, complex-1, token1, nMidTokens, npath);\r\n            // npath.pop();\r\n        }\r\n        return idx;\r\n    }\r\n\r\n    // 计算所有路径\r\n    function allPaths(\r\n                address tokenIn,\r\n                address tokenOut,\r\n                address[] memory midTokens,\r\n                uint complexLevel\r\n            )\r\n            public\r\n            pure\r\n            returns (address[][] memory paths) {\r\n        // uint complexLevel = args.flag.getComplexLevel();\r\n        uint mids = midTokens.length;\r\n        // address token0 = args.tokenIn;\r\n        // address token1 = args.tokenOut;\r\n        \r\n        if (complexLevel > MAX_COMPLEX_LEVEL) {\r\n            complexLevel = MAX_COMPLEX_LEVEL;\r\n        }\r\n\r\n        if (complexLevel >= mids) {\r\n            complexLevel = mids;\r\n        }\r\n\r\n        uint total = uniswapRoutes(mids, complexLevel);\r\n        // console.log(\"mids=%d complex=%d total path=%d\", mids, complexLevel, total);\r\n\r\n        uint idx = 0;\r\n        paths = new address[][](total);\r\n        // paths[idx] = new address[]{token0, token1};\r\n        // idx ++;\r\n\r\n        address[] memory initialPath = new address[](1);\r\n        initialPath[0] = tokenIn;\r\n\r\n        // address[] memory midTokens = new address[](midTokens.length);\r\n        // for (uint i = 0; i < mids; i ++) {\r\n        //     midTokens[i] = args.midTokens[i];\r\n        // }\r\n\r\n        for (uint i = 0; i <= complexLevel; i ++) {\r\n            idx = calcPathComplex(paths, idx, i, tokenOut, midTokens, initialPath);\r\n        }\r\n    }\r\n\r\n    function getExchangeRoutes(uint flag, uint midTokens, uint complexLevel) public pure returns (uint)  {\r\n        if (isUniswapLikeExchange(flag)) {\r\n            return uniswapRoutes(midTokens, complexLevel);\r\n        }\r\n        // todo 其他更多的类型\r\n        return 1;\r\n    }\r\n\r\n    function linearInterpolation(\r\n                    uint256 value,\r\n                    uint256 parts\r\n                )\r\n                internal\r\n                pure\r\n                returns(uint256[] memory rets) {\r\n        rets = new uint256[](parts);\r\n        for (uint i = 0; i < parts; i++) {\r\n            rets[i] = value.mul(i + 1).div(parts);\r\n        }\r\n    }\r\n\r\n    /// @dev calcDistributes calc swap exchange\r\n    function calcDistributes(\r\n                    DataTypes.Exchange memory ex,\r\n                    address[] memory path,\r\n                    uint[] memory amts,\r\n                    address to\r\n                )\r\n                public\r\n                view\r\n                returns (uint256[] memory distributes) {\r\n        uint flag = ex.exFlag;\r\n        address addr = ex.contractAddr;\r\n\r\n        if (flag == EXCHANGE_UNISWAP_V2 || flag == EXCHANGE_UNISWAP_V3) {\r\n            distributes = uniswapLikeSwap(addr, path, amts);\r\n            // for (uint i = 0; i < amts.length; i ++) {\r\n            //     distributes[i+1] = uniswapLikeSwap(addr, path, amts[i]);\r\n            // }\r\n        } else if (flag == EXCHANGE_EBANK_EX) {\r\n            distributes = new uint256[](amts.length+1);\r\n            for (uint i = 0; i < amts.length; i ++) {\r\n                distributes[i+1] = ebankSwap(addr, path, amts[i], to);\r\n            }\r\n        } else {\r\n            // should NOT reach here\r\n        }\r\n        // todo other swap\r\n    }\r\n\r\n    // 是否是 uniswap 类似的交易所\r\n    function isUniswapLikeExchange(uint flag) public pure returns (bool) {\r\n        if (flag == EXCHANGE_UNISWAP_V2 ||\r\n            flag == EXCHANGE_UNISWAP_V3 ||\r\n            flag == EXCHANGE_EBANK_EX) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function isEBankExchange(uint flag) public pure returns (bool) {\r\n        if (flag == EXCHANGE_EBANK_EX) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    // deposit eth from address from\r\n    function depositETH(IWETH weth) public returns (uint256) {\r\n        weth.deposit();\r\n\r\n        return weth.balanceOf(address(this));\r\n    }\r\n\r\n    // withdraw weth\r\n    function withdrawWETH(IWETH weth, uint256 amount) public {\r\n        weth.withdraw(amount);\r\n    }\r\n\r\n    /// @dev 计算 ctoken 的 exchange rate\r\n    function calcCTokenExchangeRate(ICToken ctoken) public view returns (uint) {\r\n        uint rate = ctoken.exchangeRateStored();\r\n        uint supplyRate = ctoken.supplyRatePerBlock();\r\n        uint lastBlock = ctoken.accrualBlockNumber();\r\n        uint blocks = block.number.sub(lastBlock);\r\n        uint inc = rate.mul(supplyRate).mul(blocks);\r\n        return rate.add(inc);\r\n    }\r\n\r\n    /// @dev 计算 token 能够 mint 得到多少 ctoken\r\n    function convertCompoundCtokenMinted(\r\n                    address ctoken,\r\n                    uint[] memory amounts,\r\n                    uint parts\r\n                )\r\n                public\r\n                view\r\n                returns (uint256[] memory) {\r\n        uint256 rate = calcCTokenExchangeRate(ICToken(ctoken));\r\n        uint256[] memory cAmts = new uint256[](parts);\r\n\r\n        for (uint i = 0; i < parts; i ++) {\r\n            cAmts[i] = amounts[i].mul(1e18).div(rate);\r\n        }\r\n        return cAmts;\r\n    }\r\n\r\n    /// @dev 计算 ctoken 能够 redeem 得到多少 token\r\n    function convertCompoundTokenRedeemed(\r\n                    address ctoken,\r\n                    uint[] memory cAmounts,\r\n                    uint parts\r\n                )\r\n                public\r\n                view\r\n                returns (uint256[] memory) {\r\n        uint256 rate = calcCTokenExchangeRate(ICToken(ctoken));\r\n        uint256[] memory amts = new uint256[](parts);\r\n\r\n        for (uint i = 0; i < parts; i ++) {\r\n            amts[i] = cAmounts[i].mul(rate).div(1e18);\r\n        }\r\n        return amts;\r\n    }\r\n\r\n    // mint token in compound\r\n    // token must NOT be ETH, ETH should _depositETH first, then do compound mint\r\n    // 币已经转到合约地址\r\n    function compoundMintToken(\r\n                    address ctoken,\r\n                    uint256 amount\r\n                )\r\n                public\r\n                returns (uint256) {\r\n        uint256 balanceBefore = IERC20(ctoken).balanceOf(address(this));\r\n        ICToken(ctoken).mint(amount);\r\n\r\n        return IERC20(ctoken).balanceOf(address(this)).sub(balanceBefore);\r\n    }\r\n\r\n    /// @dev compund mint ETH\r\n    function compoundMintETH(\r\n                    address weth,\r\n                    uint amount\r\n                )\r\n                public\r\n                returns (uint256) {\r\n        IWETH(weth).deposit{value: amount}();\r\n\r\n        return compoundMintToken(address(weth), amount);\r\n    }\r\n\r\n    /// @dev compoundRedeemCToken redeem compound token\r\n    /// @param ctoken compund token\r\n    /// @param amount amount to redeem\r\n    function compoundRedeemCToken(address ctoken, uint256 amount) public {\r\n        ICToken(ctoken).redeem(amount);\r\n    }\r\n\r\n    /// @dev aave deposit token\r\n    function aaveDepositToken(address aToken) public pure {\r\n        aToken;\r\n    }\r\n\r\n    /// @dev withdraw aave token\r\n    function aaveWithdrawToken(address aToken, uint256 amt) public pure {\r\n        aToken;\r\n        amt;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////////\r\n    /////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    /// todo 需要考虑 reserve 为 0 的情况\r\n\r\n    /// @dev uniswap like exchange\r\n    // function uniswapLikeSwap(\r\n    //                 address router,\r\n    //                 address[] memory path,\r\n    //                 uint256 amountIn\r\n    //             )\r\n    //             public\r\n    //             view\r\n    //             returns (uint) {\r\n    //     IFactory factory = IFactory(IRouter(router).factory());\r\n    //     uint[] memory amounts = new uint[](path.length);\r\n    //     amounts[0] = amountIn;\r\n    //     for (uint i = 0; i < path.length - 1; i ++) {\r\n    //         address pair = factory.getPair(path[i], path[i+1]);\r\n    //         if (pair == address(0)) {\r\n    //             return 0;\r\n    //         }\r\n    //         (uint ra, uint rb) = factory.getReserves(path[i], path[i+1]);\r\n    //         if (ra == 0 || rb == 0) {\r\n    //             return 0;\r\n    //         }\r\n    //         amounts[i+1] = factory.getAmountOut(amounts[i], ra, rb);\r\n    //     }\r\n    //     // uint[] memory amounts = IRouter(router).getAmountsOut(amountIn, path);\r\n    //     return amounts[amounts.length - 1];\r\n    // }\r\n\r\n    function calculateUniswapFormula(uint256 fromBalance, uint256 toBalance, uint256 amount) internal pure returns(uint256) {\r\n        if (amount == 0) {\r\n            return 0;\r\n        }\r\n        return amount.mul(toBalance).mul(997).div(\r\n            fromBalance.mul(1000).add(amount.mul(997))\r\n        );\r\n    }\r\n\r\n    function getReserves(\r\n                    address router,\r\n                    address[] memory path\r\n                )\r\n                public\r\n                view\r\n                returns (uint[][] memory reserves) {\r\n\r\n        uint plen = path.length;\r\n        reserves = new uint[][](plen);\r\n        IFactory factory = IFactory(IRouter(router).factory());\r\n        for (uint i = 0; i < plen - 1; i ++) {\r\n            // address t0 = path[i] == address(0) ? weth : path[i];\r\n            // address t1 = path[i+1] == address(0) ? weth : path[i+1];\r\n            address pair = factory.getPair(path[i], path[i+1]);\r\n            uint[] memory res = new uint[](2);\r\n            if (pair == address(0)) {\r\n                reserves[i] = res;\r\n                // return reserves;\r\n                continue;\r\n            }\r\n            // (uint r0, uint r1, ) = IPair(pair).getReserves();\r\n            // if (r0 == 0 || r1 == 0) {\r\n            //     return reserves;\r\n            // }\r\n            // reserves[i] = IERC20(path[i]).balanceOf(pair);\r\n            // reserves[i+1] = IERC20(path[i+1]).balanceOf(pair);\r\n            // if (reserves[i] == 0 || reserves[i+1] == 0) {\r\n            //     return reserves;\r\n            // }\r\n            res[0] = IERC20(path[i]).balanceOf(pair);\r\n            res[1] = IERC20(path[i+1]).balanceOf(pair);\r\n            reserves[i] = res;\r\n            // if (reserves[i] == 0 || reserves[i+1] == 0) {\r\n            //     return reserves;\r\n            // }\r\n        }\r\n    }\r\n\r\n    function uniswapLikeSwap(\r\n                    address router,\r\n                    address[] memory path,\r\n                    uint256[] memory amountIns\r\n                )\r\n                public\r\n                view\r\n                returns (uint[] memory amountOuts) {\r\n        uint plen = path.length;\r\n        uint[] memory reserves = new uint[](plen);\r\n        amountOuts = new uint[](amountIns.length+1);\r\n\r\n        IFactory factory = IFactory(IRouter(router).factory());\r\n        for (uint i = 0; i < plen - 1; i ++) {\r\n            // address t0 = path[i] == address(0) ? weth : path[i];\r\n            // address t1 = path[i+1] == address(0) ? weth : path[i+1];\r\n            address pair = factory.getPair(path[i], path[i+1]);\r\n            if (pair == address(0)) {\r\n                return amountOuts;\r\n            }\r\n            reserves[i] = IERC20(path[i]).balanceOf(pair);\r\n            reserves[i+1] = IERC20(path[i+1]).balanceOf(pair);\r\n            if (reserves[i] == 0 || reserves[i+1] == 0) {\r\n                return amountOuts;\r\n            }\r\n        }\r\n\r\n        uint[] memory tmp = new uint[](plen);\r\n        for (uint i = 0; i < amountIns.length; i ++) {\r\n            tmp[0] = amountIns[i];\r\n            for (uint j = 0; j < plen - 1; j ++) {\r\n                tmp[j + 1] = calculateUniswapFormula(reserves[j], reserves[j+1], tmp[j]);\r\n            }\r\n            amountOuts[i+1] = tmp[plen-1];\r\n        }\r\n\r\n        // amounts[0] = amountIn;\r\n        // for (uint i = 0; i < path.length - 1; i ++) {\r\n        //     address pair = factory.getPair(path[i], path[i+1]);\r\n        //     if (pair == address(0)) {\r\n        //         return 0;\r\n        //     }\r\n        //     (uint ra, uint rb) = factory.getReserves(path[i], path[i+1]);\r\n        //     if (ra == 0 || rb == 0) {\r\n        //         return 0;\r\n        //     }\r\n        //     amounts[i+1] = factory.getAmountOut(amounts[i], ra, rb);\r\n        // }\r\n        // // uint[] memory amounts = IRouter(router).getAmountsOut(amountIn, path);\r\n        // return amounts[amounts.length - 1];\r\n    }\r\n\r\n    /// @dev ebank exchange\r\n    function ebankSwap(\r\n                    address router,\r\n                    address[] memory path,\r\n                    uint256 amountIn,\r\n                    address to\r\n                )\r\n                public\r\n                view\r\n                returns (uint) {\r\n        IDeBankFactory factory = IDeBankFactory(IDeBankRouter(router).factory());\r\n        uint[] memory amounts = new uint[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint i = 0; i < path.length - 1; i ++) {\r\n            address pair = factory.getPair(path[i], path[i+1]);\r\n            if (pair == address(0)) {\r\n                return 0;\r\n            }\r\n            (uint ra, uint rb, uint feeRate, bool outAnchorToken) = factory.getReservesFeeRate(path[i], path[i + 1], to);\r\n            if (ra == 0 || rb == 0) {\r\n                return 0;\r\n            }\r\n            if (outAnchorToken) {\r\n                amounts[i + 1] = factory.getAmountOutFeeRateAnchorToken(amounts[i], ra, rb, feeRate);\r\n            } else {\r\n                amounts[i + 1] = factory.getAmountOutFeeRate(amounts[i], ra, rb, feeRate);\r\n            }\r\n        }\r\n        // uint[] memory amounts = IRouter(router).getAmountsOut(amountIn, path);\r\n        return amounts[amounts.length - 1];\r\n        // uint[] memory amounts = IDeBankRouter(router).getAmountsOut(amountIn, path, to);\r\n        // return amounts[amounts.length - 1];\r\n    }\r\n\r\n    /// @dev swap stable coin in curve\r\n    function curveSwap(\r\n                    address addr,\r\n                    uint i,\r\n                    uint j,\r\n                    uint dx\r\n                )\r\n                public\r\n                view\r\n                returns (uint) {\r\n        return ICurve(addr).get_dy(int128(i), int128(j), dx);\r\n    }\r\n}\r\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/swap/aggressive2/interface/IERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity ^0.6.12;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n"
    },
    "contracts/swap/aggressive2/interface/IRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface IRouter {\r\n    function factory() external view returns (address);\r\n    \r\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    \r\n    function swapExactETHForTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    \r\n    function swapExactTokensForETH(\r\n            uint amountIn,\r\n            uint amountOutMin,\r\n            address[] calldata path,\r\n            address to,\r\n            uint deadline\r\n        )\r\n        external\r\n        returns (uint[] memory amounts);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n}\r\n"
    },
    "contracts/swap/aggressive2/interface/IDeBankRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface IDeBankRouter {\r\n    function factory() external view returns (address);\r\n    \r\n    /// @dev getAmountsOut 对比 IRouter 增加了 to 参数, 可以根据 to 来决定手续费率\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path, address to) external view returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForTokensUnderlying(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokensUnderlying(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n        \r\n    function swapExactTokensForETHUnderlying(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n\r\n}\r\n"
    },
    "contracts/swap/aggressive2/interface/IDeBankFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.12;\r\n\r\ninterface IDeBankFactory {\r\n    function router() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, address token1);\r\n\r\n    function pairFor(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function getReserves(address tokenA, address tokenB) external view returns (uint256 reserveA, uint256 reserveB);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path, address to) external view returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path, address to) external view returns (uint256[] memory amounts);\r\n\r\n    // function amountToCTokenAmt(address ctoken, uint amountIn) external view returns (uint cAmountIn);\r\n    // function ctokenAmtToAmount(address ctoken, uint cAmountOut) external view returns (uint amountOut);\r\n\r\n    function setPairFeeRate(address pair, uint feeRate) external;\r\n\r\n    function getReservesFeeRate(address tokenA, address tokenB, address to) \r\n                external view returns (uint reserveA, uint reserveB, uint feeRate, bool outAnchorToken);\r\n\r\n    function getAmountOutFeeRate(uint amountIn, uint reserveIn, uint reserveOut, uint feeRate) external pure returns (uint amountOut);\r\n\r\n    function getAmountOutFeeRateAnchorToken(uint amountIn, uint reserveIn, uint reserveOut, uint feeRate) external pure returns (uint amountOut);\r\n}\r\n"
    },
    "contracts/swap/aggressive2/interface/ICurve.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface ICurve {\r\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\r\n    function get_dy_underlying(int128 i, int128 j, uint256 dx) external view returns (uint256);\r\n\r\n    \r\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\r\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}