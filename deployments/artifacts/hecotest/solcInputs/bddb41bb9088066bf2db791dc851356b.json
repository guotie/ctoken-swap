{
  "language": "Solidity",
  "sources": {
    "contracts/swap/orderbook/Orderbook.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./Ownable.sol\";\r\nimport \"./ReentrancyGuard.sol\";\r\nimport \"./OBStorage.sol\";\r\nimport \"./ICTokenFactory.sol\";\r\nimport \"./ICToken.sol\";\r\nimport \"./ICETH.sol\";\r\nimport \"./OBPriceLogic.sol\";\r\nimport \"./OBPairConfig.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface IWHT {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface IHswapV2Callee {\r\n    function hswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\r\n}\r\n\r\ninterface IMarginHolding {\r\n  // owner: 杠杆用户\r\n  // fulfiled: 买到的token数量(tokenIn)\r\n  // amt: 卖出的token数量(tokenOut)\r\n  function onFulfiled(address owner, address tokenOut, address tokenIn, uint fulfiled, uint amt) external;\r\n  // tokenOut: 待卖出的币 srcToken\r\n  // tokenIn: 待买入的币 destToken\r\n  // tokenReturn: tokenOut\r\n  // amt: 返还的tokenOut数量\r\n  function onCanceled(address owner, address token0, address token1, address tokenReturn, uint amt) external;\r\n}\r\n\r\n\r\n// interface ICTokenFactory {\r\n//     function getCTokenAddressPure(address cToken) external view returns (address);\r\n//     function getTokenAddress(address cToken) external view returns (address);\r\n// }\r\n\r\ninterface IOrderBook {\r\n    event CreateOrder(address indexed owner,\r\n          address indexed srcToken,\r\n          address indexed destToken,\r\n          uint orderId,\r\n          uint amountIn,\r\n          uint minAmountOut,\r\n          uint flag);\r\n\r\n    event FulFilOrder(address indexed maker,\r\n          address indexed taker,\r\n          uint orderId,\r\n          uint amt,\r\n          uint amtOut);\r\n          // uint remaining);\r\n\r\n    event CancelOrder(address indexed owner,\r\n          address indexed srcToken,\r\n          address indexed destToken,\r\n          uint orderId);\r\n}\r\n\r\ncontract OrderBook is IOrderBook, OBStorage, ReentrancyGuard {\r\n    using SafeMath for uint;\r\n    using SafeMath for uint256;\r\n    using OBPairConfig for DataTypes.OBPairConfigMap;\r\n\r\n    uint private constant _ORDER_CLOSED  = 0x00000000000000000000000000000001;   // 128 bit\r\n    uint private constant _HALF_MAX_UINT = uint(-1) >> 1;                            // 0x8fffffffffff...\r\n\r\n    // _ctokenFactory: ctoken 工厂\r\n    // _wETH: eth/bnb/ht\r\n    // _margin: 代持合约地址\r\n    // 这个地址必须是 payable !!!\r\n    constructor(address _ctokenFactory, address _cETH, address _wETH, address _margin) public payable {\r\n      cETH = _cETH;\r\n      wETH = _wETH;\r\n      marginAddr    = _margin;\r\n      ctokenFactory = _ctokenFactory;\r\n      feeTo = msg.sender;\r\n    }\r\n\r\n    modifier whenOpen() {\r\n        require(closed == false, \"order book closed\");\r\n        _;\r\n    }\r\n\r\n    receive() external payable {\r\n        //  cETH 中赎回\r\n        // assert(msg.sender == cWHT);\r\n        // only accept HT via fallback from the WHT contract\r\n    }\r\n\r\n    function closeOrderBook() external onlyOwner {\r\n      closed = true;\r\n    }\r\n\r\n    function openOrderBook() external onlyOwner {\r\n      closed = false;\r\n    }\r\n\r\n    function setMinOrderAmount(address token, uint amt) external onlyOwner {\r\n      minAmounts[token] = amt;\r\n    }\r\n\r\n    function _putOrder(DataTypes.OrderItem storage order) internal {\r\n      uint orderId = order.orderId;\r\n      uint flag = order.flag;\r\n      bool margin = isMargin(flag);\r\n      uint addrIdx;\r\n      uint pairIdx;\r\n      address owner = order.owner;\r\n\r\n      if (margin) {\r\n          // margin 订单取 to 地址\r\n          owner = order.to;\r\n          addrIdx = marginOrders[owner].length;\r\n          marginOrders[owner].push(orderId);\r\n      } else {\r\n          addrIdx = addressOrders[owner].length;\r\n          addressOrders[owner].push(orderId);\r\n      }\r\n\r\n      pairIdx = pairOrders[order.pair].length;\r\n      pairOrders[order.pair].push(orderId);\r\n\r\n      order.pairAddrIdx = maskAddrPairIndex(pairIdx, addrIdx);\r\n\r\n      emit CreateOrder(owner,\r\n          order.tokenAmt.srcToken,\r\n          order.tokenAmt.destToken,\r\n          orderId,\r\n          order.tokenAmt.amountIn,\r\n          order.tokenAmt.guaranteeAmountOut,\r\n          flag);\r\n    }\r\n\r\n    function _removeOrder(DataTypes.OrderItem memory order) private {\r\n        // uint orderId = order.orderId;\r\n        uint pairIdx = pairIndex(order.pairAddrIdx);\r\n        uint addrIdx = addrIndex(order.pairAddrIdx);\r\n        address owner = order.owner;\r\n        uint rIdx;\r\n        bool margin = isMargin(order.flag);\r\n\r\n        if (margin) {\r\n            owner = order.to;\r\n            uint lastIdx = marginOrders[owner].length-1;\r\n            if (addrIdx != lastIdx) {\r\n              rIdx = marginOrders[owner][lastIdx];\r\n              marginOrders[owner][addrIdx] = rIdx;\r\n              orders[rIdx].pairAddrIdx = updateAddrIdx(orders[rIdx].pairAddrIdx, addrIdx);\r\n            }\r\n            marginOrders[owner].pop();\r\n        } else {\r\n            uint lastIdx = addressOrders[owner].length-1;\r\n            if (addrIdx != lastIdx) {\r\n              rIdx = addressOrders[owner][lastIdx];\r\n              addressOrders[owner][addrIdx] = rIdx;\r\n              orders[rIdx].pairAddrIdx = updateAddrIdx(orders[rIdx].pairAddrIdx, addrIdx);\r\n            }\r\n            addressOrders[owner].pop();\r\n        }\r\n\r\n        if ((pairOrders[order.pair].length > 1) && (pairIdx != pairOrders[order.pair].length-1)) {\r\n          rIdx = pairOrders[order.pair][pairOrders[order.pair].length - 1];\r\n          pairOrders[order.pair][pairIdx] = rIdx;\r\n          orders[rIdx].pairAddrIdx = updatePairIdx(orders[rIdx].pairAddrIdx, pairIdx);\r\n        }\r\n        pairOrders[order.pair].pop();\r\n    }\r\n\r\n    // 如果找到 addr 对应的 etoken 地址, 返回 etoken 地址; 否则, addr 本身就是 etoken, 返回 addr\r\n    function _getOrCreateETokenAddress(address addr) internal returns (address) {\r\n      if (addr == address(0) || addr == wETH) {\r\n        return cETH;\r\n      }\r\n      address etoken = ICTokenFactory(ctokenFactory).getCTokenAddressPure(addr);\r\n      if (etoken == address(0)) {\r\n        // 这里要判断 addr 是否在 etoken mapping 中.\r\n        // 如果在, 才能说明 addr 是 etoken;\r\n        // 如果不在, 说明该 token 还没有对应的 etoken, 需要创建对应的 etoken\r\n        address token = ICTokenFactory(ctokenFactory).getTokenAddress(addr);\r\n        if (token != address(0)) {\r\n          return addr;\r\n        }\r\n        // addr 是 token, 当不存在对应的 etoken, 创建对应的 etoken\r\n        return ICTokenFactory(ctokenFactory).getCTokenAddress(addr);\r\n      }\r\n      return etoken;\r\n    }\r\n\r\n    function _getETokenAddress(address addr) internal view returns (address) {\r\n      if (addr == address(0) || addr == wETH) {\r\n        return cETH;\r\n      }\r\n      address etoken = ICTokenFactory(ctokenFactory).getCTokenAddressPure(addr);\r\n      if (etoken == address(0)) {\r\n        return addr;\r\n      }\r\n      return etoken;\r\n    }\r\n\r\n    // 创建订单\r\n    // 调用前需要 approve\r\n    function createOrder(\r\n              address srcToken,\r\n              address destToken,\r\n              address to,             // 兑换得到的 token 发送地址, 杠杆传用户地址\r\n              uint amountIn,\r\n              uint guaranteeAmountOut,       // \r\n              uint flag\r\n          )\r\n          public\r\n          payable\r\n          whenOpen\r\n          nonReentrant\r\n          returns (uint idx) {\r\n      require(srcToken != destToken, \"identical token\");\r\n\r\n      if (srcToken == address(0)) {\r\n        // 转入 wETH\r\n        require(msg.value >= amountIn, \"not enough amountIn\");\r\n        // IWHT(wETH).deposit{value: msg.value}();\r\n        // srcToken = wETH;\r\n      } else {\r\n        // should approve outside\r\n        TransferHelper.safeTransferFrom(srcToken, msg.sender, address(this), amountIn);\r\n      }\r\n\r\n      {\r\n        // 最低挂单量限制\r\n        require(amountIn > minAmounts[srcToken], \"less than min amount\");\r\n      }\r\n      idx = orderId ++;\r\n      DataTypes.OrderItem storage order = orders[idx];\r\n      order.orderId = idx;\r\n      order.owner = msg.sender;\r\n      order.to = to == address(0) ? msg.sender : to;\r\n      // solhint-disable-next-line\r\n      order.timestamp = block.timestamp; // maskTimestamp(block.timestamp, expiredAt);\r\n      order.flag = flag;\r\n      order.tokenAmt.fulfiled = 0;\r\n      address etoken = _getOrCreateETokenAddress(srcToken);\r\n      {\r\n        order.tokenAmt.srcToken = srcToken;\r\n        order.tokenAmt.srcEToken = etoken;\r\n        order.tokenAmt.amountIn = amountIn;\r\n        if (srcToken != etoken) {\r\n          // order.isEToken = true;\r\n          // mint to etoken\r\n          if (srcToken == address(0)) {\r\n            // uint balanceBefore = IERC20(cETH).balanceOf(address(this));\r\n            (uint err, uint amt) = ICETH(cETH).mint{value: msg.value}();\r\n            require(err == 0, \"mint failed\");\r\n            order.tokenAmt.amountInMint = amt; // IERC20(cETH).balanceOf(address(this)).sub(balanceBefore);\r\n          } else {\r\n            // uint balanceBefore = IERC20(etoken).balanceOf(address(this));\r\n            IERC20(srcToken).approve(etoken, amountIn);\r\n            (uint err, uint amt) = ICToken(etoken).mint(amountIn);\r\n            ICToken(etoken).approve(etoken, 0);\r\n            require(err == 0, \"mint failed\");\r\n            order.tokenAmt.amountInMint = amt; // IERC20(etoken).balanceOf(address(this)).sub(balanceBefore);\r\n          }\r\n        } else {\r\n          order.tokenAmt.amountInMint = amountIn;\r\n        }\r\n      }\r\n      order.tokenAmt.destToken = destToken;\r\n      address destEToken = _getOrCreateETokenAddress(destToken);\r\n      order.tokenAmt.destEToken = destEToken;\r\n      order.tokenAmt.guaranteeAmountOut = guaranteeAmountOut;\r\n\r\n      // src dest 必须同时为 token 或者 etoken\r\n      require((srcToken == etoken) == (destToken == destEToken), \"both token or etoken\");\r\n\r\n      if (msg.sender == marginAddr) {\r\n        require(isMargin(flag), \"flag should be margin\");\r\n        // 代持合约只能挂 etoken\r\n        require(etoken == srcToken, \"src should be etoken\");\r\n        require(to != msg.sender, \"to should be user's address\");\r\n        require(order.tokenAmt.destEToken == destToken, \"dest should be etoken\");\r\n      }\r\n\r\n      order.pair = _pairFor(etoken, destEToken);\r\n\r\n      // 授权 省去后续 cancel withdraw 授权的麻烦\r\n      if (IERC20(destEToken).allowance(address(this), destEToken) < _HALF_MAX_UINT) {\r\n          IERC20(destEToken).approve(destEToken, uint(-1));\r\n      }\r\n      if (IERC20(etoken).allowance(address(this), etoken) < _HALF_MAX_UINT) {\r\n          IERC20(etoken).approve(destEToken, uint(-1));\r\n      }\r\n\r\n      _putOrder(order);\r\n    }\r\n\r\n    function pairFor(address srcToken, address destToken) public view returns(uint pair) {\r\n      return _pairFor(_getETokenAddress(srcToken), _getETokenAddress(destToken));\r\n    }\r\n\r\n    // 调用前需要确保 srcToken destToken 都是 etoken\r\n    // 交易对hash 区分方向 eth->usdt 与 usdt->eth 是不同的交易对\r\n    function _pairFor(address srcToken, address destToken) private pure returns(uint pair) {\r\n      // if (srcToken == address(0)) {\r\n      //     srcToken = wETH;\r\n      // }\r\n      // if (destToken == address(0)) {\r\n      //     destToken = wETH;\r\n      // }\r\n      // (address token0, address token1) = srcToken < destToken ? (srcToken, destToken) : (destToken, srcToken);\r\n      pair = uint(keccak256(abi.encodePacked(srcToken, destToken)));\r\n    }\r\n\r\n    // 获取所有订单列表\r\n    function getAllOrders() external view returns(DataTypes.OrderItem[] memory allOrders) {\r\n      uint total = 0;\r\n      uint id = 0;\r\n      for (uint i = 0; i < orderId; i ++) {\r\n        uint flag = orders[i].flag;\r\n        if (_orderClosed(flag) == false) {\r\n          total ++;\r\n        }\r\n      }\r\n\r\n      allOrders = new DataTypes.OrderItem[](total);\r\n      for (uint i = 0; i < orderId; i ++) {\r\n        DataTypes.OrderItem memory order = orders[i];\r\n        if (_orderClosed(order.flag) == false) {\r\n          allOrders[id] = order;\r\n          id ++;\r\n        }\r\n      }\r\n    }\r\n\r\n    function _orderClosed(uint flag) private pure returns (bool) {\r\n      return (flag & _ORDER_CLOSED) != 0;\r\n    }\r\n    \r\n    /// @dev 赎回 etoken\r\n    function _redeemTransfer(\r\n                    address token,\r\n                    address etoken,\r\n                    address to,\r\n                    uint256 redeemAmt\r\n                ) private {\r\n        console.log(\"redeemAmt:\", redeemAmt);\r\n        (uint ret, , uint amt) = ICToken(etoken).redeem(redeemAmt);\r\n        require(ret == 0, \"redeem failed\");\r\n\r\n        if (token == address(0)) {\r\n            TransferHelper.safeTransferETH(to, amt); // address(this).balance);\r\n        } else {\r\n            console.log(\"redeem token amt:\", redeemAmt, amt, IERC20(token).balanceOf(address(this)));\r\n            TransferHelper.safeTransfer(token, to, amt); // IERC20(token).balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    // 调用者判断是否有足够的 token 可以赎回\r\n    function cancelOrder(uint orderId) public nonReentrant {\r\n      DataTypes.OrderItem storage order = orders[orderId];\r\n      bool margin = isMargin(order.flag);\r\n\r\n      if (margin) {\r\n        require(msg.sender == owner() || msg.sender == marginAddr, \"cancelMarginOrder: no auth\");\r\n      } else {\r\n        require(msg.sender == owner() || msg.sender == order.owner, \"cancelOrder: no auth\");\r\n      }\r\n      require(_orderClosed(order.flag) == false, \"order has been closed\");\r\n\r\n      // 退回未成交部分\r\n      address srcToken = order.tokenAmt.srcToken;\r\n      address srcEToken = order.tokenAmt.srcEToken;\r\n      uint amt = order.tokenAmt.amountInMint.sub(order.tokenAmt.fulfiled);\r\n      console.log(\"cancel order: srcEToken amt=%d\", amt);\r\n\r\n      if (srcToken != srcEToken) {\r\n        // redeem etoken\r\n        // 如果有足够多的 etoken 可以赎回, 则全部赎回; 否则尽可能多的赎回\r\n        // uint cash = ICToken(srcEToken).getCash();\r\n        // uint redeemAmt = amt;\r\n\r\n        if (amt > 0) {\r\n          _redeemTransfer(srcToken, srcEToken, order.owner, amt);\r\n          console.log(\"redeem transfer ok\");\r\n          /*\r\n          // redeem token\r\n          uint balanceBefore;\r\n          if (srcEToken == cETH) {\r\n            // console.log(\"redeem cETH:\", cETH, order.owner);\r\n            // console.log(\"casH: %d redeemAmt: %d\", ICToken(cETH).getCash(), redeemAmt);\r\n            balanceBefore = address(this).balance;\r\n            uint ret = ICToken(cETH).redeem(redeemAmt);\r\n            require(ret == 0, \"redeem eth failed\");\r\n            // console.log(\"redeem ceth:\", ret, redeemAmt);\r\n            uint amtToSend = address(this).balance.sub(balanceBefore);\r\n            TransferHelper.safeTransferETH(order.owner, amtToSend);\r\n          } else {\r\n            // console.log(\"redeem token:\", srcEToken, redeemAmt);\r\n            balanceBefore = IERC20(srcToken).balanceOf(address(this));\r\n            uint ret = ICToken(srcEToken).redeem(redeemAmt);\r\n            require(ret == 0, \"redeem failed\");\r\n            uint amtToSend = IERC20(srcToken).balanceOf(address(this)).sub(balanceBefore);\r\n            TransferHelper.safeTransfer(srcToken, order.owner, amtToSend);\r\n            // console.log(\"redeem token success\", srcEToken, redeemAmt);\r\n          }\r\n          */\r\n        }\r\n        // if (remainingEToken > 0) {\r\n        //   TransferHelper.safeTransfer(srcEToken, order.owner, remainingEToken);\r\n        // }\r\n      } else {\r\n        TransferHelper.safeTransfer(srcToken, order.owner, amt);\r\n      }\r\n\r\n      // 杠杆用户成交的币已经转给代持合约, 这里只处理非杠杆用户的币，还给用户\r\n      if (!margin) {\r\n        address dest = order.tokenAmt.destEToken;\r\n        address destToken = order.tokenAmt.destToken;\r\n        uint balance = balanceOf[dest][order.to];\r\n        if (balance > 0) {\r\n          // console.log(\"withdraw fulfiled to maker:\", order.to, balance);\r\n          if (dest == destToken) {\r\n              _withdraw(order.to, dest, balance, balance);\r\n          } else {\r\n              _withdrawUnderlying(order.to, destToken, dest, balance, balance);\r\n          }\r\n        }\r\n      } else {\r\n        // 通知杠杆合约处理 挂单 srcToken\r\n        IMarginHolding(marginAddr).onCanceled(order.to, srcEToken, order.tokenAmt.destToken, order.tokenAmt.srcToken, amt);\r\n      }\r\n\r\n      order.flag |= _ORDER_CLOSED;\r\n      _removeOrder(order);\r\n\r\n      emit CancelOrder(\r\n                  order.owner,\r\n                  order.tokenAmt.srcToken,\r\n                  order.tokenAmt.destToken,\r\n                  orderId\r\n              );\r\n    }\r\n\r\n    /// @dev get maker fee rate\r\n    function getMakerFeeRate(uint256 pair) public view returns (uint) {\r\n      uint fee = pairFeeRate[pair].feeMaker();\r\n      if (fee == 0) {\r\n        return defaultFeeMaker;\r\n      }\r\n      return fee - 1;\r\n    }\r\n\r\n    /// @dev get taker fee rate\r\n    function getTakerFeeRate(uint256 pair) public view returns (uint) {\r\n      uint fee = pairFeeRate[pair].feeTaker();\r\n      if (fee == 0) {\r\n        return defaultFeeTaker;\r\n      }\r\n\r\n      return fee - 1;\r\n    }\r\n\r\n    struct FulFilAmt {\r\n      bool isToken;      // 是否是 token\r\n      uint256 filled;    // 成交的 srcEToken\r\n      uint256 takerFee;  // taker 手续费\r\n      uint256 makerFee;  // maker 手续费\r\n      uint256 takerAmt;  // taker 得到的 srcEToken = amtDest - fee\r\n      uint256 takerAmtToken; // taker 得到的 srcToken = amtDestToken - fee\r\n      uint256 makerAmt;      // maker 得到的 destEToken\r\n      uint256 amtDest;       // taker 付出 srcEToken\r\n      uint256 amtDestToken;  // taker 付出的 srcToken\r\n    }\r\n\r\n    function fulfilOrders(\r\n                uint[] memory orderIds,\r\n                uint[] memory amtToTakens,\r\n                address to,\r\n                bool isToken,\r\n                bool partialFill,\r\n                bytes calldata data\r\n              )\r\n              external\r\n              payable\r\n              whenOpen {\r\n        require(orderIds.length == amtToTakens.length, \"invalid param\");\r\n\r\n        for (uint i = 0; i < orderIds.length; i ++) {\r\n          fulfilOrder(orderIds[i], amtToTakens[i], to, isToken, partialFill, data);\r\n        }\r\n    }\r\n\r\n    /// @dev fulfilOrder orderbook order, etoken in and etoken out\r\n    // order 成交, 收取成交后的币的手续费, 普通订单, maker 成交的币由合约代持; taker 的币发给用户, amtToTaken 是 src EToken 的数量\r\n    /// @param orderId order id\r\n    /// @param amtToTaken 成交多少量\r\n    /// @param to 合约地址或者 msg.sender\r\n    /// @param isToken 用户输入 token 且得到 token, 调用者须 approve 且确保 srcEToken 的 cash 足够兑付\r\n    /// @param partialFill 是否允许部分成交(正好此时部分被其他人taken)\r\n    /// @param data flashloan 合约执行代码\r\n    /// @return fulFilAmt (买到的币数量, 付出的币数量)\r\n    function fulfilOrder(\r\n                uint orderId,\r\n                uint amtToTaken,\r\n                address to,\r\n                bool isToken,\r\n                bool partialFill,\r\n                bytes calldata data\r\n              )\r\n              public\r\n              payable\r\n              whenOpen\r\n              nonReentrant\r\n              returns (FulFilAmt memory fulFilAmt) {\r\n      DataTypes.OrderItem storage order = orders[orderId];\r\n      \r\n      if ((order.flag & _ORDER_CLOSED) > 0) {\r\n          return fulFilAmt;\r\n      }\r\n\r\n      DataTypes.TokenAmount memory tokenAmt = order.tokenAmt;\r\n      if (to == address(0)) {\r\n        to = msg.sender;\r\n      }\r\n\r\n      fulFilAmt.isToken = isToken;\r\n      fulFilAmt.filled  = amtToTaken;  // 挂单被吃的数量\r\n      {\r\n        uint left = tokenAmt.amountInMint.sub(tokenAmt.fulfiled);\r\n        if (amtToTaken > left) {\r\n          require(partialFill, \"not enough to fulfil\");\r\n          \r\n          fulFilAmt.filled = left;\r\n        }\r\n      }\r\n      _getFulfiledAmt(tokenAmt, fulFilAmt, order.pair);\r\n\r\n      // console.log(\"takerAmt=%d makerAmt=%d filled=%d\", fulFilAmt.takerAmt, fulFilAmt.makerAmt, fulFilAmt.filled);\r\n      \r\n      // 验证转入 taker 的币\r\n      address destEToken = tokenAmt.destEToken;\r\n      address srcEToken = tokenAmt.srcEToken;\r\n\r\n      // 先转币给 taker\r\n      if (isToken) {\r\n            // redeem srcEToken\r\n          // IERC20(srcEToken).approve(srcEToken, fulFilAmt.takerAmt);\r\n          // uint ret = ICToken(srcEToken).redeem(fulFilAmt.takerAmt);\r\n          // require(ret == 0, \"redeem failed\");\r\n          // TransferHelper.safeTransfer(tokenAmt.srcToken, to, fulFilAmt.takerAmtToken);\r\n          _redeemTransfer(tokenAmt.srcToken, srcEToken, to, fulFilAmt.takerAmt);\r\n      } else {\r\n          TransferHelper.safeTransfer(srcEToken, to, fulFilAmt.takerAmt);\r\n      }\r\n      // console.log(\"transfer srcToken to taker success: %s %d %d\", tokenAmt.srcToken, fulFilAmt.takerAmt, fulFilAmt.takerAmtToken);\r\n\r\n      // 从 taker 哪里转入 destToken / destEToken\r\n      if (data.length > 0) {\r\n          uint256 balanceBefore = IERC20(destEToken).balanceOf(address(this));\r\n          IHswapV2Callee(to).hswapV2Call(msg.sender, fulFilAmt.takerAmt, fulFilAmt.amtDest, data);\r\n          uint256 transferIn = IERC20(destEToken).balanceOf(address(this)).sub(balanceBefore);\r\n          require(transferIn >= fulFilAmt.amtDest, \"not enough\");\r\n      } else {\r\n          if (isToken) {\r\n            address destToken = tokenAmt.destToken;\r\n            TransferHelper.safeTransferFrom(destToken, msg.sender, address(this), fulFilAmt.amtDestToken);\r\n            // mint\r\n            IERC20(destToken).approve(destEToken, fulFilAmt.amtDestToken);\r\n            (uint ret, ) = ICToken(destEToken).mint(fulFilAmt.amtDestToken);\r\n            require(ret == 0, \"mint failed\");\r\n          } else {\r\n            // taker 得到 srcEToken, maker 得到的 destEToken, 暂存在 合约中\r\n            TransferHelper.safeTransferFrom(destEToken, msg.sender, address(this), fulFilAmt.amtDest);\r\n          }\r\n      }\r\n\r\n      // 将手续费转给 feeTo\r\n      if (fulFilAmt.takerFee > 0) {\r\n        TransferHelper.safeTransfer(srcEToken, feeTo, fulFilAmt.takerFee);\r\n      }\r\n      if (fulFilAmt.makerFee > 0) {\r\n        TransferHelper.safeTransfer(destEToken, feeTo, fulFilAmt.makerFee);\r\n      }\r\n\r\n      // 更改相关的状态\r\n      // 1. 增加 maker 的 balance; 如果是 margin, 转币给 margin, 并执行回调\r\n      // 2. 修改order状态\r\n      _updateOrder(order, fulFilAmt.filled, fulFilAmt.makerAmt);\r\n\r\n      emit FulFilOrder(\r\n              order.owner,\r\n              msg.sender,\r\n              orderId,\r\n              fulFilAmt.filled,\r\n              fulFilAmt.amtDest\r\n            );\r\n    }\r\n\r\n    /// @dev 更新状态\r\n    function _updateOrder(\r\n                DataTypes.OrderItem storage order,\r\n                uint filled,\r\n                uint makerGot\r\n              ) private {\r\n        address maker = order.to;\r\n        address srcEToken = order.tokenAmt.srcEToken;\r\n        address destEToken = order.tokenAmt.destEToken;\r\n\r\n        if (isMargin(order.flag)) {\r\n          // 转给 margin 合约\r\n          TransferHelper.safeTransfer(destEToken, marginAddr, makerGot);\r\n          // 回调 todo ??\r\n          IMarginHolding(marginAddr).onFulfiled(maker, srcEToken, destEToken, makerGot, filled);\r\n        } else {\r\n          balanceOf[destEToken][maker] += makerGot;\r\n        }\r\n\r\n        // 已成交\r\n        order.tokenAmt.fulfiled = order.tokenAmt.fulfiled.add(filled);\r\n        order.tokenAmt.destFulfiled = order.tokenAmt.destFulfiled.add(makerGot);\r\n\r\n        if (order.tokenAmt.fulfiled >= order.tokenAmt.amountInMint) {\r\n          //\r\n          order.flag |= _ORDER_CLOSED;\r\n          _removeOrder(order);\r\n        }\r\n    }\r\n\r\n    /// @dev 根据order的兑换比例, 手续费, 计算兑换得到的dest token的兑换数量. 如果 是 token, 则调用 EToken 的接口更新 exchangeRate, 因此，这个方法不是只读方法\r\n    /// @param fulFilAmt 各种成交数量, taker买到的币的数量 taker 付出的币的数量 maker 得到的和卖出的币的数量\r\n    function _getFulfiledAmt(\r\n                DataTypes.TokenAmount memory tokenAmt,\r\n                FulFilAmt memory fulFilAmt,\r\n                uint256 pair\r\n              )\r\n              private {\r\n      uint amtToTaken = fulFilAmt.filled;\r\n      // 挂单者在不扣除手续费的情况下得到的币的数量\r\n      fulFilAmt.amtDest = OBPriceLogic.convertBuyAmountByETokenIn(tokenAmt, amtToTaken);\r\n\r\n      fulFilAmt.takerFee = amtToTaken.mul(getTakerFeeRate(pair)).div(DENOMINATOR);\r\n      fulFilAmt.makerFee = amtToTaken.mul(getMakerFeeRate(pair)).div(DENOMINATOR);\r\n      // taker得到的币，扣除手续费\r\n      fulFilAmt.takerAmt = amtToTaken.sub(fulFilAmt.takerFee);\r\n      // maker 得到的币数量，扣除手续费\r\n      fulFilAmt.makerAmt = fulFilAmt.amtDest.sub(fulFilAmt.makerFee);\r\n\r\n      if (fulFilAmt.isToken) {\r\n        // address srcEToken = tokenAmt.srcEToken;\r\n        uint256 srcRate = OBPriceLogic.refreshTokenExchangeRate(ICToken(tokenAmt.srcEToken));\r\n        uint256 destRate = OBPriceLogic.refreshTokenExchangeRate(ICToken(tokenAmt.destEToken));\r\n        fulFilAmt.takerAmtToken = fulFilAmt.takerAmt.mul(srcRate).div(1e18);\r\n        fulFilAmt.amtDestToken = fulFilAmt.amtDest.mul(destRate).div(1e18);\r\n      }\r\n    }\r\n\r\n    // withdraw etoken\r\n    // token should be etoken\r\n    function _withdraw(address user, address etoken, uint total, uint amt) private {\r\n        TransferHelper.safeTransfer(etoken, user, amt);\r\n\r\n        balanceOf[etoken][user] = total.sub(amt);\r\n    }\r\n\r\n    function _withdrawUnderlying(address user, address token, address etoken, uint total, uint amt) private {\r\n        balanceOf[etoken][user] = total.sub(amt);\r\n\r\n        // if (etoken == cETH) {\r\n        //   uint balanceBefore = address(this).balance;\r\n        //   // approve\r\n        //   IERC20(cETH).approve(cETH, amt);\r\n        //   uint ret = ICETH(cETH).redeem(amt);\r\n        //   require(ret == 0, \"redeem eth failed\");\r\n        //   uint redeemAmt = address(this).balance.sub(balanceBefore);\r\n        //   TransferHelper.safeTransferETH(user, redeemAmt);\r\n        // } else {\r\n        //   uint balanceBefore = IERC20(token).balanceOf(address(this));\r\n        //   // approve\r\n        //   IERC20(etoken).approve(etoken, amt);\r\n        //   uint ret = ICToken(etoken).redeem(amt);\r\n        //   require(ret == 0, \"redeem failed\");\r\n        //   uint redeemAmt = IERC20(token).balanceOf(address(this)).sub(balanceBefore);\r\n        //   TransferHelper.safeTransfer(token, user, redeemAmt);\r\n        // }\r\n        _redeemTransfer(token, etoken, user, amt);\r\n    }\r\n\r\n    // 用户成交后，资金由合约代管, 用户提现得到自己的 etoken\r\n    function withdraw(address etoken, uint amt) external {\r\n        uint total = balanceOf[etoken][msg.sender];\r\n        require(total > 0, \"no asset\");\r\n        if (amt == 0) {\r\n            amt = total;\r\n        } else {\r\n            require(total >= amt, \"not enough asset\");\r\n        }\r\n\r\n        _withdraw(msg.sender, etoken, total, amt);\r\n    }\r\n\r\n    // 用户成交后，资金由合约代管, 用户提现得到自己的 token\r\n    function withdrawUnderlying(address token, uint amt) external {\r\n        address etoken = _getETokenAddress(token);\r\n        uint total = balanceOf[etoken][msg.sender];\r\n\r\n        require(total > 0, \"no asset\");\r\n        if (amt == 0) {\r\n            amt = total;\r\n        } else {\r\n            require(total >= amt, \"not enough asset\");\r\n        }\r\n\r\n        _withdrawUnderlying(msg.sender, token, etoken, total, amt);\r\n    }\r\n\r\n    /// @dev 设置 feeTo 地址\r\n    function setFeeTo(address to) external onlyOwner {\r\n      feeTo = to;\r\n    }\r\n\r\n    /// @dev TODO 需要关闭 转出手续费\r\n    // function adminTransfer(address token, address to, uint amt) external onlyOwner {\r\n    //     if (token == address(0)) {\r\n    //       TransferHelper.safeTransferETH(to, amt);\r\n    //     } else {\r\n    //       TransferHelper.safeTransfer(token, to, amt);\r\n    //     }\r\n    // }\r\n\r\n    function _getPairFee(address src, address dest) internal view returns (DataTypes.OBPairConfigMap storage conf) {\r\n      address srcEToken = _getETokenAddress(src);\r\n      address destEToken = _getETokenAddress(dest);\r\n      uint256 pair = _pairFor(srcEToken, destEToken);\r\n      conf = pairFeeRate[pair];\r\n      return conf;\r\n    }\r\n\r\n    function setPairTakerFee(address src, address dest, uint fee) external onlyOwner {\r\n      DataTypes.OBPairConfigMap storage conf = _getPairFee(src, dest);\r\n\r\n      conf.setFeeTaker(fee);\r\n    }\r\n    \r\n    function setPairMakerFee(address src, address dest, uint fee) external onlyOwner {\r\n      DataTypes.OBPairConfigMap storage conf = _getPairFee(src, dest);\r\n\r\n      conf.setFeeMaker(fee);\r\n    }\r\n}\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success,) = to.call{value: value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n"
    },
    "contracts/swap/orderbook/Ownable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n"
    },
    "contracts/swap/orderbook/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ncontract ReentrancyGuard {\r\n    bool private _notEntered;\r\n\r\n    constructor () internal {\r\n        // Storing an initial non-zero value makes deployment a bit more\r\n        // expensive, but in exchange the refund on every call to nonReentrant\r\n        // will be lower in amount. Since refunds are capped to a percetange of\r\n        // the total transaction's gas, it is best to keep them low in cases\r\n        // like this one, to increase the likelihood of the full refund coming\r\n        // into effect.\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _notEntered = true;\r\n    }\r\n}"
    },
    "contracts/swap/orderbook/OBStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./Ownable.sol\";\r\nimport { DataTypes } from \"./DataTypes.sol\";\r\nimport { OBPairConfig } from \"./OBPairConfig.sol\";\r\n\r\n// 存储\r\ncontract OBStorage is Ownable {\r\n    using OBPairConfig for DataTypes.OBPairConfigMap;\r\n\r\n    uint private constant _PAIR_INDEX_MASK = 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;   // 128 bit\r\n    uint private constant _ADDR_INDEX_MASK = 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000;   // 128 bit\r\n    uint private constant _MARGIN_MASK     = 0x8000000000000000000000000000000000000000000000000000000000000000;\r\n    uint private constant _EXPIRED_AT_MASK = 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000;   // 128 bit\r\n    uint private constant _ADDR_INDEX_OFFSET = 128;\r\n    // uint private constant _EXPIRED_AT_OFFSET = 128;\r\n\r\n    uint256 public constant DENOMINATOR = 10000;\r\n\r\n    // // 计算价格的乘数 price = token0 * priceRatio / token1, such as 1e30\r\n    // uint public priceRatio = 1e30; \r\n\r\n    uint public orderId;   // order Id 自增\r\n\r\n    // 关闭订单薄功能\r\n    bool    public closed; // prettier-ignore\r\n    // address public router;\r\n    address public wETH;\r\n    address public cETH;  // compound ETH token\r\n    address public ctokenFactory;\r\n    address public marginAddr;  // 代持合约\r\n    address public feeTo;       // 手续费地址\r\n\r\n    // maker 手续费 && taker 手续费\r\n    uint public defaultFeeMaker = 30;\r\n    uint public defaultFeeTaker = 30;\r\n    mapping(uint256 => DataTypes.OBPairConfigMap) public pairFeeRate;\r\n    // 最低挂单量\r\n    mapping(address => uint256) public minAmounts;\r\n    mapping(address => mapping(address => uint)) public balanceOf;   // 代持用户的币\r\n\r\n    // orders\r\n    mapping (uint => DataTypes.OrderItem) public orders;\r\n    mapping (address => uint[]) public marginOrders;   // 杠杆合约代持的挂单\r\n    mapping (address => uint[]) public addressOrders;\r\n    mapping (uint => uint[]) public pairOrders;\r\n\r\n    function pairIndex(uint id) public pure returns(uint) {\r\n        return (id & _PAIR_INDEX_MASK);\r\n    }\r\n\r\n    function addrIndex(uint id) public pure returns(uint) {\r\n        return (id & _ADDR_INDEX_MASK) >> _ADDR_INDEX_OFFSET;\r\n    }\r\n\r\n    // pairIdx 不变, addrIdx 更新\r\n    function updateAddrIdx(uint idx, uint addrIdx) public pure returns(uint) {\r\n      return pairIndex(idx) | addrIndex(addrIdx);\r\n    }\r\n\r\n    // pairIdx 不变, addrIdx 更新\r\n    function updatePairIdx(uint idx, uint pairIdx) public pure returns(uint) {\r\n      return (idx & _ADDR_INDEX_MASK) | pairIdx;\r\n    }\r\n\r\n    function maskAddrPairIndex(uint pairIdx, uint addrIdx) public pure returns (uint) {\r\n        return (pairIdx) | (addrIdx << _ADDR_INDEX_OFFSET);\r\n    }\r\n\r\n    function isMargin(uint flag) public pure returns (bool) {\r\n      return (flag & _MARGIN_MASK) != 0;\r\n    }\r\n\r\n    // function getExpiredAt(uint ts) public pure returns (uint) {\r\n    //   return (ts & _EXPIRED_AT_MASK) >> _EXPIRED_AT_OFFSET;\r\n    // }\r\n\r\n    // function maskTimestamp(uint ts, uint expired) public pure returns (uint) {\r\n    //   return (ts) | (expired << _EXPIRED_AT_OFFSET);\r\n    // }\r\n    \r\n    // function setSwapMining(address _swapMininng) public onlyOwner {\r\n    //     swapMining = _swapMininng;\r\n    // }\r\n}\r\n"
    },
    "contracts/swap/orderbook/ICTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity ^0.6.12;\r\n\r\n\r\ninterface ICTokenFactory {\r\n    // 根据 token 地址获取对应的 ctoken 地址, 如果不存在, 创建对应的 etoekn\r\n    function getCTokenAddress(address token) external returns (address);\r\n\r\n    // 根据 token 地址获取对应的 ctoken 地址\r\n    function getCTokenAddressPure(address token) external view returns (address);\r\n\r\n    // 根据 ctoken 地址获取对应的 token 地址\r\n    function getTokenAddress(address cToken) external view returns (address);\r\n}\r\n"
    },
    "contracts/swap/orderbook/ICToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface ICToken {\r\n\r\n    function mint(uint mintAmount) external returns (uint, uint);\r\n    function redeem(uint redeemTokens) external returns (uint, uint, uint);\r\n\r\n    function transfer(address dst, uint amount) external returns (bool);\r\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function balanceOfUnderlying(address owner) external returns (uint);\r\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\r\n    function borrowRatePerBlock() external view returns (uint);\r\n    function supplyRatePerBlock() external view returns (uint);\r\n    function totalBorrowsCurrent() external returns (uint);\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function borrowBalanceStored(address account) external view returns (uint);\r\n    function exchangeRateCurrent() external returns (uint);\r\n    function exchangeRateStored() external view returns (uint);\r\n    function getCash() external view returns (uint);\r\n    function accrueInterest() external returns (uint);\r\n    function accrualBlockNumber() external view returns (uint);\r\n    // function getCash() virtual external view returns (uint);\r\n    // function accrueInterest() virtual public returns (uint);\r\n    // function seize(address liquidator, address borrower, uint seizeTokens) virtual external returns (uint);\r\n\r\n}\r\n"
    },
    "contracts/swap/orderbook/ICETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface ICETH {\r\n\r\n    function mint() external payable returns (uint, uint);\r\n    function redeem(uint redeemTokens) external returns (uint, uint, uint);\r\n\r\n    function transfer(address dst, uint amount) external returns (bool);\r\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function balanceOfUnderlying(address owner) external returns (uint);\r\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\r\n    function borrowRatePerBlock() external view returns (uint);\r\n    function supplyRatePerBlock() external view returns (uint);\r\n    function totalBorrowsCurrent() external returns (uint);\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function borrowBalanceStored(address account) external view returns (uint);\r\n    function exchangeRateCurrent() external returns (uint);\r\n    function exchangeRateStored() external view returns (uint);\r\n    function getCash() external view returns (uint);\r\n    function accrueInterest() external returns (uint);\r\n    function accrualBlockNumber() external view returns (uint);\r\n    // function getCash() virtual external view returns (uint);\r\n    // function accrueInterest() virtual public returns (uint);\r\n    // function seize(address liquidator, address borrower, uint seizeTokens) virtual external returns (uint);\r\n\r\n}\r\n"
    },
    "contracts/swap/orderbook/OBPriceLogic.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./ICToken.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./DataTypes.sol\";\r\n\r\n// 根据compound 最新的 exchange rate 换算 挂单时的价格, 根据 taker 的吃单量换算挂单者\r\n// 1. tokenIn 和 tokenOut都是 etoken: 不需要换算\r\n// 2. tokenIn tokenOut 都是 token: \r\nlibrary OBPriceLogic {\r\n    using SafeMath for uint;\r\n    using SafeMath for uint256;\r\n\r\n    // struct OBPrice {\r\n    //     address src;\r\n    //     address srcEToken;\r\n    //     address dst;\r\n    //     address dstEToken;\r\n    //     uint256 amtIn;\r\n    //     uint256 eAmtIn;\r\n    //     uint256 amtOut;\r\n    //     uint256 eAmtOut;\r\n    //     // uint256 feeTaker;\r\n    //     // uint256 feeMaker;\r\n    // }\r\n\r\n    // uint256 constant public DENOMINATOR = 10000;\r\n\r\n    function getCurrentExchangeRate(ICToken ctoken) public view returns (uint256) {\r\n        uint rate = ctoken.exchangeRateStored();\r\n        uint supplyRate = ctoken.supplyRatePerBlock();\r\n        uint lastBlock = ctoken.accrualBlockNumber();\r\n        uint blocks = block.number.sub(lastBlock);\r\n        uint inc = rate.mul(supplyRate).mul(blocks);\r\n        return rate.add(inc);\r\n    }\r\n\r\n    function refreshTokenExchangeRate(ICToken ctoken) public returns (uint256) {\r\n        return ctoken.exchangeRateCurrent();\r\n    }\r\n\r\n    /// @dev 根据价格计算 amtToTaken 对应的 amtOut. 如果挂单时 destToken 是 ctoken, 则直接计算比例; 否则, 需要将挂单设置的guaranteeAmountOut转换为 etoken 数量, 再计算\r\n    /// @param data OBPrice to calcutation\r\n    /// @param amtToTaken amount to taken, in etoken\r\n    /// @return maker 得到的币数量; 单位 etoken \r\n    function convertBuyAmountByETokenIn(\r\n                    DataTypes.TokenAmount memory data,\r\n                    uint amtToTaken\r\n                )\r\n                public\r\n                view\r\n                returns (uint) {\r\n        // address src = data.srcToken;\r\n        // address srcEToken = data.srcEToken;\r\n        address dst = data.destToken;\r\n        address dstEToken = data.destEToken;\r\n        // // uint256 feeTaker = DENOMINATOR - data.feeTaker;\r\n        // // uint256 feeMaker = DENOMINATOR - data.feeMaker;\r\n\r\n        if (dst == dstEToken) {\r\n            // 挂单就是以 etoken 来挂的\r\n            return amtToTaken.mul(data.guaranteeAmountOut).div(data.amountInMint);\r\n        }\r\n        uint destRate = getCurrentExchangeRate(ICToken(dstEToken));\r\n        uint destEAmt = data.guaranteeAmountOut.mul(1e18).div(destRate);\r\n        return amtToTaken.mul(destEAmt).div(data.amountInMint);\r\n\r\n        // // 由于目前 create order已经限制了必须同时为 token 或者 etoken\r\n        // require(src != srcEToken && dst != dstEToken, \"invalid orderbook tokens\");\r\n        \r\n        // // price = amtOut/amtIn = eAmtOut*rateOut/(eAmtIn*rateIn)\r\n        // // eprice = (price*rateIn)/rateOut = (amtOut*rateIn)/(amtIn*rateOut)\r\n        // uint256 rateIn = getCurrentExchangeRate(ICToken(srcEToken));\r\n        // uint256 rateOut = getCurrentExchangeRate(ICToken(dstEToken));\r\n\r\n        // // 吃单者需要转入的币的数量\r\n        // return amtToTaken.mul(rateIn).mul(data.guaranteeAmountOut).div(data.amountIn).div(rateOut);\r\n        // // return (amtToSendByEToken, amtToTaken);\r\n    }\r\n\r\n\r\n}"
    },
    "contracts/swap/orderbook/OBPairConfig.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport { DataTypes } from \"./DataTypes.sol\";\r\n\r\nlibrary OBPairConfig {\r\n    uint constant internal MASK_FEE_MAKER  = 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff; // prettier-ignore\r\n    uint constant internal MASK_FEE_TAKER  = 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000; // prettier-ignore\r\n    // uint constant internal FEE_DENOMINATOR = 10000;\r\n\r\n    uint constant internal MAX_FEE_RATE = 1000; // 10%\r\n\r\n    uint constant internal SHIFT_FEE_TAKER = 128;\r\n\r\n    /**\r\n    * @dev Gets the maker fee of order book pair\r\n    * @param self The order book pair configuration\r\n    * @return The maker fee + 1 if fee exist or else 0\r\n    **/\r\n    function feeMaker(DataTypes.OBPairConfigMap storage self) public view returns (uint256) {\r\n        return (self.data & MASK_FEE_MAKER);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the taker fee of order book pair\r\n    * @param self The order book pair configuration\r\n    * @return The taker fee + 1 if fee exist or else 0\r\n    **/\r\n    function feeTaker(DataTypes.OBPairConfigMap storage self) public view returns (uint256) {\r\n        return ((self.data & MASK_FEE_TAKER) >> SHIFT_FEE_TAKER);\r\n    }\r\n    \r\n    /**\r\n    * @dev Sets the maker fee of order book pair\r\n    * @param self The order book pair configuration\r\n    * @param fee taker fee to set\r\n    **/\r\n    function setFeeMaker(DataTypes.OBPairConfigMap storage self, uint fee) public {\r\n        require(fee < MAX_FEE_RATE, \"maker fee invalid\");\r\n        self.data = (self.data & ~MASK_FEE_MAKER) | (fee+1);\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the maker fee of order book pair\r\n    * @param self The order book pair configuration\r\n    * @param fee maker fee to set\r\n    **/\r\n    function setFeeTaker(DataTypes.OBPairConfigMap storage self, uint fee) public {\r\n        require(fee < MAX_FEE_RATE, \"taker fee invalid\");\r\n        self.data = (self.data & ~MASK_FEE_TAKER) | ((fee+1) << SHIFT_FEE_TAKER);\r\n    }\r\n}\r\n"
    },
    "contracts/swap/orderbook/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary SafeMath {\r\n    uint256 constant internal WAD = 10 ** 18;\r\n    uint256 constant internal RAY = 10 ** 27;\r\n\r\n    function wad() public pure returns (uint256) {\r\n        return WAD;\r\n    }\r\n\r\n    function ray() public pure returns (uint256) {\r\n        return RAY;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a <= b ? a : b;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function sqrt(uint256 a) internal pure returns (uint256 b) {\r\n        if (a > 3) {\r\n            b = a;\r\n            uint256 x = a / 2 + 1;\r\n            while (x < b) {\r\n                b = x;\r\n                x = (a / x + x) / 2;\r\n            }\r\n        } else if (a != 0) {\r\n            b = 1;\r\n        }\r\n    }\r\n\r\n    function wmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mul(a, b) / WAD;\r\n    }\r\n\r\n    function wmulRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, b), WAD / 2) / WAD;\r\n    }\r\n\r\n    function rmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mul(a, b) / RAY;\r\n    }\r\n\r\n    function rmulRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, b), RAY / 2) / RAY;\r\n    }\r\n\r\n    function wdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(mul(a, WAD), b);\r\n    }\r\n\r\n    function wdivRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, WAD), b / 2) / b;\r\n    }\r\n\r\n    function rdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(mul(a, RAY), b);\r\n    }\r\n\r\n    function rdivRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, RAY), b / 2) / b;\r\n    }\r\n\r\n    function wpow(uint256 x, uint256 n) internal pure returns (uint256) {\r\n        uint256 result = WAD;\r\n        while (n > 0) {\r\n            if (n % 2 != 0) {\r\n                result = wmul(result, x);\r\n            }\r\n            x = wmul(x, x);\r\n            n /= 2;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256) {\r\n        uint256 result = RAY;\r\n        while (n > 0) {\r\n            if (n % 2 != 0) {\r\n                result = rmul(result, x);\r\n            }\r\n            x = rmul(x, x);\r\n            n /= 2;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/swap/orderbook/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity 0.6.12;\r\n\r\nlibrary DataTypes {\r\n    struct TokenAmount {\r\n        address srcToken;\r\n        address destToken;\r\n        address srcEToken;             // srcToken 对应的 eToken\r\n        address destEToken;            // destToken 对应的 eToken\r\n        uint amountIn;                 // 初始挂单数量\r\n        uint amountInMint;             // 如果 srcToken 不是 eToken, mint 成为 etoken 的数量\r\n        uint fulfiled;                 // 已经成交部分, 单位 etoken\r\n        uint guaranteeAmountOut;       // 最低兑换后要求得到的数量\r\n        uint destFulfiled;             // destEToken 已经得到的 destEToken\r\n    }\r\n\r\n    struct OrderItem {\r\n      uint orderId;\r\n      uint pairAddrIdx;        // pairIdx | addrIdx\r\n      uint pair;               // hash(srcToken, destToken)\r\n      uint timestamp;          // 挂单时间 \r\n      uint flag;\r\n      address owner;           // 如果是杠杆的订单, owner 为杠杆合约地址, to为用户真实地址\r\n      address to;              // 兑换得到的token发送地址 \r\n      TokenAmount tokenAmt;\r\n    }\r\n\r\n    struct OBPairConfigMap {\r\n      // bit 0-127 min amount\r\n      // bit 128-191 maker fee rate\r\n      // bit 192-255 taker fee rate\r\n      uint256 data;\r\n    }\r\n}\r\n"
    },
    "contracts/swap/aggressive2/StepSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./library/SafeMath.sol\";\r\nimport \"./library/DataTypes.sol\";\r\nimport \"./library/SwapFlag.sol\";\r\nimport \"./library/PathFinder.sol\";\r\nimport \"./interface/IWETH.sol\";\r\nimport \"./interface/ICToken.sol\";\r\nimport \"./interface/ILHT.sol\";\r\nimport \"./interface/ICTokenFactory.sol\";\r\nimport \"./interface/IFactory.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./Exchanges.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\n// 分步骤 swap, 可能的步骤\r\n// 0. despot eth/ht\r\n// 1. withdraw weth/wht\r\n// 2. mint token (compound)\r\n// 3. mint wht/ht (compound)\r\n// 4. redeem ctoken (compound)\r\n// 5. redeem wht/ht (compound)\r\n// 6. uniswap v1\r\n// 7. uniswap v2\r\n// 8. curve stable\r\n// 9. uniswap v3\r\n// \r\n//\r\n// tokenIn的情况:\r\n// 1. ht\r\n// 2. token\r\n// 3. ctoken\r\n//\r\n// tokenOut的情况:\r\n// 1. ht\r\n// 2. token\r\n// 3. ctoken\r\n// 4. cht\r\n//\r\n//\r\n// uniswap 只需要提供 router 地址，router 合约有 factory 地址\r\n// \r\n// exchange 的类型\r\n// 1. uniswap v1\r\n// 2. uniswap v2, direct by pair 直接使用pair交易\r\n// 3. uniswap v2, 使用router交易, 因为mdex可以交易挖矿\r\n// 4. curve\r\n//\r\n\r\ncontract StepSwapStorage {\r\n    mapping(uint => DataTypes.Exchange) public swaps;  // \r\n    uint public exchangeCount;  // exchange 数量\r\n    IWETH public weth;\r\n    ILHT public ceth;  // compound eth\r\n    ICTokenFactory public ctokenFactory;\r\n\r\n    uint internal constant _HALF_MAX_UINT = uint(-1) >> 1;                            // 0x8fffffffffff...\r\n}\r\n\r\n// contract StepSwap is BaseStepSwap {\r\ncontract StepSwap is Ownable, StepSwapStorage {\r\n    using SafeMath for uint;\r\n    using SafeMath for uint256;\r\n    using SwapFlag for DataTypes.SwapFlagMap;\r\n    \r\n    constructor(address _weth, address _ceth, address _factory) public {\r\n        weth = IWETH(_weth);\r\n        ceth = ILHT(_ceth);\r\n        ctokenFactory = ICTokenFactory(_factory);\r\n    }\r\n\r\n    receive() external payable {\r\n\r\n    }\r\n\r\n    function isTokenToken(address token) public view returns (bool) {\r\n        address ctoken = ctokenFactory.getCTokenAddressPure(token);\r\n        // 有对应的 ctoken 时, 一定是 token\r\n        if (ctoken != address(0)) {\r\n            return true;\r\n        }\r\n        // 没有对应的 ctoken 时, 有可能 token 是 ctoken, 也有可能是 token 没有对应的 ctoken 地址\r\n        if (ctokenFactory.getTokenAddress(token) != address(0)) {\r\n            // 是 ctoken, 存在对应的 token 地址\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _getCTokenAddressPure(address token) internal view returns (address ctoken) {\r\n        if (token == address(0)) {\r\n            return address(ceth);\r\n        }\r\n        return ctokenFactory.getCTokenAddressPure(token);\r\n    }\r\n\r\n    function _getTokenAddressPure(address ctoken) internal view returns (address token) {\r\n        if (token == address(ceth)) {\r\n            return address(0);\r\n        }\r\n        return ctokenFactory.getTokenAddress(ctoken);\r\n    }\r\n\r\n    /// @dev 根据入参交易对, midTokens, complex 计算 flag, routes, path列表, cpath列表\r\n    // 参数 midTokens 中不能包含 tokenIn/tokenOut 相同的 token\r\n    function getRoutesPaths(\r\n                    DataTypes.QuoteParams memory args\r\n                )\r\n                public\r\n                view\r\n                returns (\r\n                    // uint flag,\r\n                    uint routes,\r\n                    address[][] memory paths,\r\n                    address[][] memory cpaths,\r\n                    DataTypes.Exchange[] memory exchanges\r\n                    ) {\r\n        (routes, exchanges) = calcExchangeRoutes(args.midTokens.length, args.complex);\r\n\r\n        address ti = args.tokenIn;\r\n        address to = args.tokenOut;\r\n        address cti = args.tokenIn;\r\n        address cto = args.tokenOut;\r\n        if (args.tokenIn == address(0)) {\r\n            // flag = flag | SwapFlag.FLAG_TOKEN_IN_ETH;\r\n            cti = address(ceth);\r\n        } else if (isTokenToken(args.tokenIn)) {\r\n            // flag = flag | SwapFlag.FLAG_TOKEN_TOKEN;\r\n            cti = _getCTokenAddressPure(ti);\r\n        } else {\r\n            // flag = flag | SwapFlag.FLAG_TOKEN_CTOKEN;\r\n            ti = ctokenFactory.getTokenAddress(cti);\r\n        }\r\n\r\n        if (args.tokenOut == address(0)) {\r\n            // flag = flag | SwapFlag.FLAG_TOKEN_OUT_ETH;\r\n            cto = address(ceth);\r\n        } else if (isTokenToken(args.tokenOut)) {\r\n            // both token\r\n            require(isTokenToken(args.tokenIn) || args.tokenIn == address(0), \"both token in/out should be token\");\r\n            cto = _getCTokenAddressPure(to);\r\n        } else {\r\n            // both ctoken\r\n            require(isTokenToken(args.tokenIn) == false || args.tokenIn == address(0), \"both token in/out should be etoken\");\r\n            to = ctokenFactory.getTokenAddress(cto);\r\n        }\r\n\r\n        // flag = flag | ((args.mainRoutes & 0xff) << SwapFlag._SHIFT_MAIN_ROUTES);\r\n        // flag = flag | ((args.complex & 0x3) << SwapFlag._SHIFT_COMPLEX_LEVEL);\r\n        // flag = flag | (args.parts & 0xff);\r\n        // if (args.allowPartial) {\r\n        //     flag = flag | SwapFlag._MASK_PARTIAL_FILL;\r\n        // }\r\n        // if (args.allowBurnchi) {\r\n        //     flag = flag | SwapFlag._MASK_PARTIAL_FILL;\r\n        // }\r\n\r\n        if (ti == address(0)) {\r\n            ti = address(weth);\r\n        }\r\n        if (to == address(0)) {\r\n            to = address(weth);\r\n        }\r\n        // 排除 midToken 中与 tokenIn/tokenOut 相同的 token\r\n        address[] memory midCTokens = new address[](args.midTokens.length);\r\n        for (uint i = 0; i < args.midTokens.length; i ++) {\r\n            midCTokens[i] = _getCTokenAddressPure(args.midTokens[i]);\r\n        }\r\n        address[][] memory tmp = Exchanges.allPaths(ti, to, args.midTokens, args.complex);\r\n        paths = allSwapPaths(tmp);\r\n        tmp = Exchanges.allPaths(cti, cto, midCTokens, args.complex);\r\n        cpaths = allSwapPaths(tmp);\r\n    }\r\n\r\n    function allSwapPaths(\r\n                    address[][] memory ps\r\n                )\r\n                public\r\n                view\r\n                returns (address[][] memory paths) {\r\n        uint total = 0;\r\n        for (uint i = 0; i < exchangeCount; i ++) {\r\n            DataTypes.Exchange storage ex = swaps[i];\r\n\r\n            if (ex.contractAddr == address(0)) {\r\n                continue;\r\n            }\r\n            // DataTypes.Exchange memory ex = exchanges[i];\r\n            if (Exchanges.isUniswapLikeExchange(ex.exFlag)) {\r\n                total += ps.length;\r\n            } else {\r\n                // curve, etc\r\n                total ++;\r\n            }\r\n        }\r\n        paths = new address[][](total);\r\n        uint pIdx = 0;\r\n        for (uint i = 0; i < exchangeCount; i ++) {\r\n            DataTypes.Exchange storage ex = swaps[i];\r\n\r\n            if (ex.contractAddr == address(0)) {\r\n                continue;\r\n            }\r\n            if (Exchanges.isUniswapLikeExchange(ex.exFlag)) {\r\n                for (uint j = 0; j < ps.length; j ++) {\r\n                    paths[pIdx] = ps[j];\r\n                    pIdx ++;\r\n                }\r\n            } else {\r\n                // curve, etc\r\n                paths[pIdx] = new address[](1);\r\n                pIdx ++;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev 获取交易所的 reserve 数据及 exchangeRate\r\n    function getSwapReserveRates(\r\n                DataTypes.QuoteParams memory args\r\n            )\r\n            public\r\n            view\r\n            returns (DataTypes.SwapReserveRates memory params) {\r\n        require(exchangeCount > 0, \"no exchanges\");\r\n        // uint flag;\r\n        (\r\n            // flag,\r\n            params.routes,\r\n            params.paths,\r\n            params.cpaths,\r\n            params.exchanges\r\n        ) = getRoutesPaths(args);\r\n\r\n        console.log(\"routes: %d paths: %d exchanges: %d\", params.routes, params.paths.length, params.exchanges.length);\r\n        if (isTokenToken(args.tokenIn) || isTokenToken(args.tokenOut)) {\r\n            address ctokenIn = _getCTokenAddressPure(args.tokenIn);\r\n            address ctokenOut = _getCTokenAddressPure(args.tokenOut);\r\n            params.isEToken  = false;\r\n            params.tokenIn   = args.tokenIn;\r\n            params.tokenOut  = args.tokenOut;\r\n            params.etokenIn  = ctokenIn;\r\n            params.etokenOut = ctokenOut;\r\n            params.rateIn    = Exchanges.calcCTokenExchangeRate(ICToken(ctokenIn));\r\n            params.rateOut   = Exchanges.calcCTokenExchangeRate(ICToken(ctokenOut));\r\n        } else {\r\n            params.isEToken  = true;\r\n            params.etokenIn  = args.tokenIn;\r\n            params.etokenOut = args.tokenOut;\r\n            params.tokenIn   = ctokenFactory.getTokenAddress(args.tokenIn);\r\n            params.tokenOut  = ctokenFactory.getTokenAddress(args.tokenOut);\r\n            params.rateIn    = Exchanges.calcCTokenExchangeRate(ICToken(args.tokenIn));\r\n            params.rateOut   = Exchanges.calcCTokenExchangeRate(ICToken(args.tokenOut));\r\n        }\r\n\r\n        // console.log(\"exchange rate done\");\r\n        // params.routes = routes;\r\n        // params.paths = paths;\r\n        // params.cpaths = cpaths;\r\n        // params.exchanges = exchanges;\r\n\r\n        params.fees = new uint[](params.routes);\r\n        params.reserves = new uint[][][](params.routes);\r\n        for (uint i = 0; i < params.paths.length; i ++) {\r\n            DataTypes.Exchange memory ex = params.exchanges[i];\r\n            address[] memory path = params.paths[i];\r\n\r\n            // if (ex.contractAddr == address(0)) {\r\n            //     params.reserves[i] = new uint[](path.length);\r\n            //     continue;\r\n            // }\r\n\r\n            if (Exchanges.isUniswapLikeExchange(ex.exFlag)) {\r\n                if (Exchanges.isEBankExchange(ex.exFlag)) { // 必须先于 UniswapLike 的判断\r\n                    // todo set exchange fee\r\n                    params.fees[i] = 30;\r\n                    params.reserves[i] = Exchanges.getReserves(ex.contractAddr, params.cpaths[i]);\r\n                } else {\r\n                    // set exchange fee\r\n                    params.fees[i] = 30;\r\n                    params.reserves[i] = Exchanges.getReserves(ex.contractAddr, path);\r\n                }\r\n            } else {\r\n                // curve todo\r\n                params.fees[i] = 4;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev 根据入参, 生成交易参数\r\n    function buildSwapRouteSteps(\r\n                    DataTypes.SwapReserveRates memory args\r\n                )\r\n                public\r\n                view\r\n                returns (DataTypes.SwapParams memory params) {\r\n        uint steps = args.swapRoutes;\r\n\r\n        params.amountIn = args.amountIn;\r\n        if (args.isEToken) {\r\n            params.tokenIn = args.etokenIn;\r\n            params.tokenOut = args.etokenOut;\r\n            // etoken 且不完全由ebank 兑换时, step 增加两步: redeem 和 mint, mint 不计入 step 中\r\n            if (args.allEbank == false) {\r\n                steps += 1;\r\n            }\r\n        } else {\r\n            params.tokenIn = args.tokenIn;\r\n            params.tokenOut = args.tokenOut;\r\n        }\r\n        params.isEToken = args.isEToken;\r\n\r\n        uint stepIdx = 0;\r\n        params.steps = new DataTypes.StepExecuteParams[](steps);\r\n        if (args.isEToken && args.allEbank == false) {\r\n            // redeem to token\r\n            params.steps[stepIdx] = _buildCompoundRedeemStep(args.amountIn.sub(args.ebankAmt), args.etokenIn);\r\n            stepIdx ++;\r\n        }\r\n\r\n        if (args.ebankAmt > 0) {\r\n            // build ebank swap\r\n            address ebankRouter = _getEBankContract();\r\n            address[] memory path;\r\n            address[] memory cpath;\r\n            uint i = 0;\r\n            for (; i < args.distributes.length; i ++) {\r\n                if (args.distributes[i] == 0) {\r\n                    continue;\r\n                }\r\n\r\n                DataTypes.Exchange memory ex = args.exchanges[i];\r\n                if (Exchanges.isEBankExchange(ex.exFlag)) {\r\n                    path = args.paths[i];\r\n                    cpath = args.cpaths[i];\r\n                    break;\r\n                }\r\n            }\r\n            console.log(\"build ebank step: amt=%d\", args.ebankAmt);\r\n            require(i != args.distributes.length, \"no ebank\");\r\n            params.steps[stepIdx] = buildEbankSwapStep(\r\n                                                ebankRouter,\r\n                                                path,\r\n                                                cpath,\r\n                                                args.ebankAmt,\r\n                                                args.isEToken\r\n                                            );\r\n            stepIdx ++;\r\n        }\r\n\r\n        for (uint i = 0; i < args.distributes.length; i ++) {\r\n            if (args.distributes[i] == 0) {\r\n                continue;\r\n            }\r\n\r\n            DataTypes.Exchange memory ex = args.exchanges[i];\r\n            if (Exchanges.isEBankExchange(ex.exFlag)) {\r\n                continue;\r\n            }\r\n\r\n            if (Exchanges.isUniswapLikeExchange(ex.exFlag)) {\r\n                params.steps[stepIdx] = buildUniSwapStep(\r\n                                            ex.contractAddr,\r\n                                            args.paths[i],\r\n                                            args.distributes[i],\r\n                                            true\r\n                                        );\r\n            } else {\r\n                // todo curve, etc\r\n                DataTypes.StepExecuteParams memory step;\r\n                step.flag = 0;\r\n                params.steps[stepIdx] = step;\r\n            }\r\n\r\n            stepIdx ++;\r\n        }\r\n\r\n        // if (args.isEToken && args.allEbank == false) {\r\n        //     //\r\n        //     params.step[stepIdx] = _buildCompoundMintStep(0, args.etokenOut);\r\n        // }\r\n        params.block = block.number;\r\n    }\r\n\r\n    function _isETH(address token) private view returns (bool) {\r\n        if (token == address(weth) || token == address(0)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function _isCETH(address token) private view returns (bool) {\r\n        if (token == address(ceth) || token == address(0)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// 构建 ebank swap 参数\r\n    function buildEbankSwapStep(\r\n                    address router,\r\n                    address[] memory path,\r\n                    address[] memory cpath,\r\n                    uint256 amtIn,\r\n                    bool isEToken                // 是否是 token in token out\r\n                )\r\n                public\r\n                view\r\n                returns (DataTypes.StepExecuteParams memory step) {\r\n        DataTypes.UniswapRouterParam memory rp;\r\n        if (!isEToken) {\r\n            // underlying swap\r\n            address tokenIn = cpath[0];\r\n            address tokenOut = cpath[cpath.length-1];\r\n\r\n            if (_isCETH(tokenIn)) {\r\n                step.flag = DataTypes.STEP_EBANK_ROUTER_ETH_TOKENS;\r\n            } else if (_isCETH(tokenOut)) {\r\n                step.flag = DataTypes.STEP_EBANK_ROUTER_TOKENS_ETH;\r\n            } else {\r\n                step.flag = DataTypes.STEP_EBANK_ROUTER_TOKENS_TOKENS;\r\n            }\r\n            // underlying 时, path 必须是 token\r\n            rp.path = path;\r\n        } else {\r\n            step.flag = DataTypes.STEP_EBANK_ROUTER_CTOKENS_CTOKENS;\r\n            rp.path = cpath;\r\n        }\r\n\r\n        rp.contractAddr = router;\r\n        rp.amount = amtIn;\r\n\r\n        step.data = abi.encode(rp);\r\n    }\r\n\r\n    /// 构建 uniswap swap 参数\r\n    function buildUniSwapStep(\r\n                    address router,\r\n                    address[] memory path,\r\n                    uint256 amtIn,\r\n                    bool useRouter\r\n                )\r\n                public\r\n                view\r\n                returns (DataTypes.StepExecuteParams memory step) {\r\n            require(useRouter, \"must be router\");\r\n        // if (useRouter) {\r\n            address tokenIn = path[0];\r\n            address tokenOut = path[path.length-1];\r\n\r\n            if (_isETH(tokenIn)) {\r\n                step.flag = DataTypes.STEP_UNISWAP_ROUTER_ETH_TOKENS;\r\n            } else if (_isETH(tokenOut)) {\r\n                step.flag = DataTypes.STEP_UNISWAP_ROUTER_TOKENS_ETH;\r\n            } else {\r\n                step.flag = DataTypes.STEP_UNISWAP_ROUTER_TOKENS_TOKENS;\r\n            }\r\n            DataTypes.UniswapRouterParam memory rp;\r\n            rp.contractAddr = router;\r\n            rp.amount = amtIn;\r\n            rp.path = path;\r\n\r\n            step.data = abi.encode(rp);\r\n        // } else {\r\n            // IFactory factory = IFactory(IRouter(router).factory());\r\n            // DataTypes.UniswapPairParam memory rp;\r\n            // rp.amount = amtIn;\r\n            \r\n            // rp.pairs = new address[](path.length-1);\r\n            // for (uint i = 0; i < path.length-2; i ++) {\r\n            //     rp.pairs[i] = factory.getPair(path[i], path[i+1]);\r\n            // }\r\n\r\n            // step.flag = DataTypes.STEP_UNISWAP_PAIR_SWAP;\r\n            // step.data = abi.encode(rp);\r\n        // }\r\n    }\r\n\r\n    // 如果已经有 approve, 返回; 如果没有 approve, 执行 approve\r\n    function _approve(IERC20 tokenIn, address spender) private {\r\n        if (tokenIn.allowance(address(this), spender) < _HALF_MAX_UINT) {\r\n            tokenIn.approve(spender, uint(-1));\r\n        }\r\n    }\r\n\r\n    /*\r\n    function _doPairStep(address tokenIn, address tokenOut, uint amt, uint[] memory pairs) private {\r\n        if (tokenIn == address(0)) {\r\n            //\r\n            weth.deposit{value: amt}();\r\n            tokenIn = address(weth);\r\n        }\r\n        \r\n        TransferHelper.safeTransfer(tokenIn, pairs[i], amt);\r\n        uint amount = amt;\r\n\r\n        for (uint i = 0; i < pairs.length; i ++) {\r\n            address to;\r\n            bool reversed = (pairs[i] & DataTypes.REVERSE_SWAP_MASK) > 0;\r\n            address pair = address(pairs[i] & ADDRESS_MASK);\r\n\r\n            if (i == pairs.length - 1) {\r\n                to = address(this);\r\n            } else {\r\n                to = address(pairs[i+1] & ADDRESS_MASK);\r\n            }\r\n\r\n            if (reversed) {\r\n                IPair(pair).swap(0, amount, to, new bytes(0));\r\n            } else {\r\n                IPair(pair).swap(amount, 0, to, new bytes(0));\r\n            }\r\n        }\r\n\r\n        if (tokenOut == address(0)) {\r\n            //\r\n            weth.withdraw(IERC20(weth).balanceOf(address(this)));\r\n        }\r\n    }\r\n    */\r\n\r\n    function _doRouterSetp(uint flag, address tokenIn, address router, uint amt, address[] memory path, uint deadline) private {\r\n        // approve, swap\r\n            // DataTypes.UniswapRouterParam memory param = abi.decode(step.data, (DataTypes.UniswapRouterParam));\r\n            // address router = param.contractAddr;\r\n        console.log(\"_doRouterSetp flag:\", flag);\r\n        if (flag == DataTypes.STEP_UNISWAP_ROUTER_ETH_TOKENS || flag == DataTypes.STEP_EBANK_ROUTER_ETH_TOKENS) {\r\n            // eth\r\n            if (amt == 0) {\r\n                amt = address(this).balance;\r\n            }\r\n            if (flag == DataTypes.STEP_UNISWAP_ROUTER_ETH_TOKENS) {\r\n                IRouter(router).swapExactETHForTokens{value: amt}(0, path, address(this), deadline);\r\n            } else {\r\n                IDeBankRouter(router).swapExactETHForTokensUnderlying{value: amt}(0, path, address(this), deadline);\r\n            }\r\n        } else {\r\n            if (amt == 0) {\r\n                amt = IERC20(tokenIn).balanceOf(address(this));\r\n            }\r\n            // approve\r\n            _approve(IERC20(tokenIn), router);\r\n            if (flag == DataTypes.STEP_UNISWAP_ROUTER_TOKENS_TOKENS) {\r\n                console.log(\"uniswap token->token:\", path.length, amt, IERC20(tokenIn).balanceOf(address(this)));\r\n                IRouter(router).swapExactTokensForTokens(amt, 0, path, address(this), deadline);\r\n            } else if (flag == DataTypes.STEP_UNISWAP_ROUTER_TOKENS_ETH) {\r\n                IRouter(router).swapExactTokensForETH(amt, 0, path, address(this), deadline);\r\n            } else if (flag == DataTypes.STEP_EBANK_ROUTER_CTOKENS_CTOKENS) {\r\n                console.log(\"ebank ctoken->ctoken:\", path.length, amt, IERC20(tokenIn).balanceOf(address(this)));\r\n                IDeBankRouter(router).swapExactTokensForTokens(amt, 0, path, address(this), deadline);\r\n            } else if (flag == DataTypes.STEP_EBANK_ROUTER_TOKENS_TOKENS) {\r\n                console.log(\"ebank token->token:\", path.length, amt, IERC20(tokenIn).balanceOf(address(this)));\r\n                IDeBankRouter(router).swapExactTokensForTokensUnderlying(amt, 0, path, address(this), deadline);\r\n            } else {\r\n                // STEP_EBANK_ROUTER_TOKENS_ETH\r\n                require(flag == DataTypes.STEP_EBANK_ROUTER_TOKENS_ETH, \"invalid flag\");\r\n                IDeBankRouter(router).swapExactTokensForETHUnderlying(amt, 0, path, address(this), deadline);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /// @dev 根据参数执行兑换\r\n    // 用户需要授权\r\n    function unoswap(DataTypes.SwapParams memory args) public payable {\r\n        address tokenIn = args.tokenIn;\r\n\r\n        if (tokenIn == address(0)) {\r\n            require(msg.value >= args.amountIn, \"not enough value\");\r\n        } else {\r\n            // transfer\r\n            TransferHelper.safeTransferFrom(tokenIn, msg.sender, address(this), args.amountIn);\r\n        }\r\n\r\n        console.log(\"transfer to stepswap success, steps: %d amountIn: %d\", args.steps.length, args.amountIn);\r\n\r\n        address tokenOut = args.tokenOut;\r\n        // solhint-disable-next-line\r\n        uint deadline = block.timestamp + 600;\r\n        if (args.isEToken) {\r\n            // 是否需要 redeem\r\n            uint stepIdx = 0;\r\n            uint endIdx = args.steps.length;\r\n            bool redeemMint = false;\r\n            uint total = 0;   // total redeemed\r\n            uint originAmt = 0;\r\n            if (args.steps[0].flag == DataTypes.STEP_COMPOUND_REDEEM_TOKEN) {\r\n                redeemMint = true;\r\n                stepIdx ++;\r\n                endIdx -= 1;\r\n                DataTypes.CompoundRedeemParam memory rp = abi.decode(args.steps[0].data, (DataTypes.CompoundRedeemParam));\r\n                // _approve(tokenIn, spender);\r\n                ICToken(rp.ctoken).redeem(rp.amount);\r\n                originAmt = rp.amount;\r\n                if (rp.ctoken == address(ceth)) {\r\n                    total = address(this).balance;\r\n                } else {\r\n                    address token = ctokenFactory.getTokenAddress(rp.ctoken);\r\n                    total = IERC20(token).balanceOf(address(this));\r\n                }\r\n            }\r\n\r\n            // 如果有 ebank swap, 必定在第一个\r\n            if (args.amountIn > originAmt) {\r\n                _approve(IERC20(tokenIn), address(this));\r\n                DataTypes.UniswapRouterParam memory param = abi.decode(args.steps[stepIdx].data, (DataTypes.UniswapRouterParam));\r\n                IDeBankRouter(param.contractAddr).swapExactTokensForTokens(param.amount, 0, param.path, address(this), deadline);\r\n                stepIdx ++;\r\n            }\r\n\r\n            address ctokenIn = _getTokenAddressPure(tokenIn);\r\n            for (; stepIdx < endIdx; stepIdx ++) {\r\n                // 根据不同情况, 计算不同的交易数量\r\n                uint amount = 0;\r\n                DataTypes.StepExecuteParams memory step = args.steps[stepIdx];\r\n                // if (step.flag == DataTypes.STEP_UNISWAP_PAIR_SWAP) {\r\n                //     DataTypes.UniswapPairParam memory param = abi.decode(step.data, (DataTypes.UniswapPairParam));\r\n                //     if (stepIdx != endIdx - 1) {\r\n                //         amount = param.amount.mul(total).div(originAmt);\r\n                //     }\r\n                //     _doPairStep(ctokenIn, amount, param.pairs);\r\n                // } else {\r\n                    DataTypes.UniswapRouterParam memory param = abi.decode(step.data, (DataTypes.UniswapRouterParam));\r\n                    if (stepIdx != endIdx - 1) {\r\n                        amount = param.amount.mul(total).div(originAmt);\r\n                    }\r\n                    _doRouterSetp(step.flag, ctokenIn, param.contractAddr, amount, param.path, deadline);\r\n                // }\r\n            }\r\n\r\n            if (redeemMint) {\r\n                // mint to ctoken\r\n                if (tokenOut == address(ceth)) {\r\n                    uint amt = address(this).balance;\r\n                    ceth.mint{value: amt}();\r\n                } else {\r\n                    address token = ctokenFactory.getTokenAddress(tokenOut);\r\n                    _approve(IERC20(token), tokenOut);\r\n                    ICToken(tokenOut).mint(IERC20(token).balanceOf(address(this)));\r\n                }\r\n            }\r\n        } else {\r\n            // 没有 redeem/mint操作, 不需要考虑 amount 转换的问题\r\n            console.log(\"steps:\", args.steps.length);\r\n            for (uint i = 0; i < args.steps.length; i ++) {\r\n                uint flag = args.steps[i].flag;\r\n                console.log(\"swap %d %d\", i, flag);\r\n                DataTypes.StepExecuteParams memory step = args.steps[i];\r\n                // if (flag == DataTypes.STEP_UNISWAP_PAIR_SWAP) {\r\n                //     DataTypes.UniswapPairParam memory param = abi.decode(step.data, (DataTypes.UniswapPairParam));\r\n                //     _doPairStep(tokenIn, param.amount, param.pairs);\r\n                // } else {\r\n                    DataTypes.UniswapRouterParam memory param = abi.decode(step.data, (DataTypes.UniswapRouterParam));\r\n                    _doRouterSetp(flag, tokenIn, param.contractAddr, param.amount, param.path, deadline);\r\n                // }\r\n            }\r\n        }\r\n\r\n        /// \r\n        // transfer to user\r\n        if (args.tokenOut == address(0)) {\r\n            uint balance = address(this).balance;\r\n            require(balance >= args.minAmt, \"less than minAmt\");\r\n            console.log(\"eth balance:\", balance);\r\n            TransferHelper.safeTransferETH(msg.sender, balance);\r\n        } else {\r\n            uint balance = IERC20(tokenOut).balanceOf(address(this));\r\n            require(balance >= args.minAmt, \"less than minAmt\");\r\n            console.log(\"token balance:\", balance);\r\n            TransferHelper.safeTransfer(tokenOut, msg.sender, balance);\r\n        }\r\n    }\r\n\r\n    /// @dev 在给定中间交易对数量和复杂度的情况下, 有多少种兑换路径\r\n    function calcExchangeRoutes(\r\n                    uint midTokens,\r\n                    uint complexLevel\r\n                )\r\n                public\r\n                view\r\n                returns (uint total, DataTypes.Exchange[] memory exchanges) {\r\n        uint i;\r\n\r\n        // 计算一共有多少个 exchange routes\r\n        for (i = 0; i < exchangeCount; i ++) {\r\n            DataTypes.Exchange storage ex = swaps[i];\r\n\r\n            if (ex.contractAddr == address(0)) {\r\n                continue;\r\n            }\r\n\r\n            total += Exchanges.getExchangeRoutes(ex.exFlag, midTokens, complexLevel);\r\n        }\r\n        exchanges = new DataTypes.Exchange[](total);\r\n        uint exIdx = 0;\r\n        for (i = 0; i < exchangeCount; i ++) {\r\n            DataTypes.Exchange storage ex = swaps[i];\r\n\r\n            if (ex.contractAddr == address(0)) {\r\n                continue;\r\n            }\r\n\r\n            uint count = Exchanges.getExchangeRoutes(ex.exFlag, midTokens, complexLevel);\r\n            for (uint j = 0; j < count; j ++) {\r\n                exchanges[exIdx].exFlag = ex.exFlag;\r\n                exchanges[exIdx].contractAddr = ex.contractAddr;\r\n                exIdx ++;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /// @dev 扣除 gas 费用后得到的\r\n    /// @param amounts 未计算 gas 时兑换得到的数量\r\n    /// @param gas gas, 单位 GWei\r\n    /// @param tokenPriceGWei token 的价格相对于 GWei 的价格 token/ht * gas. 例如 tokenOut 为 usdt, eth 的价格为 2000 usdt, 此时, 将消耗的 gas 折算为\r\n    ///                       usdt, 然后再 amounts 中扣减\r\n    function _deductGasFee(\r\n                uint[] memory amounts,\r\n                uint gas,\r\n                uint tokenPriceGWei\r\n            )\r\n            internal\r\n            pure\r\n            returns(int[] memory) {\r\n        uint val = gas.mul(tokenPriceGWei);\r\n        int256[] memory deducted = new int256[](amounts.length);\r\n\r\n        for (uint i = 1; i < amounts.length; i ++) {\r\n            uint amt = amounts[i];\r\n            // if (amt > val) {\r\n                deducted[i] = int256(amt) - int256(val);\r\n            // } else {\r\n                // 负数\r\n                // deducted[i] = int256(amt).sub(int256(val));\r\n            // }\r\n        }\r\n\r\n        return deducted;\r\n    }\r\n\r\n    /// amt * part / totalParts\r\n    function _partAmount(uint amt, uint part, uint totalParts) private pure returns (uint) {\r\n        return amt.mul(part).div(totalParts);\r\n    }\r\n\r\n    function _getEBankContract() private view returns (address ebank) {\r\n        for (uint i = 0; i < exchangeCount; i ++) {\r\n            DataTypes.Exchange memory ex = swaps[i];\r\n            if (ex.exFlag == Exchanges.EXCHANGE_EBANK_EX && ex.contractAddr != address(0)) {\r\n                ebank = ex.contractAddr;\r\n                break;\r\n            }\r\n        }\r\n        require(ebank != address(0), \"not found ebank\");\r\n        return ebank;\r\n    }\r\n\r\n    function _buildCompoundMintStep(\r\n                uint amt,\r\n                address ctoken\r\n            )\r\n            private \r\n            view\r\n            returns (DataTypes.StepExecuteParams memory step) {\r\n        address token = ctokenFactory.getTokenAddress(ctoken);\r\n\r\n        // todo 是否可以用 weth 来做判断\r\n        if (token == address(0) || token == address(weth)) {\r\n            step.flag = DataTypes.STEP_COMPOUND_MINT_CETH;\r\n        } else {\r\n            step.flag = DataTypes.STEP_COMPOUND_MINT_CTOKEN;\r\n        }\r\n        DataTypes.CompoundRedeemParam memory rp;\r\n        rp.amount = amt;\r\n        rp.ctoken = ctoken;\r\n\r\n        step.data = abi.encode(rp);\r\n    }\r\n\r\n    /// @dev 构建 redeem 步骤的合约地址及参数\r\n    /// @param amt redeem amount, if 0, redeem all(balanceOf(address(this)))\r\n    function _buildCompoundRedeemStep(\r\n                uint amt,\r\n                address ctoken\r\n            )\r\n            private \r\n            pure\r\n            returns (DataTypes.StepExecuteParams memory step) {\r\n        // eth 和 token 都是调用同一个方法 redeem, 且参数相同, 因此，使用同一个 flag\r\n        step.flag = DataTypes.STEP_COMPOUND_REDEEM_TOKEN;\r\n        // }\r\n        DataTypes.CompoundRedeemParam memory rp;\r\n        rp.amount = amt;\r\n        rp.ctoken = ctoken;\r\n\r\n        step.data = abi.encode(rp);\r\n    }\r\n\r\n\r\n    function _buildEBankRouteStep(\r\n                uint flag,\r\n                uint amt,\r\n                address ebank,\r\n                address[] memory path\r\n                // bool direct\r\n            )\r\n            private \r\n            pure\r\n            returns (DataTypes.StepExecuteParams memory step) {\r\n        step.flag = flag;\r\n        DataTypes.UniswapRouterParam memory rp;\r\n        rp.amount = amt;\r\n        rp.contractAddr = ebank;\r\n        // if (direct) {\r\n        //     rp.to = sd.to;\r\n        // } else {\r\n            // rp.to = address(this);\r\n        // }\r\n        rp.path = path;\r\n        step.data = abi.encode(rp);\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    \r\n\r\n    function addSwap(uint flag, address addr) external onlyOwner {\r\n        DataTypes.Exchange storage ex = swaps[exchangeCount];\r\n        ex.exFlag = flag;\r\n        ex.contractAddr = addr;\r\n\r\n        exchangeCount ++;\r\n    }\r\n\r\n    function removeSwap(uint i) external onlyOwner {\r\n        DataTypes.Exchange storage ex = swaps[i];\r\n\r\n        ex.contractAddr = address(0);\r\n    }\r\n\r\n    function setWETH(address _weth) external onlyOwner {\r\n        weth = IWETH(_weth);\r\n    }\r\n\r\n    function setCETH(address _ceth) external onlyOwner {\r\n        ceth = ILHT(_ceth);\r\n    }\r\n\r\n    function setCtokenFactory(address factory) external onlyOwner {\r\n        ctokenFactory = ICTokenFactory(factory);\r\n    }\r\n}\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success,) = to.call{value: value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n"
    },
    "contracts/swap/aggressive2/library/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity >=0.6.12;\r\n\r\nlibrary SafeMath {\r\n    uint256 constant WAD = 10 ** 18;\r\n    uint256 constant RAY = 10 ** 27;\r\n\r\n    function wad() public pure returns (uint256) {\r\n        return WAD;\r\n    }\r\n\r\n    function ray() public pure returns (uint256) {\r\n        return RAY;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a <= b ? a : b;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function sqrt(uint256 a) internal pure returns (uint256 b) {\r\n        if (a > 3) {\r\n            b = a;\r\n            uint256 x = a / 2 + 1;\r\n            while (x < b) {\r\n                b = x;\r\n                x = (a / x + x) / 2;\r\n            }\r\n        } else if (a != 0) {\r\n            b = 1;\r\n        }\r\n    }\r\n\r\n    function wmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mul(a, b) / WAD;\r\n    }\r\n\r\n    function wmulRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, b), WAD / 2) / WAD;\r\n    }\r\n\r\n    function rmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mul(a, b) / RAY;\r\n    }\r\n\r\n    function rmulRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, b), RAY / 2) / RAY;\r\n    }\r\n\r\n    function wdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(mul(a, WAD), b);\r\n    }\r\n\r\n    function wdivRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, WAD), b / 2) / b;\r\n    }\r\n\r\n    function rdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(mul(a, RAY), b);\r\n    }\r\n\r\n    function rdivRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, RAY), b / 2) / b;\r\n    }\r\n\r\n    function wpow(uint256 x, uint256 n) internal pure returns (uint256) {\r\n        uint256 result = WAD;\r\n        while (n > 0) {\r\n            if (n % 2 != 0) {\r\n                result = wmul(result, x);\r\n            }\r\n            x = wmul(x, x);\r\n            n /= 2;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256) {\r\n        uint256 result = RAY;\r\n        while (n > 0) {\r\n            if (n % 2 != 0) {\r\n                result = rmul(result, x);\r\n            }\r\n            x = rmul(x, x);\r\n            n /= 2;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n"
    },
    "contracts/swap/aggressive2/library/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @title DataTypes library\r\n * @author ebankex\r\n * @notice Provides data types and functions to perform step swap calculations\r\n * @dev DataTypes are used for aggressive swap within multi swap exchanges.\r\n **/\r\n\r\nlibrary DataTypes {\r\n    // 步骤执行的动作类型\r\n    uint256 public constant STEP_DEPOSIT_ETH           = 0x0000000001; // prettier-ignore\r\n    uint256 public constant STEP_WITHDRAW_WETH         = 0x0000000002; // prettier-ignore\r\n    uint256 public constant STEP_COMPOUND_MINT_CTOKEN  = 0x0000000003; // prettier-ignore\r\n    uint256 public constant STEP_COMPOUND_MINT_CETH    = 0x0000000004; // prettier-ignore\r\n    uint256 public constant STEP_COMPOUND_REDEEM_TOKEN = 0x0000000005; // prettier-ignore\r\n    // uint256 public constant STEP_COMPOUND_REDEEM_ETH   = 0x0000000006; // prettier-ignore\r\n    uint256 public constant STEP_AAVE_DEPOSIT_ATOKEN   = 0x0000000007; // prettier-ignore\r\n    uint256 public constant STEP_AAVE_DEPOSIT_WETH     = 0x0000000008; // prettier-ignore\r\n    uint256 public constant STEP_AAVE_WITHDRAW_TOKEN   = 0x0000000009; // prettier-ignore\r\n    uint256 public constant STEP_AAVE_WITHDRAW_ETH     = 0x000000000a; // prettier-ignore\r\n\r\n    // uint256 public constant STEP_UNISWAP_PAIR_SWAP              = 0x0000000100; // prettier-ignore\r\n    uint256 public constant STEP_UNISWAP_ROUTER_TOKENS_TOKENS   = 0x000000011; // prettier-ignore\r\n    uint256 public constant STEP_UNISWAP_ROUTER_ETH_TOKENS      = 0x000000012; // prettier-ignore\r\n    uint256 public constant STEP_UNISWAP_ROUTER_TOKENS_ETH      = 0x000000013; // prettier-ignore\r\n    uint256 public constant STEP_EBANK_ROUTER_CTOKENS_CTOKENS   = 0x000000014;  // prettier-ignore same to STEP_UNISWAP_ROUTER_TOKENS_TOKENS\r\n    uint256 public constant STEP_EBANK_ROUTER_TOKENS_TOKENS     = 0x000000015;  // prettier-ignore underlying\r\n    uint256 public constant STEP_EBANK_ROUTER_ETH_TOKENS        = 0x000000016;  // prettier-ignore underlying\r\n    uint256 public constant STEP_EBANK_ROUTER_TOKENS_ETH        = 0x000000017;  // prettier-ignore underlying\r\n\r\n    uint256 public constant REVERSE_SWAP_MASK = 0x8000000000000000000000000000000000000000000000000000000000000000;\r\n    uint256 public constant ADDRESS_MASK      = 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff; // prettier-ignore\r\n\r\n    // todo slip, 16 bit, 分母: 10000\r\n    struct SwapFlagMap {\r\n        // bit 0-7 parts, 8 bit\r\n        // bit 8-63: flag token in/out, 64 bit\r\n        // bit 72-79 max main part, 8 bit\r\n        // bit 80-81 complex level, 2 bit\r\n        // bit 82    allow partial fill\r\n        // bit 83    allow burnChi\r\n        uint256 data;\r\n    }\r\n\r\n    /// @dev 询价 计算最佳兑换路径的入参\r\n    struct RoutePathParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        address[] midTokens;      // should always be token\r\n        uint256 mainRoutes;           // distributeCounts\r\n        uint256 complex;\r\n        uint256 parts;\r\n        bool allowPartial;\r\n        bool allowBurnchi;\r\n    }\r\n\r\n    /// @dev 询价 计算最佳兑换路径的入参\r\n    struct QuoteParams {\r\n        address to;\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint256 amountIn;\r\n        address[] midTokens;      // should always be token\r\n        uint256 mainRoutes;           // distributeCounts\r\n        uint256 complex;\r\n        uint256 parts;\r\n        // uint256 routes;           // distributeCounts\r\n        bool allowPartial;\r\n        bool allowBurnchi;\r\n        // uint256 tokenPriceGWei;\r\n        // address fromAddress;\r\n        // address dstReceiver;\r\n        // address[] midTokens;      // should always be token\r\n        // Exchange[]  exchanges;\r\n        // address[][] paths;        // 由 midTokens 和 复杂度计算得到的所有 path 列表\r\n        // address[][] cpaths;       // 由 midCTokens 和 复杂度计算得到的所有 cpath 列表\r\n        // SwapFlagMap flag;\r\n    }\r\n\r\n    // swap reserves; exchange rates\r\n    struct SwapReserveRates {\r\n        bool isEToken;\r\n        bool allowBurnchi;\r\n        bool allEbank;                  // 是否全部都由 ebank 兑换\r\n        uint256 ebankAmt;\r\n        uint256 amountIn;\r\n        uint256 swapRoutes;             // 最终经过多少个 route 来兑换\r\n        address tokenIn;\r\n        address tokenOut;\r\n        address etokenIn;\r\n        address etokenOut;\r\n        uint256 routes;                 // distributeCounts 交易所数量 * 路径数量\r\n        uint256 rateIn;\r\n        uint256 rateOut;\r\n        uint256[]  fees;\r\n        Exchange[]  exchanges;\r\n        address[][] paths;        // 由 midTokens 和 复杂度计算得到的所有 path 列表\r\n        address[][] cpaths;       // 由 midCTokens 和 复杂度计算得到的所有 cpath 列表\r\n        uint256[][][] reserves;     // [routes][path]\r\n        uint256[] distributes;    // 各个 swap 路径分配的兑换数量, 对于 ebank 是 etoken 的数量， 其他 swap 是 token 数量\r\n    }\r\n\r\n    struct UniswapRouterParam {\r\n        uint256 amount;\r\n        address contractAddr;\r\n        // address to;\r\n        address[] path;\r\n    }\r\n\r\n    struct CompoundRedeemParam {\r\n        uint256 amount;\r\n        // address to;\r\n        address ctoken;\r\n    }\r\n\r\n    struct UniswapPairParam {\r\n        uint256 amount;\r\n        address[] pairs;\r\n    }\r\n\r\n    // struct \r\n    struct StepExecuteParams {\r\n        uint256 flag;           // step execute flag 指示用哪种步骤去执行\r\n        bytes   data;\r\n    }\r\n\r\n    /// @dev 兑换 入参\r\n    struct SwapParams {\r\n        // address to;\r\n        // address tokenIn;\r\n        // address tokenOut;\r\n        // uint256 amountIn;\r\n        // uint256 amountOut;\r\n        // uint256 tokenPriceGWei;\r\n        // address fromAddress;\r\n        // address dstReceiver;\r\n        // address[] midTokens;  // should always be token\r\n        // SwapFlagMap flag;\r\n        // SwapFlagMap flag;\r\n        bool isEToken;\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint256 amountIn;\r\n        uint256 minAmt;\r\n        uint256 block;   // 计算结果的 block\r\n        StepExecuteParams[] steps;\r\n    }\r\n\r\n    /// @dev Exchange 交易所合约地址及交易所类型\r\n    struct Exchange {\r\n        uint exFlag;\r\n        address contractAddr;\r\n    }\r\n\r\n\r\n    /// @dev 计算各个交易所的每个parts的return\r\n    struct SwapDistributes {\r\n        bool        isCtoken;     // 买入、卖出的币是否是 ctoken\r\n        // bool     ctokenOut;    // 买到的币是否是 ctoken\r\n        address     to;           // 交易者地址\r\n        address     tokenIn;\r\n        address     tokenOut;\r\n        uint256     parts;        // 交易量拆分为多少份\r\n        uint256     rateIn;       // token in exchange rate\r\n        uint256     rateOut;      // token out exchange rate\r\n        uint[]      amounts;      // split into parts\r\n        uint[]      cAmounts;     // mint to ctoken amounts\r\n        // address[]   midTokens;    // middle token list\r\n        // address[]   midCTokens;   // middle ctoken list\r\n        address[][] paths;        // 由 midTokens 和 复杂度计算得到的所有 path 列表\r\n        address[][] cpaths;       // 由 midCTokens 和 复杂度计算得到的所有 cpath 列表\r\n\r\n        uint[]      gases;          // gas 费用估算\r\n        uint[]      pathIdx;        // 使用的 path 序号\r\n        uint[][]    distributes;    // 一级为交易路径, 二级为该交易路径的所有parts对应的return\r\n        int256[][]  netDistributes; // distributes - gases\r\n        Exchange[]  exchanges;\r\n    }\r\n}\r\n"
    },
    "contracts/swap/aggressive2/library/SwapFlag.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./DataTypes.sol\";\r\n\r\nlibrary SwapFlag {\r\n    uint256 public constant FLAG_TOKEN_IN_ETH          = 0x000000000100; // prettier-ignore\r\n    uint256 public constant FLAG_TOKEN_TOKEN           = 0x000000000200; // prettier-ignore\r\n    uint256 public constant FLAG_TOKEN_CTOKEN          = 0x000000000400; // prettier-ignore\r\n    uint256 public constant FLAG_TOKEN_OUT_ETH         = 0x000000000800; // prettier-ignore\r\n    // uint256 public constant FLAG_TOKEN_OUT_TOKEN       = 0x000000001000; // prettier-ignore\r\n    // uint256 public constant FLAG_TOKEN_OUT_CTOKEN      = 0x000000002000; // prettier-ignore\r\n    // uint256 public constant FLAG_TOKEN_OUT_CETH        = 0x0000000040; // prettier-ignore\r\n\r\n    uint256 internal constant _MASK_PARTS           = 0x00000000000000000000ff; // prettier-ignore\r\n    uint256 internal constant _MASK_MAIN_ROUTES     = 0x00ff000000000000000000; // prettier-ignore\r\n    uint256 internal constant _MASK_COMPLEX_LEVEL   = 0x0300000000000000000000; // prettier-ignore\r\n    uint256 internal constant _MASK_PARTIAL_FILL    = 0x0400000000000000000000; // prettier-ignore\r\n    uint256 internal constant _MASK_BURN_CHI        = 0x0800000000000000000000; // prettier-ignore\r\n\r\n    // uint256 internal constant _SHIFT_PARTS          = 64; // prettier-ignore\r\n    uint256 internal constant _SHIFT_MAIN_ROUTES    = 72; // prettier-ignore\r\n    uint256 internal constant _SHIFT_COMPLEX_LEVEL  = 80; // prettier-ignore\r\n\r\n    /// @dev if token in/out is token\r\n    function tokenIsToken(DataTypes.SwapFlagMap memory self) public pure returns (bool) {\r\n        return (self.data & FLAG_TOKEN_TOKEN) != 0;\r\n    }\r\n\r\n    function tokenIsToken(uint flag) public pure returns (bool) {\r\n        return (flag & FLAG_TOKEN_TOKEN) != 0;\r\n    }\r\n    \r\n    /// @dev if token in/out is ctoken\r\n    function tokenIsCToken(DataTypes.SwapFlagMap memory self) public pure returns (bool) {\r\n        return (self.data & FLAG_TOKEN_CTOKEN) != 0;\r\n    }\r\n\r\n    /// @dev if token in is ETH\r\n    function tokenInIsETH(DataTypes.SwapFlagMap memory self) public pure returns (bool) {\r\n        return (self.data & FLAG_TOKEN_IN_ETH) != 0;\r\n    }\r\n\r\n    /// @dev if token out is ETH\r\n    function tokenOutIsETH(DataTypes.SwapFlagMap memory self) public pure returns (bool) {\r\n        return (self.data & FLAG_TOKEN_OUT_ETH) != 0;\r\n    }\r\n\r\n    /// @dev get param split parts\r\n    function getParts(DataTypes.SwapFlagMap memory self) public pure returns (uint256) {\r\n        return (self.data & _MASK_PARTS);\r\n    }\r\n\r\n    /// @dev get param main routes max port\r\n    function getMainRoutes(DataTypes.SwapFlagMap memory self) public pure returns (uint256) {\r\n        return (self.data & _MASK_MAIN_ROUTES) >> _SHIFT_MAIN_ROUTES;\r\n    }\r\n\r\n    /// @dev get param complex level\r\n    function getComplexLevel(DataTypes.SwapFlagMap memory self) public pure returns (uint256) {\r\n        return (self.data & _MASK_COMPLEX_LEVEL) >> _SHIFT_COMPLEX_LEVEL;\r\n    }\r\n\r\n    /// @dev get param allow partial fill\r\n    function allowPartialFill(DataTypes.SwapFlagMap memory self) public pure returns (bool) {\r\n        return (self.data & _MASK_PARTIAL_FILL) != 0;\r\n    }\r\n\r\n    /// @dev get param burn CHI\r\n    function burnCHI(DataTypes.SwapFlagMap memory self) public pure returns (bool) {\r\n        return (self.data & _MASK_BURN_CHI) != 0;\r\n    }\r\n}\r\n"
    },
    "contracts/swap/aggressive2/library/PathFinder.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\n/// @dev 寻找最优路径\r\n\r\nlibrary PathFinder {\r\n    function findBestDistribution(\r\n        uint256 s,                // parts\r\n        int256[][] memory amounts // exchangesReturns\r\n    )\r\n        public\r\n        view\r\n        returns(\r\n            int256 returnAmount,\r\n            uint256[] memory distribution\r\n        )\r\n    {\r\n        uint256 n = amounts.length;\r\n\r\n        int256[][] memory answer = new int256[][](n); // int[n][s+1]\r\n        uint256[][] memory parent = new uint256[][](n); // int[n][s+1]\r\n\r\n        for (uint i = 0; i < n; i++) {\r\n            answer[i] = new int256[](s + 1);\r\n            parent[i] = new uint256[](s + 1);\r\n        }\r\n        // console.log(\"amounts length:\", n, s, amounts[0].length);\r\n\r\n        for (uint j = 0; j <= s; j++) {\r\n            answer[0][j] = amounts[0][j];\r\n            for (uint i = 1; i < n; i++) {\r\n                answer[i][j] = 0;\r\n            }\r\n            parent[0][j] = 0;\r\n        }\r\n        // console.log(\"amounts length 2:\", n, s, amounts[0].length);\r\n\r\n        for (uint i = 1; i < n; i++) {\r\n            for (uint j = 0; j <= s; j++) {\r\n                answer[i][j] = answer[i - 1][j];\r\n                parent[i][j] = j;\r\n\r\n                for (uint k = 1; k <= j; k++) {\r\n                    if (answer[i - 1][j - k] + amounts[i][k] > answer[i][j]) {\r\n                        answer[i][j] = answer[i - 1][j - k] + amounts[i][k];\r\n                        parent[i][j] = j - k;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        console.log(\"amounts length 3:\", n, s, amounts[0].length);\r\n\r\n        distribution = new uint256[](n);\r\n\r\n        uint256 partsLeft = s;\r\n        for (uint curExchange = n - 1; partsLeft > 0; curExchange--) {\r\n            distribution[curExchange] = partsLeft - parent[curExchange][partsLeft];\r\n            partsLeft = parent[curExchange][partsLeft];\r\n        }\r\n\r\n        returnAmount = (answer[n - 1][s] <= 0) ? int256(0) : answer[n - 1][s];\r\n        console.log(\"return amount:\", uint(returnAmount));\r\n        for (uint i = 0; i < n; i ++) {\r\n            console.log(\"distribution[%d]: %d %d\", i, distribution[i], uint(amounts[i][s]));\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/swap/aggressive2/interface/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.12;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\n\r\nabstract contract IWETH is IERC20 {\r\n    function deposit() external virtual payable;\r\n\r\n    function withdraw(uint256 amount) external virtual;\r\n}\r\n"
    },
    "contracts/swap/aggressive2/interface/ICToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface ICToken {\r\n\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint, uint, uint);\r\n\r\n    function transfer(address dst, uint amount) external returns (bool);\r\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function balanceOfUnderlying(address owner) external returns (uint);\r\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\r\n    function borrowRatePerBlock() external view returns (uint);\r\n    function supplyRatePerBlock() external view returns (uint);\r\n    function totalBorrowsCurrent() external returns (uint);\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function borrowBalanceStored(address account) external view returns (uint);\r\n    function exchangeRateCurrent() external returns (uint);\r\n    function exchangeRateStored() external view returns (uint);\r\n    function getCash() external view returns (uint);\r\n    function accrueInterest() external returns (uint);\r\n    function accrualBlockNumber() external view returns (uint);\r\n    // function getCash() virtual external view returns (uint);\r\n    // function accrueInterest() virtual public returns (uint);\r\n    // function seize(address liquidator, address borrower, uint seizeTokens) virtual external returns (uint);\r\n\r\n}\r\n"
    },
    "contracts/swap/aggressive2/interface/ILHT.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface ILHT {\r\n\r\n    function mint() external payable returns (uint, uint);\r\n    function redeem(uint redeemTokens) external returns (uint, uint, uint);\r\n\r\n    function transfer(address dst, uint amount) external returns (bool);\r\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function balanceOfUnderlying(address owner) external returns (uint);\r\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\r\n    function borrowRatePerBlock() external view returns (uint);\r\n    function supplyRatePerBlock() external view returns (uint);\r\n    function totalBorrowsCurrent() external returns (uint);\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function borrowBalanceStored(address account) external view returns (uint);\r\n    function exchangeRateCurrent() external returns (uint);\r\n    function exchangeRateStored() external view returns (uint);\r\n    function getCash() external view returns (uint);\r\n    function accrueInterest() external returns (uint);\r\n    function accrualBlockNumber() external view returns (uint);\r\n    // function getCash() virtual external view returns (uint);\r\n    // function accrueInterest() virtual public returns (uint);\r\n    // function seize(address liquidator, address borrower, uint seizeTokens) virtual external returns (uint);\r\n\r\n}\r\n"
    },
    "contracts/swap/aggressive2/interface/ICTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.12;\r\n\r\n\r\ninterface ICTokenFactory {\r\n    // 根据 token 地址获取对应的 ctoken 地址\r\n    function getCTokenAddressPure(address token) external view returns (address);\r\n\r\n    // 根据 ctoken 地址获取对应的 token 地址\r\n    function getTokenAddress(address cToken) external view returns (address);\r\n}\r\n"
    },
    "contracts/swap/aggressive2/interface/IFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface IFactory {\r\n\r\n    function router() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function getReserves(address tokenA, address tokenB) external view returns (uint256 reserveA, uint256 reserveB);\r\n    \r\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountOut);\r\n    \r\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\r\n}\r\n"
    },
    "contracts/swap/aggressive2/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.12;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n"
    },
    "contracts/swap/aggressive2/Exchanges.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./interface/IWETH.sol\";\r\nimport \"./interface/ICToken.sol\";\r\nimport \"./interface/IFactory.sol\";\r\nimport \"./interface/IRouter.sol\";\r\nimport \"./interface/IDeBankRouter.sol\";\r\nimport \"./interface/IDeBankFactory.sol\";\r\nimport \"./interface/ICurve.sol\";\r\nimport \"./library/SafeMath.sol\";\r\nimport \"./library/DataTypes.sol\";\r\nimport \"./library/SwapFlag.sol\";\r\n\r\n// import \"hardhat/console.sol\";\r\n// import \"./interface/IAToken.sol\";\r\n\r\n/**\r\n * @title Exchanges library 计算能够 mint 、赎回、兑换多少\r\n * @author ebankex\r\n * @notice Provides data types and functions to perform step swap calculations\r\n * @dev Exchanges are used for aggressive swap within multi swap exchanges.\r\n **/\r\n\r\nlibrary Exchanges {\r\n    using SafeMath for uint;\r\n    using SafeMath for uint256;\r\n    using SwapFlag for DataTypes.SwapFlagMap;\r\n\r\n    uint constant public MAX_COMPLEX_LEVEL = 3;\r\n\r\n    uint constant public EXCHANGE_UNISWAP_V2 = 1;  // prettier-ignore\r\n    uint constant public EXCHANGE_UNISWAP_V3 = 2;  // prettier-ignore\r\n    uint constant public EXCHANGE_EBANK_EX   = 3;  // prettier-ignore\r\n    uint constant public EXCHANGE_CURVE      = 4;  // prettier-ignore\r\n\r\n    uint constant public SWAP_EBANK_CTOKENS_CTOKENS      = 1;  // prettier-ignore\r\n    uint constant public SWAP_EBANK_TOKENS_TOKENS        = 1;  // prettier-ignore\r\n    uint constant public SWAP_EBANK_ETH_TOKENS           = 1;  // prettier-ignore\r\n    uint constant public SWAP_EBANK_TOKENS_ETH           = 1;  // prettier-ignore\r\n\r\n    /// @dev 根据 midToken 数量, complexLevel 计算类 uniswap 交易所有多少个交易路径: 1 + P(midTokens, 1) + P(midTokens, 2) + .... + P(midTokens, complex)\r\n    /// complexLevel: 一次兑换时, 中间token的数量。例如为 2 时，可以的兑换路径为 a-m1-m2-b, a-m2-m1-b 或者 a-m1-b a-m2-b\r\n    /// 仅对于uniswap类的交易所, 其他类型交易所例如 curve 不适用\r\n    function uniswapRoutes(uint midTokens, uint complexLevel) internal pure returns (uint) {\r\n        uint count = 1;\r\n\r\n        if (complexLevel > MAX_COMPLEX_LEVEL) {\r\n            complexLevel = MAX_COMPLEX_LEVEL;\r\n        }\r\n\r\n        if (complexLevel >= midTokens) {\r\n            complexLevel = midTokens;\r\n        }\r\n        for (uint i = 1; i <= complexLevel; i ++) {\r\n            uint p = 1;\r\n            for (uint j = 0; j < i; j ++) {\r\n                p = p * (midTokens-j);\r\n            }\r\n            count += p;\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    /// @dev _itemInArray item 是否在数组 vec 中\r\n    function _itemInArray(address[] memory vec, address item) private pure returns (bool) {\r\n        for (uint i = 0; i < vec.length; i ++) {\r\n            if (item == vec[i]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @dev 递归计算特定 complex 下 paths 数组: P(midTokens, complex)\r\n    function calcPathComplex(\r\n                address[][] memory paths,\r\n                uint idx,\r\n                uint complex,\r\n                address token1,\r\n                address[] memory midTokens,\r\n                address[] memory path\r\n            )\r\n            internal\r\n            pure\r\n            returns (uint) {\r\n        if (complex == 0) {\r\n            address[] memory npath = new address[](path.length+1);\r\n            for (uint i = 0; i < path.length; i ++) {\r\n                npath[i] = path[i];\r\n            }\r\n            npath[npath.length-1] = token1;\r\n            paths[idx] = npath;\r\n            return idx+1;\r\n        }\r\n\r\n        for (uint i = 0; i < midTokens.length; i ++) {\r\n            address[] memory npath = new address[](path.length+1);\r\n            for (uint ip = 0; ip < path.length; ip ++) {\r\n                npath[ip] = path[ip];\r\n            }\r\n            address midToken = midTokens[i];\r\n            npath[npath.length-1] = midToken;\r\n\r\n            uint nMidLen = 0;\r\n            for (uint j = 0; j < midTokens.length; j ++) {\r\n                address mid = midTokens[j];\r\n                if (_itemInArray(npath, mid) == false) {\r\n                    nMidLen ++;\r\n                }\r\n            }\r\n            address[] memory nMidTokens = new address[](nMidLen);\r\n            uint midIdx = 0;\r\n            for (uint j = 0; j < midTokens.length; j ++) {\r\n                address mid = midTokens[j];\r\n                if (_itemInArray(npath, mid) == false) {\r\n                    nMidTokens[midIdx] = mid;\r\n                    midIdx ++;\r\n                }\r\n            }\r\n            idx = calcPathComplex(paths, idx, complex-1, token1, nMidTokens, npath);\r\n            // npath.pop();\r\n        }\r\n        return idx;\r\n    }\r\n\r\n    // 计算所有路径\r\n    function allPaths(\r\n                address tokenIn,\r\n                address tokenOut,\r\n                address[] memory midTokens,\r\n                uint complexLevel\r\n            )\r\n            public\r\n            pure\r\n            returns (address[][] memory paths) {\r\n        // uint complexLevel = args.flag.getComplexLevel();\r\n        uint mids = midTokens.length;\r\n        // address token0 = args.tokenIn;\r\n        // address token1 = args.tokenOut;\r\n        \r\n        if (complexLevel > MAX_COMPLEX_LEVEL) {\r\n            complexLevel = MAX_COMPLEX_LEVEL;\r\n        }\r\n\r\n        if (complexLevel >= mids) {\r\n            complexLevel = mids;\r\n        }\r\n\r\n        uint total = uniswapRoutes(mids, complexLevel);\r\n        // console.log(\"mids=%d complex=%d total path=%d\", mids, complexLevel, total);\r\n\r\n        uint idx = 0;\r\n        paths = new address[][](total);\r\n        // paths[idx] = new address[]{token0, token1};\r\n        // idx ++;\r\n\r\n        address[] memory initialPath = new address[](1);\r\n        initialPath[0] = tokenIn;\r\n\r\n        // address[] memory midTokens = new address[](midTokens.length);\r\n        // for (uint i = 0; i < mids; i ++) {\r\n        //     midTokens[i] = args.midTokens[i];\r\n        // }\r\n\r\n        for (uint i = 0; i <= complexLevel; i ++) {\r\n            idx = calcPathComplex(paths, idx, i, tokenOut, midTokens, initialPath);\r\n        }\r\n    }\r\n\r\n    function getExchangeRoutes(uint flag, uint midTokens, uint complexLevel) public pure returns (uint)  {\r\n        if (isUniswapLikeExchange(flag)) {\r\n            return uniswapRoutes(midTokens, complexLevel);\r\n        }\r\n        // todo 其他更多的类型\r\n        return 1;\r\n    }\r\n\r\n    function linearInterpolation(\r\n                    uint256 value,\r\n                    uint256 parts\r\n                )\r\n                internal\r\n                pure\r\n                returns(uint256[] memory rets) {\r\n        rets = new uint256[](parts);\r\n        for (uint i = 0; i < parts; i++) {\r\n            rets[i] = value.mul(i + 1).div(parts);\r\n        }\r\n    }\r\n\r\n    /// @dev calcDistributes calc swap exchange\r\n    function calcDistributes(\r\n                    DataTypes.Exchange memory ex,\r\n                    address[] memory path,\r\n                    uint[] memory amts,\r\n                    address to\r\n                )\r\n                public\r\n                view\r\n                returns (uint256[] memory distributes) {\r\n        uint flag = ex.exFlag;\r\n        address addr = ex.contractAddr;\r\n\r\n        if (flag == EXCHANGE_UNISWAP_V2 || flag == EXCHANGE_UNISWAP_V3) {\r\n            distributes = uniswapLikeSwap(addr, path, amts);\r\n            // for (uint i = 0; i < amts.length; i ++) {\r\n            //     distributes[i+1] = uniswapLikeSwap(addr, path, amts[i]);\r\n            // }\r\n        } else if (flag == EXCHANGE_EBANK_EX) {\r\n            distributes = new uint256[](amts.length+1);\r\n            for (uint i = 0; i < amts.length; i ++) {\r\n                distributes[i+1] = ebankSwap(addr, path, amts[i], to);\r\n            }\r\n        } else {\r\n            // should NOT reach here\r\n        }\r\n        // todo other swap\r\n    }\r\n\r\n    // 是否是 uniswap 类似的交易所\r\n    function isUniswapLikeExchange(uint flag) public pure returns (bool) {\r\n        if (flag == EXCHANGE_UNISWAP_V2 ||\r\n            flag == EXCHANGE_UNISWAP_V3 ||\r\n            flag == EXCHANGE_EBANK_EX) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function isEBankExchange(uint flag) public pure returns (bool) {\r\n        if (flag == EXCHANGE_EBANK_EX) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    // deposit eth from address from\r\n    function depositETH(IWETH weth) public returns (uint256) {\r\n        weth.deposit();\r\n\r\n        return weth.balanceOf(address(this));\r\n    }\r\n\r\n    // withdraw weth\r\n    function withdrawWETH(IWETH weth, uint256 amount) public {\r\n        weth.withdraw(amount);\r\n    }\r\n\r\n    /// @dev 计算 ctoken 的 exchange rate\r\n    function calcCTokenExchangeRate(ICToken ctoken) public view returns (uint) {\r\n        uint rate = ctoken.exchangeRateStored();\r\n        uint supplyRate = ctoken.supplyRatePerBlock();\r\n        uint lastBlock = ctoken.accrualBlockNumber();\r\n        uint blocks = block.number.sub(lastBlock);\r\n        uint inc = rate.mul(supplyRate).mul(blocks);\r\n        return rate.add(inc);\r\n    }\r\n\r\n    /// @dev 计算 token 能够 mint 得到多少 ctoken\r\n    function convertCompoundCtokenMinted(\r\n                    address ctoken,\r\n                    uint[] memory amounts,\r\n                    uint parts\r\n                )\r\n                public\r\n                view\r\n                returns (uint256[] memory) {\r\n        uint256 rate = calcCTokenExchangeRate(ICToken(ctoken));\r\n        uint256[] memory cAmts = new uint256[](parts);\r\n\r\n        for (uint i = 0; i < parts; i ++) {\r\n            cAmts[i] = amounts[i].mul(1e18).div(rate);\r\n        }\r\n        return cAmts;\r\n    }\r\n\r\n    /// @dev 计算 ctoken 能够 redeem 得到多少 token\r\n    function convertCompoundTokenRedeemed(\r\n                    address ctoken,\r\n                    uint[] memory cAmounts,\r\n                    uint parts\r\n                )\r\n                public\r\n                view\r\n                returns (uint256[] memory) {\r\n        uint256 rate = calcCTokenExchangeRate(ICToken(ctoken));\r\n        uint256[] memory amts = new uint256[](parts);\r\n\r\n        for (uint i = 0; i < parts; i ++) {\r\n            amts[i] = cAmounts[i].mul(rate).div(1e18);\r\n        }\r\n        return amts;\r\n    }\r\n\r\n    // mint token in compound\r\n    // token must NOT be ETH, ETH should _depositETH first, then do compound mint\r\n    // 币已经转到合约地址\r\n    function compoundMintToken(\r\n                    address ctoken,\r\n                    uint256 amount\r\n                )\r\n                public\r\n                returns (uint256) {\r\n        uint256 balanceBefore = IERC20(ctoken).balanceOf(address(this));\r\n        ICToken(ctoken).mint(amount);\r\n\r\n        return IERC20(ctoken).balanceOf(address(this)).sub(balanceBefore);\r\n    }\r\n\r\n    /// @dev compund mint ETH\r\n    function compoundMintETH(\r\n                    address weth,\r\n                    uint amount\r\n                )\r\n                public\r\n                returns (uint256) {\r\n        IWETH(weth).deposit{value: amount}();\r\n\r\n        return compoundMintToken(address(weth), amount);\r\n    }\r\n\r\n    /// @dev compoundRedeemCToken redeem compound token\r\n    /// @param ctoken compund token\r\n    /// @param amount amount to redeem\r\n    function compoundRedeemCToken(address ctoken, uint256 amount) public {\r\n        ICToken(ctoken).redeem(amount);\r\n    }\r\n\r\n    /// @dev aave deposit token\r\n    function aaveDepositToken(address aToken) public pure {\r\n        aToken;\r\n    }\r\n\r\n    /// @dev withdraw aave token\r\n    function aaveWithdrawToken(address aToken, uint256 amt) public pure {\r\n        aToken;\r\n        amt;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////////\r\n    /////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    /// todo 需要考虑 reserve 为 0 的情况\r\n\r\n    /// @dev uniswap like exchange\r\n    // function uniswapLikeSwap(\r\n    //                 address router,\r\n    //                 address[] memory path,\r\n    //                 uint256 amountIn\r\n    //             )\r\n    //             public\r\n    //             view\r\n    //             returns (uint) {\r\n    //     IFactory factory = IFactory(IRouter(router).factory());\r\n    //     uint[] memory amounts = new uint[](path.length);\r\n    //     amounts[0] = amountIn;\r\n    //     for (uint i = 0; i < path.length - 1; i ++) {\r\n    //         address pair = factory.getPair(path[i], path[i+1]);\r\n    //         if (pair == address(0)) {\r\n    //             return 0;\r\n    //         }\r\n    //         (uint ra, uint rb) = factory.getReserves(path[i], path[i+1]);\r\n    //         if (ra == 0 || rb == 0) {\r\n    //             return 0;\r\n    //         }\r\n    //         amounts[i+1] = factory.getAmountOut(amounts[i], ra, rb);\r\n    //     }\r\n    //     // uint[] memory amounts = IRouter(router).getAmountsOut(amountIn, path);\r\n    //     return amounts[amounts.length - 1];\r\n    // }\r\n\r\n    function calculateUniswapFormula(uint256 fromBalance, uint256 toBalance, uint256 amount) internal pure returns(uint256) {\r\n        if (amount == 0) {\r\n            return 0;\r\n        }\r\n        return amount.mul(toBalance).mul(997).div(\r\n            fromBalance.mul(1000).add(amount.mul(997))\r\n        );\r\n    }\r\n\r\n    function getReserves(\r\n                    address router,\r\n                    address[] memory path\r\n                )\r\n                public\r\n                view\r\n                returns (uint[][] memory reserves) {\r\n\r\n        uint plen = path.length;\r\n        reserves = new uint[][](plen);\r\n        IFactory factory = IFactory(IRouter(router).factory());\r\n        for (uint i = 0; i < plen - 1; i ++) {\r\n            // address t0 = path[i] == address(0) ? weth : path[i];\r\n            // address t1 = path[i+1] == address(0) ? weth : path[i+1];\r\n            address pair = factory.getPair(path[i], path[i+1]);\r\n            uint[] memory res = new uint[](2);\r\n            if (pair == address(0)) {\r\n                reserves[i] = res;\r\n                // return reserves;\r\n                continue;\r\n            }\r\n            // (uint r0, uint r1, ) = IPair(pair).getReserves();\r\n            // if (r0 == 0 || r1 == 0) {\r\n            //     return reserves;\r\n            // }\r\n            // reserves[i] = IERC20(path[i]).balanceOf(pair);\r\n            // reserves[i+1] = IERC20(path[i+1]).balanceOf(pair);\r\n            // if (reserves[i] == 0 || reserves[i+1] == 0) {\r\n            //     return reserves;\r\n            // }\r\n            res[0] = IERC20(path[i]).balanceOf(pair);\r\n            res[1] = IERC20(path[i+1]).balanceOf(pair);\r\n            reserves[i] = res;\r\n            // if (reserves[i] == 0 || reserves[i+1] == 0) {\r\n            //     return reserves;\r\n            // }\r\n        }\r\n    }\r\n\r\n    function uniswapLikeSwap(\r\n                    address router,\r\n                    address[] memory path,\r\n                    uint256[] memory amountIns\r\n                )\r\n                public\r\n                view\r\n                returns (uint[] memory amountOuts) {\r\n        uint plen = path.length;\r\n        uint[] memory reserves = new uint[](plen);\r\n        amountOuts = new uint[](amountIns.length+1);\r\n\r\n        IFactory factory = IFactory(IRouter(router).factory());\r\n        for (uint i = 0; i < plen - 1; i ++) {\r\n            // address t0 = path[i] == address(0) ? weth : path[i];\r\n            // address t1 = path[i+1] == address(0) ? weth : path[i+1];\r\n            address pair = factory.getPair(path[i], path[i+1]);\r\n            if (pair == address(0)) {\r\n                return amountOuts;\r\n            }\r\n            reserves[i] = IERC20(path[i]).balanceOf(pair);\r\n            reserves[i+1] = IERC20(path[i+1]).balanceOf(pair);\r\n            if (reserves[i] == 0 || reserves[i+1] == 0) {\r\n                return amountOuts;\r\n            }\r\n        }\r\n\r\n        uint[] memory tmp = new uint[](plen);\r\n        for (uint i = 0; i < amountIns.length; i ++) {\r\n            tmp[0] = amountIns[i];\r\n            for (uint j = 0; j < plen - 1; j ++) {\r\n                tmp[j + 1] = calculateUniswapFormula(reserves[j], reserves[j+1], tmp[j]);\r\n            }\r\n            amountOuts[i+1] = tmp[plen-1];\r\n        }\r\n\r\n        // amounts[0] = amountIn;\r\n        // for (uint i = 0; i < path.length - 1; i ++) {\r\n        //     address pair = factory.getPair(path[i], path[i+1]);\r\n        //     if (pair == address(0)) {\r\n        //         return 0;\r\n        //     }\r\n        //     (uint ra, uint rb) = factory.getReserves(path[i], path[i+1]);\r\n        //     if (ra == 0 || rb == 0) {\r\n        //         return 0;\r\n        //     }\r\n        //     amounts[i+1] = factory.getAmountOut(amounts[i], ra, rb);\r\n        // }\r\n        // // uint[] memory amounts = IRouter(router).getAmountsOut(amountIn, path);\r\n        // return amounts[amounts.length - 1];\r\n    }\r\n\r\n    /// @dev ebank exchange\r\n    function ebankSwap(\r\n                    address router,\r\n                    address[] memory path,\r\n                    uint256 amountIn,\r\n                    address to\r\n                )\r\n                public\r\n                view\r\n                returns (uint) {\r\n        IDeBankFactory factory = IDeBankFactory(IDeBankRouter(router).factory());\r\n        uint[] memory amounts = new uint[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint i = 0; i < path.length - 1; i ++) {\r\n            address pair = factory.getPair(path[i], path[i+1]);\r\n            if (pair == address(0)) {\r\n                return 0;\r\n            }\r\n            (uint ra, uint rb, uint feeRate, bool outAnchorToken) = factory.getReservesFeeRate(path[i], path[i + 1], to);\r\n            if (ra == 0 || rb == 0) {\r\n                return 0;\r\n            }\r\n            if (outAnchorToken) {\r\n                amounts[i + 1] = factory.getAmountOutFeeRateAnchorToken(amounts[i], ra, rb, feeRate);\r\n            } else {\r\n                amounts[i + 1] = factory.getAmountOutFeeRate(amounts[i], ra, rb, feeRate);\r\n            }\r\n        }\r\n        // uint[] memory amounts = IRouter(router).getAmountsOut(amountIn, path);\r\n        return amounts[amounts.length - 1];\r\n        // uint[] memory amounts = IDeBankRouter(router).getAmountsOut(amountIn, path, to);\r\n        // return amounts[amounts.length - 1];\r\n    }\r\n\r\n    /// @dev swap stable coin in curve\r\n    function curveSwap(\r\n                    address addr,\r\n                    uint i,\r\n                    uint j,\r\n                    uint dx\r\n                )\r\n                public\r\n                view\r\n                returns (uint) {\r\n        return ICurve(addr).get_dy(int128(i), int128(j), dx);\r\n    }\r\n}\r\n"
    },
    "contracts/swap/aggressive2/interface/IERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity ^0.6.12;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n"
    },
    "contracts/swap/aggressive2/interface/IRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface IRouter {\r\n    function factory() external view returns (address);\r\n    \r\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    \r\n    function swapExactETHForTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    \r\n    function swapExactTokensForETH(\r\n            uint amountIn,\r\n            uint amountOutMin,\r\n            address[] calldata path,\r\n            address to,\r\n            uint deadline\r\n        )\r\n        external\r\n        returns (uint[] memory amounts);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n}\r\n"
    },
    "contracts/swap/aggressive2/interface/IDeBankRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface IDeBankRouter {\r\n    function factory() external view returns (address);\r\n    \r\n    /// @dev getAmountsOut 对比 IRouter 增加了 to 参数, 可以根据 to 来决定手续费率\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path, address to) external view returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForTokensUnderlying(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokensUnderlying(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n        \r\n    function swapExactTokensForETHUnderlying(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n\r\n}\r\n"
    },
    "contracts/swap/aggressive2/interface/IDeBankFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.12;\r\n\r\ninterface IDeBankFactory {\r\n    function router() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, address token1);\r\n\r\n    function pairFor(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function getReserves(address tokenA, address tokenB) external view returns (uint256 reserveA, uint256 reserveB);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path, address to) external view returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path, address to) external view returns (uint256[] memory amounts);\r\n\r\n    // function amountToCTokenAmt(address ctoken, uint amountIn) external view returns (uint cAmountIn);\r\n    // function ctokenAmtToAmount(address ctoken, uint cAmountOut) external view returns (uint amountOut);\r\n\r\n    function setPairFeeRate(address pair, uint feeRate) external;\r\n\r\n    function getReservesFeeRate(address tokenA, address tokenB, address to) \r\n                external view returns (uint reserveA, uint reserveB, uint feeRate, bool outAnchorToken);\r\n\r\n    function getAmountOutFeeRate(uint amountIn, uint reserveIn, uint reserveOut, uint feeRate) external pure returns (uint amountOut);\r\n\r\n    function getAmountOutFeeRateAnchorToken(uint amountIn, uint reserveIn, uint reserveOut, uint feeRate) external pure returns (uint amountOut);\r\n}\r\n"
    },
    "contracts/swap/aggressive2/interface/ICurve.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface ICurve {\r\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\r\n    function get_dy_underlying(int128 i, int128 j, uint256 dx) external view returns (uint256);\r\n\r\n    \r\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\r\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}