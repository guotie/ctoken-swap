{
  "language": "Solidity",
  "sources": {
    "contracts/common/ComptrollerInterface.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\nabstract contract ComptrollerInterface {\r\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\r\n    bool public constant isComptroller = true;\r\n\r\n    /*** Assets You Are In ***/\r\n\r\n    function enterMarkets(address[] calldata cTokens) virtual external returns (uint[] memory);\r\n    function exitMarket(address cToken) virtual external returns (uint);\r\n\r\n    /*** Policy Hooks ***/\r\n\r\n    function mintAllowed(address cToken, address minter, uint mintAmount) virtual external returns (uint);\r\n    function mintVerify(address cToken, address minter, uint mintAmount, uint mintTokens) virtual external;\r\n\r\n    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) virtual external returns (uint);\r\n    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) virtual external;\r\n\r\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) virtual external returns (uint);\r\n    function borrowVerify(address cToken, address borrower, uint borrowAmount) virtual external;\r\n\r\n    function repayBorrowAllowed(\r\n        address cToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount) virtual external returns (uint);\r\n    function repayBorrowVerify(\r\n        address cToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount,\r\n        uint borrowerIndex) virtual external;\r\n\r\n    function liquidateBorrowAllowed(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount) virtual external returns (uint);\r\n    function liquidateBorrowVerify(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount,\r\n        uint seizeTokens) virtual external;\r\n\r\n    function seizeAllowed(\r\n        address cTokenCollateral,\r\n        address cTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) virtual external returns (uint);\r\n    function seizeVerify(\r\n        address cTokenCollateral,\r\n        address cTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) virtual external;\r\n\r\n    function transferAllowed(address cToken, address src, address dst, uint transferTokens) virtual external returns (uint);\r\n    function transferVerify(address cToken, address src, address dst, uint transferTokens) virtual external;\r\n\r\n    /*** Liquidity/Liquidation Calculations ***/\r\n\r\n    function liquidateCalculateSeizeTokens(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        uint repayAmount) virtual external view returns (uint, uint);\r\n\r\n\r\n    /**\r\n     * 根据 token 地址查找 cToken 地址\r\n     * 如果是ETH/HT/BNB, 应该先变成对应的 wrapped ETH/HT/BNB\r\n     */\r\n    function getCTokenAddress(address token) virtual external view returns (address);\r\n    function _supportMarket(address cToken) virtual external returns (uint);\r\n}\r\n"
    },
    "contracts/compound/CToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\nimport \"../common/ComptrollerInterface.sol\";\r\nimport \"../common/CTokenInterfaces.sol\";\r\nimport \"../common/InterestRateModel.sol\";\r\n\r\nimport \"./ErrorReporter.sol\";\r\nimport \"./Exponential.sol\";\r\nimport \"./EIP20Interface.sol\";\r\nimport \"./EIP20NonStandardInterface.sol\";\r\n\r\n// for debug\r\nimport \"hardhat/console.sol\";\r\n\r\n/**\r\n * @title LendHub's CToken Contract\r\n * @notice Abstract base for CTokens\r\n * @author LendHub\r\n */\r\nabstract contract CToken is CTokenInterface, Exponential, TokenErrorReporter {\r\n    /**\r\n     * @notice Initialize the money market\r\n     * @param comptroller_ The address of the Comptroller\r\n     * @param interestRateModel_ The address of the interest rate model\r\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\r\n     * @param name_ EIP-20 name of this token\r\n     * @param symbol_ EIP-20 symbol of this token\r\n     * @param decimals_ EIP-20 decimal precision of this token\r\n     */\r\n    function initialize(ComptrollerInterface comptroller_,\r\n                        InterestRateModel interestRateModel_,\r\n                        uint initialExchangeRateMantissa_,\r\n                        string memory name_,\r\n                        string memory symbol_,\r\n                        uint8 decimals_) public {\r\n        require(msg.sender == admin, \"only admin may initialize the market\");\r\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\r\n\r\n        // Set initial exchange rate\r\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\r\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\r\n\r\n        // Set the comptroller\r\n        uint err = _setComptroller(comptroller_);\r\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\r\n\r\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\r\n        accrualBlockNumber = getBlockNumber();\r\n        borrowIndex = mantissaOne;\r\n\r\n        // Set the interest rate model (depends on block number / borrow index)\r\n        err = _setInterestRateModelFresh(interestRateModel_);\r\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\r\n\r\n        name = name_;\r\n        symbol = symbol_;\r\n        decimals = decimals_;\r\n\r\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\r\n     * @dev Called by both `transfer` and `transferFrom` internally\r\n     * @param spender The address of the account performing the transfer\r\n     * @param src The address of the source account\r\n     * @param dst The address of the destination account\r\n     * @param tokens The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\r\n        /* Fail if transfer not allowed */\r\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        /* Do not allow self-transfers */\r\n        if (src == dst) {\r\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\r\n        }\r\n\r\n        /* Get the allowance, infinite for the account owner */\r\n        uint startingAllowance = 0;\r\n        if (spender == src) {\r\n            startingAllowance = uint(-1);\r\n        } else {\r\n            startingAllowance = transferAllowances[src][spender];\r\n        }\r\n\r\n        /* Do the calculations, checking for {under,over}flow */\r\n        MathError mathErr;\r\n        uint allowanceNew;\r\n        uint srcTokensNew;\r\n        uint dstTokensNew;\r\n\r\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\r\n        }\r\n\r\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\r\n        }\r\n\r\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        accountTokens[src] = srcTokensNew;\r\n        accountTokens[dst] = dstTokensNew;\r\n\r\n        /* Eat some of the allowance (if necessary) */\r\n        if (startingAllowance != uint(-1)) {\r\n            transferAllowances[src][spender] = allowanceNew;\r\n        }\r\n\r\n        /* We emit a Transfer event */\r\n        emit Transfer(src, dst, tokens);\r\n\r\n        comptroller.transferVerify(address(this), src, dst, tokens);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n     * @param dst The address of the destination account\r\n     * @param amount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transfer(address dst, uint256 amount) override external nonReentrant returns (bool) {\r\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `src` to `dst`\r\n     * @param src The address of the source account\r\n     * @param dst The address of the destination account\r\n     * @param amount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transferFrom(address src, address dst, uint256 amount) override external nonReentrant returns (bool) {\r\n        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Approve `spender` to transfer up to `amount` from `src`\r\n     * @dev This will overwrite the approval amount for `spender`\r\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\r\n     * @param spender The address of the account which may transfer tokens\r\n     * @param amount The number of tokens that are approved (-1 means infinite)\r\n     * @return Whether or not the approval succeeded\r\n     */\r\n    function approve(address spender, uint256 amount) override external returns (bool) {\r\n        address src = msg.sender;\r\n        transferAllowances[src][spender] = amount;\r\n        emit Approval(src, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the current allowance from `owner` for `spender`\r\n     * @param owner The address of the account which owns the tokens to be spent\r\n     * @param spender The address of the account which may transfer tokens\r\n     * @return The number of tokens allowed to be spent (-1 means infinite)\r\n     */\r\n    function allowance(address owner, address spender) override external view returns (uint256) {\r\n        return transferAllowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the token balance of the `owner`\r\n     * @param owner The address of the account to query\r\n     * @return The number of tokens owned by `owner`\r\n     */\r\n    function balanceOf(address owner) override external view returns (uint256) {\r\n        return accountTokens[owner];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the underlying balance of the `owner`\r\n     * @dev This also accrues interest in a transaction\r\n     * @param owner The address of the account to query\r\n     * @return The amount of underlying owned by `owner`\r\n     */\r\n    function balanceOfUnderlying(address owner) override external returns (uint) {\r\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\r\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\r\n        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\r\n        return balance;\r\n    }\r\n\r\n    /**\r\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\r\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\r\n     * @param account Address of the account to snapshot\r\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\r\n     */\r\n    function getAccountSnapshot(address account) override external view returns (uint, uint, uint, uint) {\r\n        uint cTokenBalance = accountTokens[account];\r\n        uint borrowBalance;\r\n        uint exchangeRateMantissa;\r\n\r\n        MathError mErr;\r\n\r\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\r\n        if (mErr != MathError.NO_ERROR) {\r\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\r\n        }\r\n\r\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\r\n        if (mErr != MathError.NO_ERROR) {\r\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\r\n        }\r\n\r\n        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to simply retrieve block number\r\n     *  This exists mainly for inheriting test contracts to stub this result.\r\n     */\r\n    function getBlockNumber() internal view returns (uint) {\r\n        return block.number;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current per-block borrow interest rate for this cToken\r\n     * @return The borrow interest rate per block, scaled by 1e18\r\n     */\r\n    function borrowRatePerBlock() override external view returns (uint) {\r\n        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current per-block supply interest rate for this cToken\r\n     * @return The supply interest rate per block, scaled by 1e18\r\n     */\r\n    function supplyRatePerBlock() override external view returns (uint) {\r\n        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current total borrows plus accrued interest\r\n     * @return The total borrows with interest\r\n     */\r\n    function totalBorrowsCurrent() override external nonReentrant returns (uint) {\r\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\r\n        return totalBorrows;\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\r\n     * @param account The address whose balance should be calculated after updating borrowIndex\r\n     * @return The calculated balance\r\n     */\r\n    function borrowBalanceCurrent(address account) override external nonReentrant returns (uint) {\r\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\r\n        return borrowBalanceStored(account);\r\n    }\r\n\r\n    /**\r\n     * @notice Return the borrow balance of account based on stored data\r\n     * @param account The address whose balance should be calculated\r\n     * @return The calculated balance\r\n     */\r\n    function borrowBalanceStored(address account) override public view returns (uint) {\r\n        (MathError err, uint result) = borrowBalanceStoredInternal(account);\r\n        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the borrow balance of account based on stored data\r\n     * @param account The address whose balance should be calculated\r\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\r\n     */\r\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\r\n        /* Note: we do not assert that the market is up to date */\r\n        MathError mathErr;\r\n        uint principalTimesIndex;\r\n        uint result;\r\n\r\n        /* Get borrowBalance and borrowIndex */\r\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\r\n\r\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\r\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\r\n         */\r\n        if (borrowSnapshot.principal == 0) {\r\n            return (MathError.NO_ERROR, 0);\r\n        }\r\n\r\n        /* Calculate new borrow balance using the interest index:\r\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\r\n         */\r\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (mathErr, 0);\r\n        }\r\n\r\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (mathErr, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, result);\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue interest then return the up-to-date exchange rate\r\n     * @return Calculated exchange rate scaled by 1e18\r\n     */\r\n    function exchangeRateCurrent() override public nonReentrant returns (uint) {\r\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\r\n        return exchangeRateStored();\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the exchange rate from the underlying to the CToken\r\n     * @dev This function does not accrue interest before calculating the exchange rate\r\n     * @return Calculated exchange rate scaled by 1e18\r\n     */\r\n    function exchangeRateStored() override public view returns (uint) {\r\n        (MathError err, uint result) = exchangeRateStoredInternal();\r\n        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the exchange rate from the underlying to the CToken\r\n     * @dev This function does not accrue interest before calculating the exchange rate\r\n     * @return (error code, calculated exchange rate scaled by 1e18)\r\n     */\r\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\r\n        uint _totalSupply = totalSupply;\r\n        if (_totalSupply == 0) {\r\n            /*\r\n             * If there are no tokens minted:\r\n             *  exchangeRate = initialExchangeRate\r\n             */\r\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\r\n        } else {\r\n            /*\r\n             * Otherwise:\r\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\r\n             */\r\n            uint totalCash = getCashPrior();\r\n            uint cashPlusBorrowsMinusReserves;\r\n            Exp memory exchangeRate;\r\n            MathError mathErr;\r\n\r\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\r\n            if (mathErr != MathError.NO_ERROR) {\r\n                return (mathErr, 0);\r\n            }\r\n\r\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\r\n            if (mathErr != MathError.NO_ERROR) {\r\n                return (mathErr, 0);\r\n            }\r\n\r\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get cash balance of this cToken in the underlying asset\r\n     * @return The quantity of underlying asset owned by this contract\r\n     */\r\n    function getCash() override external view returns (uint) {\r\n        return getCashPrior();\r\n    }\r\n\r\n    /**\r\n     * @notice Applies accrued interest to total borrows and reserves\r\n     * @dev This calculates interest accrued from the last checkpointed block\r\n     *   up to the current block and writes new checkpoint to storage.\r\n     *   更新利息 每个块只计算一次利息\r\n     */\r\n    function accrueInterest() override public returns (uint) {\r\n        /* Remember the initial block number */\r\n        uint currentBlockNumber = getBlockNumber();\r\n        uint accrualBlockNumberPrior = accrualBlockNumber;\r\n\r\n        /* Short-circuit accumulating 0 interest */\r\n        if (accrualBlockNumberPrior == currentBlockNumber) {\r\n            return uint(Error.NO_ERROR);\r\n        }\r\n\r\n        /* Read the previous values out of storage */\r\n        uint cashPrior = getCashPrior();  // token 的数量\r\n        uint borrowsPrior = totalBorrows;\r\n        uint reservesPrior = totalReserves;\r\n        uint borrowIndexPrior = borrowIndex;\r\n\r\n        /* Calculate the current borrow interest rate */\r\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\r\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\r\n\r\n        /* Calculate the number of blocks elapsed since the last accrual */\r\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\r\n        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\r\n\r\n        /*\r\n         * Calculate the interest accumulated into borrows and reserves and the new index:\r\n         *  simpleInterestFactor = borrowRate * blockDelta\r\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\r\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\r\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\r\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\r\n         */\r\n\r\n        Exp memory simpleInterestFactor;\r\n        uint interestAccumulated;\r\n        uint totalBorrowsNew;\r\n        uint totalReservesNew;\r\n        uint borrowIndexNew;\r\n\r\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa: borrowRateMantissa}), blockDelta);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(mathErr));\r\n        }\r\n\r\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(mathErr));\r\n        }\r\n\r\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(mathErr));\r\n        }\r\n\r\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(mathErr));\r\n        }\r\n\r\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(mathErr));\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /* We write the previously calculated values into storage */\r\n        accrualBlockNumber = currentBlockNumber;\r\n        borrowIndex = borrowIndexNew;\r\n        totalBorrows = totalBorrowsNew;\r\n        totalReserves = totalReservesNew;\r\n\r\n        /* We emit an AccrueInterest event */\r\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\r\n     */\r\n    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\r\n            return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);\r\n        }\r\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\r\n        return mintFresh(msg.sender, mintAmount);\r\n    }\r\n\r\n    struct MintLocalVars {\r\n        Error err;\r\n        MathError mathErr;\r\n        uint exchangeRateMantissa;\r\n        uint mintTokens;\r\n        uint totalSupplyNew;\r\n        uint accountTokensNew;\r\n        uint actualMintAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice User supplies assets into the market and receives cTokens in exchange\r\n     * @dev Assumes interest has already been accrued up to the current block\r\n     * @param minter The address of the account which is supplying the assets\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\r\n     */\r\n    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\r\n        /* Fail if mint not allowed */\r\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\r\n        if (allowed != 0) {\r\n            console.log(\"token not allowed\");\r\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\r\n        }\r\n\r\n        /* Verify market's block number equals current block number */\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\r\n        }\r\n\r\n        MintLocalVars memory vars;\r\n\r\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /*\r\n         *  We call `doTransferIn` for the minter and the mintAmount.\r\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\r\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\r\n         *  side-effects occurred. The function returns the amount actually transferred,\r\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\r\n         *  of cash.\r\n         */\r\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\r\n\r\n        /*\r\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\r\n         *  mintTokens = actualMintAmount / exchangeRate\r\n         */\r\n\r\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\r\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\r\n\r\n        /*\r\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\r\n         *  totalSupplyNew = totalSupply + mintTokens\r\n         *  accountTokensNew = accountTokens[minter] + mintTokens\r\n         */\r\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\r\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\r\n\r\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\r\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\r\n\r\n        /* We write previously calculated values into storage */\r\n        totalSupply = vars.totalSupplyNew;\r\n        accountTokens[minter] = vars.accountTokensNew;\r\n\r\n        /* We emit a Mint event, and a Transfer event */\r\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\r\n        emit Transfer(address(this), minter, vars.mintTokens);\r\n\r\n        /* We call the defense hook */\r\n        comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\r\n\r\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems cTokens in exchange for the underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemTokens The number of cTokens to redeem into underlying\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\r\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\r\n        return redeemFresh(msg.sender, redeemTokens, 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemAmount The amount of underlying to receive from redeeming cTokens\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\r\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\r\n        return redeemFresh(msg.sender, 0, redeemAmount);\r\n    }\r\n\r\n    struct RedeemLocalVars {\r\n        Error err;\r\n        MathError mathErr;\r\n        uint exchangeRateMantissa;\r\n        uint redeemTokens;\r\n        uint redeemAmount;\r\n        uint totalSupplyNew;\r\n        uint accountTokensNew;\r\n    }\r\n\r\n    /**\r\n     * @notice User redeems cTokens in exchange for the underlying asset\r\n     * @dev Assumes interest has already been accrued up to the current block\r\n     * @param redeemer The address of the account which is redeeming the tokens\r\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\r\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\r\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\r\n\r\n        RedeemLocalVars memory vars;\r\n\r\n        /* exchangeRate = invoke Exchange Rate Stored() */\r\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        /* If redeemTokensIn > 0: */\r\n        if (redeemTokensIn > 0) {\r\n            /*\r\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\r\n             *  redeemTokens = redeemTokensIn\r\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\r\n             */\r\n            vars.redeemTokens = redeemTokensIn;\r\n\r\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\r\n            if (vars.mathErr != MathError.NO_ERROR) {\r\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\r\n            }\r\n        } else {\r\n            /*\r\n             * We get the current exchange rate and calculate the amount to be redeemed:\r\n             *  redeemTokens = redeemAmountIn / exchangeRate\r\n             *  redeemAmount = redeemAmountIn\r\n             */\r\n\r\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\r\n            if (vars.mathErr != MathError.NO_ERROR) {\r\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\r\n            }\r\n\r\n            vars.redeemAmount = redeemAmountIn;\r\n        }\r\n\r\n        /* Fail if redeem not allowed */\r\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        /* Verify market's block number equals current block number */\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\r\n        }\r\n\r\n        /*\r\n         * We calculate the new total supply and redeemer balance, checking for underflow:\r\n         *  totalSupplyNew = totalSupply - redeemTokens\r\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\r\n         */\r\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        /* Fail gracefully if protocol has insufficient cash */\r\n        if (getCashPrior() < vars.redeemAmount) {\r\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /*\r\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\r\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\r\n         *  On success, the cToken has redeemAmount less of cash.\r\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\r\n         */\r\n        doTransferOut(redeemer, vars.redeemAmount);\r\n\r\n        /* We write previously calculated values into storage */\r\n        totalSupply = vars.totalSupplyNew;\r\n        accountTokens[redeemer] = vars.accountTokensNew;\r\n\r\n        /* We emit a Transfer event, and a Redeem event */\r\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\r\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\r\n\r\n        /* We call the defense hook */\r\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sender borrows assets from the protocol to their own address\r\n      * @param borrowAmount The amount of the underlying asset to borrow\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\r\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\r\n        return borrowFresh(msg.sender, borrowAmount);\r\n    }\r\n\r\n    struct BorrowLocalVars {\r\n        MathError mathErr;\r\n        uint accountBorrows;\r\n        uint accountBorrowsNew;\r\n        uint totalBorrowsNew;\r\n    }\r\n\r\n    /**\r\n      * @notice Users borrow assets from the protocol to their own address\r\n      * @param borrowAmount The amount of the underlying asset to borrow\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\r\n        /* Fail if borrow not allowed */\r\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        /* Verify market's block number equals current block number */\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\r\n        }\r\n\r\n        /* Fail gracefully if protocol has insufficient underlying cash */\r\n        if (getCashPrior() < borrowAmount) {\r\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\r\n        }\r\n\r\n        BorrowLocalVars memory vars;\r\n\r\n        /*\r\n         * We calculate the new borrower and total borrow balances, failing on overflow:\r\n         *  accountBorrowsNew = accountBorrows + borrowAmount\r\n         *  totalBorrowsNew = totalBorrows + borrowAmount\r\n         */\r\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /*\r\n         * We invoke doTransferOut for the borrower and the borrowAmount.\r\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\r\n         *  On success, the cToken borrowAmount less of cash.\r\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\r\n         */\r\n        doTransferOut(borrower, borrowAmount);\r\n\r\n        /* We write the previously calculated values into storage */\r\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\r\n        accountBorrows[borrower].interestIndex = borrowIndex;\r\n        totalBorrows = vars.totalBorrowsNew;\r\n\r\n        /* We emit a Borrow event */\r\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\r\n\r\n        /* We call the defense hook */\r\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender repays their own borrow\r\n     * @param repayAmount The amount to repay\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\r\n     */\r\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\r\n            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\r\n        }\r\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\r\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender repays a borrow belonging to borrower\r\n     * @param borrower the account with the debt being payed off\r\n     * @param repayAmount The amount to repay\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\r\n     */\r\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\r\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\r\n        }\r\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\r\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\r\n    }\r\n\r\n    struct RepayBorrowLocalVars {\r\n        Error err;\r\n        MathError mathErr;\r\n        uint repayAmount;\r\n        uint borrowerIndex;\r\n        uint accountBorrows;\r\n        uint accountBorrowsNew;\r\n        uint totalBorrowsNew;\r\n        uint actualRepayAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Borrows are repaid by another user (possibly the borrower).\r\n     * @param payer the account paying off the borrow\r\n     * @param borrower the account with the debt being payed off\r\n     * @param repayAmount the amount of undelrying tokens being returned\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\r\n     */\r\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\r\n        /* Fail if repayBorrow not allowed */\r\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\r\n        if (allowed != 0) {\r\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);\r\n        }\r\n\r\n        /* Verify market's block number equals current block number */\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\r\n        }\r\n\r\n        RepayBorrowLocalVars memory vars;\r\n\r\n        /* We remember the original borrowerIndex for verification purposes */\r\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\r\n\r\n        /* We fetch the amount the borrower owes, with accumulated interest */\r\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);\r\n        }\r\n\r\n        /* If repayAmount == -1, repayAmount = accountBorrows */\r\n        if (repayAmount == uint(-1)) {\r\n            vars.repayAmount = vars.accountBorrows;\r\n        } else {\r\n            vars.repayAmount = repayAmount;\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /*\r\n         * We call doTransferIn for the payer and the repayAmount\r\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\r\n         *  On success, the cToken holds an additional repayAmount of cash.\r\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\r\n         *   it returns the amount actually transferred, in case of a fee.\r\n         */\r\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\r\n\r\n        /*\r\n         * We calculate the new borrower and total borrow balances, failing on underflow:\r\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\r\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\r\n         */\r\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\r\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\r\n\r\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\r\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\r\n\r\n        /* We write the previously calculated values into storage */\r\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\r\n        accountBorrows[borrower].interestIndex = borrowIndex;\r\n        totalBorrows = vars.totalBorrowsNew;\r\n\r\n        /* We emit a RepayBorrow event */\r\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\r\n\r\n        /* We call the defense hook */\r\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\r\n\r\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice The sender liquidates the borrowers collateral.\r\n     *  The collateral seized is transferred to the liquidator.\r\n     * @param borrower The borrower of this cToken to be liquidated\r\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\r\n     * @param repayAmount The amount of the underlying borrowed asset to repay\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\r\n     */\r\n    function liquidateBorrowInternal(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal nonReentrant returns (uint, uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\r\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\r\n        }\r\n\r\n        error = cTokenCollateral.accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\r\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\r\n        }\r\n\r\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\r\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\r\n    }\r\n\r\n    /**\r\n     * @notice The liquidator liquidates the borrowers collateral.\r\n     *  The collateral seized is transferred to the liquidator.\r\n     * @param borrower The borrower of this cToken to be liquidated\r\n     * @param liquidator The address repaying the borrow and seizing collateral\r\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\r\n     * @param repayAmount The amount of the underlying borrowed asset to repay\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\r\n     */\r\n    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal returns (uint, uint) {\r\n        /* Fail if liquidate not allowed */\r\n        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);\r\n        if (allowed != 0) {\r\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\r\n        }\r\n\r\n        /* Verify market's block number equals current block number */\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);\r\n        }\r\n\r\n        /* Verify cTokenCollateral market's block number equals current block number */\r\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\r\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);\r\n        }\r\n\r\n        /* Fail if borrower = liquidator */\r\n        if (borrower == liquidator) {\r\n            return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\r\n        }\r\n\r\n        /* Fail if repayAmount = 0 */\r\n        if (repayAmount == 0) {\r\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\r\n        }\r\n\r\n        /* Fail if repayAmount = -1 */\r\n        if (repayAmount == uint(-1)) {\r\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\r\n        }\r\n\r\n\r\n        /* Fail if repayBorrow fails */\r\n        (uint repayBorrowError, uint actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\r\n        if (repayBorrowError != uint(Error.NO_ERROR)) {\r\n            return (fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /* We calculate the number of collateral tokens that will be seized */\r\n        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), actualRepayAmount);\r\n        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\r\n\r\n        /* Revert if borrower collateral token balance < seizeTokens */\r\n        require(cTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\r\n\r\n        // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\r\n        uint seizeError;\r\n        if (address(cTokenCollateral) == address(this)) {\r\n            seizeError = seizeInternal(address(this), liquidator, borrower, seizeTokens);\r\n        } else {\r\n            seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);\r\n        }\r\n\r\n        /* Revert if seize tokens fails (since we cannot be sure of side effects) */\r\n        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\r\n\r\n        /* We emit a LiquidateBorrow event */\r\n        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(cTokenCollateral), seizeTokens);\r\n\r\n        /* We call the defense hook */\r\n        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, actualRepayAmount, seizeTokens);\r\n\r\n        return (uint(Error.NO_ERROR), actualRepayAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers collateral tokens (this market) to the liquidator.\r\n     * @dev Will fail unless called by another cToken during the process of liquidation.\r\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\r\n     * @param liquidator The account receiving seized collateral\r\n     * @param borrower The account having collateral seized\r\n     * @param seizeTokens The number of cTokens to seize\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function seize(address liquidator, address borrower, uint seizeTokens) override external nonReentrant returns (uint) {\r\n        return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers collateral tokens (this market) to the liquidator.\r\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\r\n     *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\r\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\r\n     * @param liquidator The account receiving seized collateral\r\n     * @param borrower The account having collateral seized\r\n     * @param seizeTokens The number of cTokens to seize\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\r\n        /* Fail if seize not allowed */\r\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        /* Fail if borrower = liquidator */\r\n        if (borrower == liquidator) {\r\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\r\n        }\r\n\r\n        MathError mathErr;\r\n        uint borrowerTokensNew;\r\n        uint liquidatorTokensNew;\r\n\r\n        /*\r\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\r\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\r\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\r\n         */\r\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\r\n        }\r\n\r\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /* We write the previously calculated values into storage */\r\n        accountTokens[borrower] = borrowerTokensNew;\r\n        accountTokens[liquidator] = liquidatorTokensNew;\r\n\r\n        /* Emit a Transfer event */\r\n        emit Transfer(borrower, liquidator, seizeTokens);\r\n\r\n        /* We call the defense hook */\r\n        comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    /**\r\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @param newPendingAdmin New pending admin.\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPendingAdmin(address payable newPendingAdmin) override external returns (uint) {\r\n        // Check caller = admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\r\n        }\r\n\r\n        // Save current value, if any, for inclusion in log\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store pendingAdmin with value newPendingAdmin\r\n        pendingAdmin = newPendingAdmin;\r\n\r\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\r\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\r\n      * @dev Admin function for pending admin to accept role and update admin\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _acceptAdmin() external override returns (uint) {\r\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\r\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\r\n        }\r\n\r\n        // Save current values for inclusion in log\r\n        address oldAdmin = admin;\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store admin with value pendingAdmin\r\n        admin = pendingAdmin;\r\n\r\n        // Clear the pending value\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(oldAdmin, admin);\r\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets a new comptroller for the market\r\n      * @dev Admin function to set a new comptroller\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setComptroller(ComptrollerInterface newComptroller) override public returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\r\n        }\r\n\r\n        ComptrollerInterface oldComptroller = comptroller;\r\n        // Ensure invoke comptroller.isComptroller() returns true\r\n        require(newComptroller.isComptroller(), \"marker method returned false\");\r\n\r\n        // Set market's comptroller to newComptroller\r\n        comptroller = newComptroller;\r\n\r\n        // Emit NewComptroller(oldComptroller, newComptroller)\r\n        emit NewComptroller(oldComptroller, newComptroller);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\r\n      * @dev Admin function to accrue interest and set a new reserve factor\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setReserveFactor(uint newReserveFactorMantissa) override external nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\r\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\r\n        return _setReserveFactorFresh(newReserveFactorMantissa);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\r\n      * @dev Admin function to set a new reserve factor\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\r\n        }\r\n\r\n        // Verify market's block number equals current block number\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\r\n        }\r\n\r\n        // Check newReserveFactor ≤ maxReserveFactor\r\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\r\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\r\n        }\r\n\r\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\r\n        reserveFactorMantissa = newReserveFactorMantissa;\r\n\r\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Accrues interest and reduces reserves by transferring from msg.sender\r\n     * @param addAmount Amount of addition to reserves\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\r\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\r\n        }\r\n\r\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\r\n        (error, ) = _addReservesFresh(addAmount);\r\n        return error;\r\n    }\r\n\r\n    /**\r\n     * @notice Add reserves by transferring from caller\r\n     * @dev Requires fresh interest accrual\r\n     * @param addAmount Amount of addition to reserves\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\r\n     */\r\n    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\r\n        // totalReserves + actualAddAmount\r\n        uint totalReservesNew;\r\n        uint actualAddAmount;\r\n\r\n        // We fail gracefully unless market's block number equals current block number\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /*\r\n         * We call doTransferIn for the caller and the addAmount\r\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\r\n         *  On success, the cToken holds an additional addAmount of cash.\r\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\r\n         *  it returns the amount actually transferred, in case of a fee.\r\n         */\r\n\r\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\r\n\r\n        totalReservesNew = totalReserves + actualAddAmount;\r\n\r\n        /* Revert on overflow */\r\n        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\r\n\r\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\r\n        totalReserves = totalReservesNew;\r\n\r\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\r\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\r\n\r\n        /* Return (NO_ERROR, actualAddAmount) */\r\n        return (uint(Error.NO_ERROR), actualAddAmount);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Accrues interest and reduces reserves by transferring to admin\r\n     * @param reduceAmount Amount of reduction to reserves\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _reduceReserves(uint reduceAmount) override external nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\r\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\r\n        return _reduceReservesFresh(reduceAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Reduces reserves by transferring to admin\r\n     * @dev Requires fresh interest accrual\r\n     * @param reduceAmount Amount of reduction to reserves\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\r\n        // totalReserves - reduceAmount\r\n        uint totalReservesNew;\r\n\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\r\n        }\r\n\r\n        // We fail gracefully unless market's block number equals current block number\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\r\n        }\r\n\r\n        // Fail gracefully if protocol has insufficient underlying cash\r\n        if (getCashPrior() < reduceAmount) {\r\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\r\n        }\r\n\r\n        // Check reduceAmount ≤ reserves[n] (totalReserves)\r\n        if (reduceAmount > totalReserves) {\r\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        totalReservesNew = totalReserves - reduceAmount;\r\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\r\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\r\n\r\n        // Store reserves[n+1] = reserves[n] - reduceAmount\r\n        totalReserves = totalReservesNew;\r\n\r\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\r\n        doTransferOut(admin, reduceAmount);\r\n\r\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\r\n     * @dev Admin function to accrue interest and update the interest rate model\r\n     * @param newInterestRateModel the new interest rate model to use\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) override public returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\r\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\r\n        return _setInterestRateModelFresh(newInterestRateModel);\r\n    }\r\n\r\n    /**\r\n     * @notice updates the interest rate model (*requires fresh interest accrual)\r\n     * @dev Admin function to update the interest rate model\r\n     * @param newInterestRateModel the new interest rate model to use\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\r\n\r\n        // Used to store old model for use in the event that is emitted on success\r\n        InterestRateModel oldInterestRateModel;\r\n\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\r\n        }\r\n\r\n        // We fail gracefully unless market's block number equals current block number\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\r\n        }\r\n\r\n        // Track the market's current interest rate model\r\n        oldInterestRateModel = interestRateModel;\r\n\r\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\r\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\r\n\r\n        // Set the interest rate model to newInterestRateModel\r\n        interestRateModel = newInterestRateModel;\r\n\r\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\r\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /*** Safe Token ***/\r\n\r\n    /**\r\n     * @notice Gets balance of this contract in terms of the underlying\r\n     * @dev This excludes the value of the current message, if any\r\n     * @return The quantity of underlying owned by this contract\r\n     */\r\n    function getCashPrior() virtual internal view returns (uint);\r\n\r\n    /**\r\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\r\n     *  This may revert due to insufficient balance or insufficient allowance.\r\n     */\r\n    function doTransferIn(address from, uint amount) virtual internal returns (uint);\r\n\r\n    /**\r\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\r\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\r\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\r\n     */\r\n    function doTransferOut(address payable to, uint amount) virtual internal;\r\n\r\n\r\n    /*** Reentrancy Guard ***/\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     */\r\n    modifier nonReentrant() {\r\n        require(_notEntered, \"re-entered\");\r\n        _notEntered = false;\r\n        _;\r\n        _notEntered = true; // get a gas-refund post-Istanbul\r\n    }\r\n}\r\n"
    },
    "contracts/common/CTokenInterfaces.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\nimport \"./ComptrollerInterface.sol\";\r\nimport \"./InterestRateModel.sol\";\r\n\r\ncontract CTokenStorage {\r\n    /**\r\n     * @dev Guard variable for re-entrancy checks\r\n     */\r\n    bool internal _notEntered;\r\n\r\n    /**\r\n     * @notice EIP-20 token name for this token\r\n     */\r\n    string public name;\r\n\r\n    /**\r\n     * @notice EIP-20 token symbol for this token\r\n     */\r\n    string public symbol;\r\n\r\n    /**\r\n     * @notice EIP-20 token decimals for this token\r\n     */\r\n    uint8 public decimals;\r\n\r\n    /*\r\n     * @notice Maximum borrow rate that can ever be applied (.0005% / block)\r\n     */\r\n\r\n    uint internal constant borrowRateMaxMantissa = 0.0005e16;\r\n\r\n    /*\r\n     * @notice Maximum fraction of interest that can be set aside for reserves\r\n     */\r\n    uint internal constant reserveFactorMaxMantissa = 1e18;\r\n\r\n    /**\r\n     * @notice Administrator for this contract\r\n     */\r\n    address payable public admin;\r\n\r\n    /**\r\n     * @notice Pending administrator for this contract\r\n     */\r\n    address payable public pendingAdmin;\r\n\r\n    /**\r\n     * @notice Contract which oversees inter-cToken operations\r\n     */\r\n    ComptrollerInterface public comptroller;\r\n\r\n    /**\r\n     * @notice Model which tells what the current interest rate should be\r\n     */\r\n    InterestRateModel public interestRateModel;\r\n\r\n    /*\r\n     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\r\n     */\r\n    uint internal initialExchangeRateMantissa;\r\n\r\n    /**\r\n     * @notice Fraction of interest currently set aside for reserves\r\n     */\r\n    uint public reserveFactorMantissa;\r\n\r\n    /**\r\n     * @notice Block number that interest was last accrued at\r\n     */\r\n    uint public accrualBlockNumber;\r\n\r\n    /**\r\n     * @notice Accumulator of the total earned interest rate since the opening of the market\r\n     */\r\n    uint public borrowIndex;\r\n\r\n    /**\r\n     * @notice Total amount of outstanding borrows of the underlying in this market\r\n     */\r\n    uint public totalBorrows;\r\n\r\n    /**\r\n     * @notice Total amount of reserves of the underlying held in this market\r\n     */\r\n    uint public totalReserves;\r\n\r\n    /**\r\n     * @notice Total number of tokens in circulation\r\n     */\r\n    uint public totalSupply;\r\n\r\n    /*\r\n     * @notice Official record of token balances for each account\r\n     */\r\n    mapping (address => uint) internal accountTokens;\r\n\r\n    /*\r\n     * @notice Approved token transfer amounts on behalf of others\r\n     */\r\n    mapping (address => mapping (address => uint)) internal transferAllowances;\r\n\r\n    /**\r\n     * @notice Container for borrow balance information\r\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\r\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\r\n     */\r\n    struct BorrowSnapshot {\r\n        uint principal;\r\n        uint interestIndex;\r\n    }\r\n\r\n    /*\r\n     * @notice Mapping of account addresses to outstanding borrow balances\r\n     */\r\n    mapping(address => BorrowSnapshot) internal accountBorrows;\r\n}\r\n\r\nabstract contract CTokenInterface is CTokenStorage {\r\n    /**\r\n     * @notice Indicator that this is a CToken contract (for inspection)\r\n     */\r\n    bool public constant isCToken = true;\r\n\r\n\r\n    /*** Market Events ***/\r\n\r\n    /**\r\n     * @notice Event emitted when interest is accrued\r\n     */\r\n    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\r\n\r\n    /**\r\n     * @notice Event emitted when tokens are minted\r\n     */\r\n    event Mint(address minter, uint mintAmount, uint mintTokens);\r\n\r\n    /**\r\n     * @notice Event emitted when tokens are redeemed\r\n     */\r\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\r\n\r\n    /**\r\n     * @notice Event emitted when underlying is borrowed\r\n     */\r\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\r\n\r\n    /**\r\n     * @notice Event emitted when a borrow is repaid\r\n     */\r\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\r\n\r\n    /**\r\n     * @notice Event emitted when a borrow is liquidated\r\n     */\r\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);\r\n\r\n\r\n    /*** Admin Events ***/\r\n\r\n    /**\r\n     * @notice Event emitted when pendingAdmin is changed\r\n     */\r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n    /**\r\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\r\n     */\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n    /**\r\n     * @notice Event emitted when comptroller is changed\r\n     */\r\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\r\n\r\n    /**\r\n     * @notice Event emitted when interestRateModel is changed\r\n     */\r\n    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\r\n\r\n    /**\r\n     * @notice Event emitted when the reserve factor is changed\r\n     */\r\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\r\n\r\n    /**\r\n     * @notice Event emitted when the reserves are added\r\n     */\r\n    event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);\r\n\r\n    /**\r\n     * @notice Event emitted when the reserves are reduced\r\n     */\r\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\r\n\r\n    /**\r\n     * @notice EIP20 Transfer event\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint amount);\r\n\r\n    /**\r\n     * @notice EIP20 Approval event\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint amount);\r\n\r\n    /**\r\n     * @notice Failure event\r\n     */\r\n    // event Failure(uint error, uint info, uint detail);\r\n\r\n\r\n    /*** User Interface ***/\r\n\r\n    function transfer(address dst, uint amount) virtual external returns (bool);\r\n    function transferFrom(address src, address dst, uint amount) virtual external returns (bool);\r\n    function approve(address spender, uint amount) virtual external returns (bool);\r\n    function allowance(address owner, address spender) virtual external view returns (uint);\r\n    function balanceOf(address owner) virtual external view returns (uint);\r\n    function balanceOfUnderlying(address owner) virtual external returns (uint);\r\n    function getAccountSnapshot(address account) virtual external view returns (uint, uint, uint, uint);\r\n    function borrowRatePerBlock() virtual external view returns (uint);\r\n    function supplyRatePerBlock() virtual external view returns (uint);\r\n    function totalBorrowsCurrent() virtual external returns (uint);\r\n    function borrowBalanceCurrent(address account) virtual external returns (uint);\r\n    function borrowBalanceStored(address account) virtual public view returns (uint);\r\n    function exchangeRateCurrent() virtual public returns (uint);\r\n    function exchangeRateStored() virtual public view returns (uint);\r\n    function getCash() virtual external view returns (uint);\r\n    function accrueInterest() virtual public returns (uint);\r\n    function seize(address liquidator, address borrower, uint seizeTokens) virtual external returns (uint);\r\n\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    function _setPendingAdmin(address payable newPendingAdmin) virtual external returns (uint);\r\n    function _acceptAdmin() virtual external returns (uint);\r\n    function _setComptroller(ComptrollerInterface newComptroller) virtual public returns (uint);\r\n    function _setReserveFactor(uint newReserveFactorMantissa) virtual external returns (uint);\r\n    function _reduceReserves(uint reduceAmount) virtual external returns (uint);\r\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) virtual public returns (uint);\r\n}\r\n\r\ncontract CErc20Storage {\r\n    /**\r\n     * @notice Underlying asset for this CToken\r\n     */\r\n    address public underlying;\r\n}\r\n\r\nabstract contract CErc20Interface is CErc20Storage {\r\n\r\n    /*** User Interface ***/\r\n\r\n    function mint(uint mintAmount) virtual external returns (uint);\r\n    function redeem(uint redeemTokens) virtual external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) virtual external returns (uint);\r\n    function borrow(uint borrowAmount) virtual external returns (uint);\r\n    function repayBorrow(uint repayAmount) virtual external returns (uint);\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) virtual external returns (uint);\r\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) virtual external returns (uint);\r\n\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    function _addReserves(uint addAmount) virtual external returns (uint);\r\n}\r\n\r\ncontract CDelegationStorage {\r\n    /**\r\n     * @notice Implementation address for this contract\r\n     */\r\n    address public implementation;\r\n}\r\n\r\nabstract contract CDelegatorInterface is CDelegationStorage {\r\n    /**\r\n     * @notice Emitted when implementation is changed\r\n     */\r\n    event NewImplementation(address oldImplementation, address newImplementation);\r\n\r\n    /**\r\n     * @notice Called by the admin to update the implementation of the delegator\r\n     * @param implementation_ The address of the new implementation for delegation\r\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\r\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\r\n     */\r\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) virtual public;\r\n}\r\n\r\nabstract contract CDelegateInterface is CDelegationStorage {\r\n    /**\r\n     * @notice Called by the delegator on a delegate to initialize it for duty\r\n     * @dev Should revert if any issues arise which make it unfit for delegation\r\n     * @param data The encoded bytes data for any initialization\r\n     */\r\n    function _becomeImplementation(bytes memory data) virtual public;\r\n\r\n    /**\r\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\r\n     */\r\n    function _resignImplementation() virtual public;\r\n}\r\n"
    },
    "contracts/common/InterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\n/**\r\n  * @title LendHub's InterestRateModel Interface\r\n  * @author LendHub\r\n  */\r\nabstract contract InterestRateModel {\r\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\r\n    bool public constant isInterestRateModel = true;\r\n\r\n    /**\r\n      * @notice Calculates the current borrow interest rate per block\r\n      * @param cash The total amount of cash the market has\r\n      * @param borrows The total amount of borrows the market has outstanding\r\n      * @param reserves The total amount of reserves the market has\r\n      * @return The borrow rate per block (as a percentage, and scaled by 1e18)\r\n      */\r\n    function getBorrowRate(uint cash, uint borrows, uint reserves) virtual external view returns (uint);\r\n\r\n    /**\r\n      * @notice Calculates the current supply interest rate per block\r\n      * @param cash The total amount of cash the market has\r\n      * @param borrows The total amount of borrows the market has outstanding\r\n      * @param reserves The total amount of reserves the market has\r\n      * @param reserveFactorMantissa The current reserve factor the market has\r\n      * @return The supply rate per block (as a percentage, and scaled by 1e18)\r\n      */\r\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) virtual external view returns (uint);\r\n\r\n}\r\n"
    },
    "contracts/compound/ErrorReporter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\ncontract ComptrollerErrorReporter {\r\n    enum Error {\r\n        NO_ERROR,\r\n        UNAUTHORIZED,\r\n        COMPTROLLER_MISMATCH,\r\n        INSUFFICIENT_SHORTFALL,\r\n        INSUFFICIENT_LIQUIDITY,\r\n        INVALID_CLOSE_FACTOR,\r\n        INVALID_COLLATERAL_FACTOR,\r\n        INVALID_LIQUIDATION_INCENTIVE,\r\n        MARKET_NOT_ENTERED, // no longer possible\r\n        MARKET_NOT_LISTED,\r\n        MARKET_ALREADY_LISTED,\r\n        MATH_ERROR,\r\n        NONZERO_BORROW_BALANCE,\r\n        PRICE_ERROR,\r\n        REJECTION,\r\n        SNAPSHOT_ERROR,\r\n        TOO_MANY_ASSETS,\r\n        TOO_MUCH_REPAY\r\n    }\r\n\r\n    enum FailureInfo {\r\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\r\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\r\n        EXIT_MARKET_BALANCE_OWED,\r\n        EXIT_MARKET_REJECTION,\r\n        SET_CLOSE_FACTOR_OWNER_CHECK,\r\n        SET_CLOSE_FACTOR_VALIDATION,\r\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\r\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\r\n        SET_COLLATERAL_FACTOR_VALIDATION,\r\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\r\n        SET_IMPLEMENTATION_OWNER_CHECK,\r\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\r\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\r\n        SET_MAX_ASSETS_OWNER_CHECK,\r\n        SET_PENDING_ADMIN_OWNER_CHECK,\r\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\r\n        SET_PRICE_ORACLE_OWNER_CHECK,\r\n        SUPPORT_MARKET_EXISTS,\r\n        SUPPORT_MARKET_OWNER_CHECK,\r\n        SET_PAUSE_GUARDIAN_OWNER_CHECK\r\n    }\r\n\r\n    /**\r\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\r\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\r\n      **/\r\n    event Failure(uint error, uint info, uint detail);\r\n\r\n    /**\r\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\r\n      */\r\n    function fail(Error err, FailureInfo info) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), 0);\r\n\r\n        return uint(err);\r\n    }\r\n\r\n    /**\r\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\r\n      */\r\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), opaqueError);\r\n\r\n        return uint(err);\r\n    }\r\n}\r\n\r\ncontract TokenErrorReporter {\r\n    enum Error {\r\n        NO_ERROR,\r\n        UNAUTHORIZED,\r\n        BAD_INPUT,\r\n        COMPTROLLER_REJECTION,\r\n        COMPTROLLER_CALCULATION_ERROR,\r\n        INTEREST_RATE_MODEL_ERROR,\r\n        INVALID_ACCOUNT_PAIR,\r\n        INVALID_CLOSE_AMOUNT_REQUESTED,\r\n        INVALID_COLLATERAL_FACTOR,\r\n        MATH_ERROR,\r\n        MARKET_NOT_FRESH,\r\n        MARKET_NOT_LISTED,\r\n        TOKEN_INSUFFICIENT_ALLOWANCE,\r\n        TOKEN_INSUFFICIENT_BALANCE,\r\n        TOKEN_INSUFFICIENT_CASH,\r\n        TOKEN_TRANSFER_IN_FAILED,\r\n        TOKEN_TRANSFER_OUT_FAILED\r\n    }\r\n\r\n    /*\r\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\r\n     *       This is because FailureInfo grows significantly faster, and\r\n     *       the order of Error has some meaning, while the order of FailureInfo\r\n     *       is entirely arbitrary.\r\n     */\r\n    enum FailureInfo {\r\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\r\n        ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\r\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        BORROW_ACCRUE_INTEREST_FAILED,\r\n        BORROW_CASH_NOT_AVAILABLE,\r\n        BORROW_FRESHNESS_CHECK,\r\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\r\n        BORROW_MARKET_NOT_LISTED,\r\n        BORROW_COMPTROLLER_REJECTION,\r\n        LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\r\n        LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\r\n        LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\r\n        LIQUIDATE_COMPTROLLER_REJECTION,\r\n        LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\r\n        LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\r\n        LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\r\n        LIQUIDATE_FRESHNESS_CHECK,\r\n        LIQUIDATE_LIQUIDATOR_IS_BORROWER,\r\n        LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\r\n        LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\r\n        LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\r\n        LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\r\n        LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\r\n        LIQUIDATE_SEIZE_TOO_MUCH,\r\n        MINT_ACCRUE_INTEREST_FAILED,\r\n        MINT_COMPTROLLER_REJECTION,\r\n        MINT_EXCHANGE_CALCULATION_FAILED,\r\n        MINT_EXCHANGE_RATE_READ_FAILED,\r\n        MINT_FRESHNESS_CHECK,\r\n        MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\r\n        MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\r\n        MINT_TRANSFER_IN_FAILED,\r\n        MINT_TRANSFER_IN_NOT_POSSIBLE,\r\n        REDEEM_ACCRUE_INTEREST_FAILED,\r\n        REDEEM_COMPTROLLER_REJECTION,\r\n        REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\r\n        REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\r\n        REDEEM_EXCHANGE_RATE_READ_FAILED,\r\n        REDEEM_FRESHNESS_CHECK,\r\n        REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\r\n        REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\r\n        REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\r\n        REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\r\n        REDUCE_RESERVES_ADMIN_CHECK,\r\n        REDUCE_RESERVES_CASH_NOT_AVAILABLE,\r\n        REDUCE_RESERVES_FRESH_CHECK,\r\n        REDUCE_RESERVES_VALIDATION,\r\n        REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\r\n        REPAY_BORROW_ACCRUE_INTEREST_FAILED,\r\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_COMPTROLLER_REJECTION,\r\n        REPAY_BORROW_FRESHNESS_CHECK,\r\n        REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\r\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\r\n        SET_COLLATERAL_FACTOR_VALIDATION,\r\n        SET_COMPTROLLER_OWNER_CHECK,\r\n        SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\r\n        SET_INTEREST_RATE_MODEL_FRESH_CHECK,\r\n        SET_INTEREST_RATE_MODEL_OWNER_CHECK,\r\n        SET_MAX_ASSETS_OWNER_CHECK,\r\n        SET_ORACLE_MARKET_NOT_LISTED,\r\n        SET_PENDING_ADMIN_OWNER_CHECK,\r\n        SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\r\n        SET_RESERVE_FACTOR_ADMIN_CHECK,\r\n        SET_RESERVE_FACTOR_FRESH_CHECK,\r\n        SET_RESERVE_FACTOR_BOUNDS_CHECK,\r\n        TRANSFER_COMPTROLLER_REJECTION,\r\n        TRANSFER_NOT_ALLOWED,\r\n        TRANSFER_NOT_ENOUGH,\r\n        TRANSFER_TOO_MUCH,\r\n        ADD_RESERVES_ACCRUE_INTEREST_FAILED,\r\n        ADD_RESERVES_FRESH_CHECK,\r\n        ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE\r\n    }\r\n\r\n    /**\r\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\r\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\r\n      **/\r\n    event Failure(uint error, uint info, uint detail);\r\n\r\n    /**\r\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\r\n      */\r\n    function fail(Error err, FailureInfo info) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), 0);\r\n\r\n        return uint(err);\r\n    }\r\n\r\n    /**\r\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\r\n      */\r\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), opaqueError);\r\n\r\n        return uint(err);\r\n    }\r\n}"
    },
    "contracts/compound/Exponential.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\nimport \"./CarefulMath.sol\";\r\nimport \"./ExponentialNoError.sol\";\r\n\r\n/**\r\n * @title Exponential module for storing fixed-precision decimals\r\n * @author LendHub\r\n * @dev Legacy contract for compatibility reasons with existing contracts that still use MathError\r\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\r\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\r\n *         `Exp({mantissa: 5100000000000000000})`.\r\n */\r\ncontract Exponential is CarefulMath, ExponentialNoError {\r\n    /**\r\n     * @dev Creates an exponential from numerator and denominator values.\r\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\r\n     *            or if `denom` is zero.\r\n     */\r\n    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\r\n        if (err1 != MathError.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two exponentials, returning a new exponential.\r\n     */\r\n    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two exponentials, returning a new exponential.\r\n     */\r\n    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\r\n     */\r\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\r\n     */\r\n    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, truncate(product));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\r\n     */\r\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return addUInt(truncate(product), addend);\r\n    }\r\n\r\n    /**\r\n     * @dev Divide an Exp by a scalar, returning a new Exp.\r\n     */\r\n    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\r\n    }\r\n\r\n    /**\r\n     * @dev Divide a scalar by an Exp, returning a new Exp.\r\n     */\r\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\r\n        /*\r\n          We are doing this as:\r\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\r\n\r\n          How it works:\r\n          Exp = a / b;\r\n          Scalar = s;\r\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\r\n        */\r\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n        return getExp(numerator, divisor.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\r\n     */\r\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, truncate(fraction));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two exponentials, returning a new exponential.\r\n     */\r\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n\r\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        // We add half the scale before dividing so that we get rounding instead of truncation.\r\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\r\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\r\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\r\n        if (err1 != MathError.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\r\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\r\n        assert(err2 == MathError.NO_ERROR);\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\r\n     */\r\n    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\r\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies three exponentials, returning a new exponential.\r\n     */\r\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\r\n        (MathError err, Exp memory ab) = mulExp(a, b);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, ab);\r\n        }\r\n        return mulExp(ab, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two exponentials, returning a new exponential.\r\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\r\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\r\n     */\r\n    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        return getExp(a.mantissa, b.mantissa);\r\n    }\r\n}\r\n"
    },
    "contracts/compound/EIP20Interface.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\n/**\r\n * @title ERC 20 Token Standard Interface\r\n *  https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface EIP20Interface {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n      * @notice Get the total number of tokens in circulation\r\n      * @return The supply of tokens\r\n      */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Gets the balance of the specified address\r\n     * @param owner The address from which the balance will be retrieved\r\n     * @return balance The balance\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n      * @param dst The address of the destination account\r\n      * @param amount The number of tokens to transfer\r\n      * @return success Whether or not the transfer succeeded\r\n      */\r\n    function transfer(address dst, uint256 amount) external returns (bool success);\r\n\r\n    /**\r\n      * @notice Transfer `amount` tokens from `src` to `dst`\r\n      * @param src The address of the source account\r\n      * @param dst The address of the destination account\r\n      * @param amount The number of tokens to transfer\r\n      * @return success Whether or not the transfer succeeded\r\n      */\r\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\r\n\r\n    /**\r\n      * @notice Approve `spender` to transfer up to `amount` from `src`\r\n      * @dev This will overwrite the approval amount for `spender`\r\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\r\n      * @param spender The address of the account which may transfer tokens\r\n      * @param amount The number of tokens that are approved (-1 means infinite)\r\n      * @return success Whether or not the approval succeeded\r\n      */\r\n    function approve(address spender, uint256 amount) external returns (bool success);\r\n\r\n    /**\r\n      * @notice Get the current allowance from `owner` for `spender`\r\n      * @param owner The address of the account which owns the tokens to be spent\r\n      * @param spender The address of the account which may transfer tokens\r\n      * @return remaining The number of tokens allowed to be spent (-1 means infinite)\r\n      */\r\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n}\r\n"
    },
    "contracts/compound/EIP20NonStandardInterface.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\n/**\r\n * @title EIP20NonStandardInterface\r\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\r\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n */\r\ninterface EIP20NonStandardInterface {\r\n\r\n    /**\r\n     * @notice Get the total number of tokens in circulation\r\n     * @return The supply of tokens\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Gets the balance of the specified address\r\n     * @param owner The address from which the balance will be retrieved\r\n     * @return balance The balance\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    ///\r\n    /// !!!!!!!!!!!!!!\r\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\r\n    /// !!!!!!!!!!!!!!\r\n    ///\r\n\r\n    /**\r\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n      * @param dst The address of the destination account\r\n      * @param amount The number of tokens to transfer\r\n      */\r\n    function transfer(address dst, uint256 amount) external;\r\n\r\n    ///\r\n    /// !!!!!!!!!!!!!!\r\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\r\n    /// !!!!!!!!!!!!!!\r\n    ///\r\n\r\n    /**\r\n      * @notice Transfer `amount` tokens from `src` to `dst`\r\n      * @param src The address of the source account\r\n      * @param dst The address of the destination account\r\n      * @param amount The number of tokens to transfer\r\n      */\r\n    function transferFrom(address src, address dst, uint256 amount) external;\r\n\r\n    /**\r\n      * @notice Approve `spender` to transfer up to `amount` from `src`\r\n      * @dev This will overwrite the approval amount for `spender`\r\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\r\n      * @param spender The address of the account which may transfer tokens\r\n      * @param amount The number of tokens that are approved\r\n      * @return success Whether or not the approval succeeded\r\n      */\r\n    function approve(address spender, uint256 amount) external returns (bool success);\r\n\r\n    /**\r\n      * @notice Get the current allowance from `owner` for `spender`\r\n      * @param owner The address of the account which owns the tokens to be spent\r\n      * @param spender The address of the account which may transfer tokens\r\n      * @return remaining The number of tokens allowed to be spent\r\n      */\r\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n}\r\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/compound/CarefulMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\n/**\r\n  * @title Careful Math\r\n  * @author LendHub\r\n  * @notice Derived from OpenZeppelin's SafeMath library\r\n  *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n  */\r\ncontract CarefulMath {\r\n\r\n    /**\r\n     * @dev Possible error codes that we can return\r\n     */\r\n    enum MathError {\r\n        NO_ERROR,\r\n        DIVISION_BY_ZERO,\r\n        INTEGER_OVERFLOW,\r\n        INTEGER_UNDERFLOW\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, returns an error on overflow.\r\n    */\r\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (a == 0) {\r\n            return (MathError.NO_ERROR, 0);\r\n        }\r\n\r\n        uint c = a * b;\r\n\r\n        if (c / a != b) {\r\n            return (MathError.INTEGER_OVERFLOW, 0);\r\n        } else {\r\n            return (MathError.NO_ERROR, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (b == 0) {\r\n            return (MathError.DIVISION_BY_ZERO, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, a / b);\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (b <= a) {\r\n            return (MathError.NO_ERROR, a - b);\r\n        } else {\r\n            return (MathError.INTEGER_UNDERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, returns an error on overflow.\r\n    */\r\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        uint c = a + b;\r\n\r\n        if (c >= a) {\r\n            return (MathError.NO_ERROR, c);\r\n        } else {\r\n            return (MathError.INTEGER_OVERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev add a and b and then subtract c\r\n    */\r\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\r\n        (MathError err0, uint sum) = addUInt(a, b);\r\n\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, 0);\r\n        }\r\n\r\n        return subUInt(sum, c);\r\n    }\r\n}"
    },
    "contracts/compound/ExponentialNoError.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\n/**\r\n * @title Exponential module for storing fixed-precision decimals\r\n * @author LendHub\r\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\r\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\r\n *         `Exp({mantissa: 5100000000000000000})`.\r\n */\r\ncontract ExponentialNoError {\r\n    uint constant expScale = 1e18;\r\n    uint constant doubleScale = 1e36;\r\n    uint constant halfExpScale = expScale/2;\r\n    uint constant mantissaOne = expScale;\r\n\r\n    struct Exp {\r\n        uint mantissa;\r\n    }\r\n\r\n    struct Double {\r\n        uint mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Truncates the given exp to a whole number value.\r\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\r\n     */\r\n    function truncate(Exp memory exp) pure internal returns (uint) {\r\n        // Note: We are not using careful math here as we're performing a division that cannot fail\r\n        return exp.mantissa / expScale;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\r\n     */\r\n    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\r\n        Exp memory product = mul_(a, scalar);\r\n        return truncate(product);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\r\n     */\r\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\r\n        Exp memory product = mul_(a, scalar);\r\n        return add_(truncate(product), addend);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if first Exp is less than second Exp.\r\n     */\r\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa < right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if left Exp <= right Exp.\r\n     */\r\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa <= right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if left Exp > right Exp.\r\n     */\r\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa > right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev returns true if Exp is exactly zero\r\n     */\r\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\r\n        return value.mantissa == 0;\r\n    }\r\n\r\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\r\n        require(n < 2**224, errorMessage);\r\n        return uint224(n);\r\n    }\r\n\r\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\r\n        require(n < 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function add_(uint a, uint b) pure internal returns (uint) {\r\n        return add_(a, b, \"addition overflow\");\r\n    }\r\n\r\n    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function sub_(uint a, uint b) pure internal returns (uint) {\r\n        return sub_(a, b, \"subtraction underflow\");\r\n    }\r\n\r\n    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\r\n    }\r\n\r\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: mul_(a.mantissa, b)});\r\n    }\r\n\r\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\r\n        return mul_(a, b.mantissa) / expScale;\r\n    }\r\n\r\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\r\n    }\r\n\r\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: mul_(a.mantissa, b)});\r\n    }\r\n\r\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\r\n        return mul_(a, b.mantissa) / doubleScale;\r\n    }\r\n\r\n    function mul_(uint a, uint b) pure internal returns (uint) {\r\n        return mul_(a, b, \"multiplication overflow\");\r\n    }\r\n\r\n    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        if (a == 0 || b == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        require(c / a == b, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\r\n    }\r\n\r\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: div_(a.mantissa, b)});\r\n    }\r\n\r\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\r\n        return div_(mul_(a, expScale), b.mantissa);\r\n    }\r\n\r\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\r\n    }\r\n\r\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(a.mantissa, b)});\r\n    }\r\n\r\n    function div_(uint a, Double memory b) pure internal returns (uint) {\r\n        return div_(mul_(a, doubleScale), b.mantissa);\r\n    }\r\n\r\n    function div_(uint a, uint b) pure internal returns (uint) {\r\n        return div_(a, b, \"divide by zero\");\r\n    }\r\n\r\n    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\r\n    }\r\n}\r\n"
    },
    "contracts/compound/LHT.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\nimport \"./CToken.sol\";\r\n\r\n/**\r\n * @title LendHub's LHT Contract\r\n * @notice CToken which wraps HT\r\n * @author LendHub\r\n */\r\ncontract LHT is CToken {\r\n    /**\r\n     * @notice Construct a new CEther money market\r\n     * @param comptroller_ The address of the Comptroller\r\n     * @param interestRateModel_ The address of the interest rate model\r\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\r\n     * @param name_ ERC-20 name of this token\r\n     * @param symbol_ ERC-20 symbol of this token\r\n     * @param decimals_ ERC-20 decimal precision of this token\r\n     * @param admin_ Address of the administrator of this token\r\n     */\r\n    constructor(ComptrollerInterface comptroller_,\r\n                InterestRateModel interestRateModel_,\r\n                uint initialExchangeRateMantissa_,\r\n                string memory name_,\r\n                string memory symbol_,\r\n                uint8 decimals_,\r\n                address payable admin_) {\r\n        // Creator of the contract is admin during initialization\r\n        admin = msg.sender;\r\n\r\n        initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\r\n\r\n        // Set the proper admin now that initialization is done\r\n        admin = admin_;\r\n    }\r\n\r\n\r\n    /*** User Interface ***/\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\r\n     * @dev Reverts upon any failure\r\n     */\r\n    function mint() external payable {\r\n        (uint err,) = mintInternal(msg.value);\r\n        requireNoError(err, \"mint failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems cTokens in exchange for the underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemTokens The number of cTokens to redeem into underlying\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeem(uint redeemTokens) external returns (uint) {\r\n        return redeemInternal(redeemTokens);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemAmount The amount of underlying to redeem\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\r\n        return redeemUnderlyingInternal(redeemAmount);\r\n    }\r\n\r\n    /**\r\n      * @notice Sender borrows assets from the protocol to their own address\r\n      * @param borrowAmount The amount of the underlying asset to borrow\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function borrow(uint borrowAmount) external returns (uint) {\r\n        return borrowInternal(borrowAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender repays their own borrow\r\n     * @dev Reverts upon any failure\r\n     */\r\n    function repayBorrow() external payable {\r\n        (uint err,) = repayBorrowInternal(msg.value);\r\n        requireNoError(err, \"repayBorrow failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice Sender repays a borrow belonging to borrower\r\n     * @dev Reverts upon any failure\r\n     * @param borrower the account with the debt being payed off\r\n     */\r\n    function repayBorrowBehalf(address borrower) external payable {\r\n        (uint err,) = repayBorrowBehalfInternal(borrower, msg.value);\r\n        requireNoError(err, \"repayBorrowBehalf failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice The sender liquidates the borrowers collateral.\r\n     *  The collateral seized is transferred to the liquidator.\r\n     * @dev Reverts upon any failure\r\n     * @param borrower The borrower of this cToken to be liquidated\r\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\r\n     */\r\n    function liquidateBorrow(address borrower, CToken cTokenCollateral) external payable {\r\n        (uint err,) = liquidateBorrowInternal(borrower, msg.value, cTokenCollateral);\r\n        requireNoError(err, \"liquidateBorrow failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice Send Ether to CEther to mint\r\n     */\r\n    // function () external payable {\r\n    fallback() external payable {\r\n        (uint err,) = mintInternal(msg.value);\r\n        requireNoError(err, \"mint failed\");\r\n    }\r\n\r\n    receive() external payable {\r\n        (uint err,) = mintInternal(msg.value);\r\n        requireNoError(err, \"mint failed\");\r\n    }\r\n    /*** Safe Token ***/\r\n\r\n    /**\r\n     * @notice Gets balance of this contract in terms of Ether, before this message\r\n     * @dev This excludes the value of the current message, if any\r\n     * @return The quantity of Ether owned by this contract\r\n     */\r\n    function getCashPrior() override internal view returns (uint) {\r\n        (MathError err, uint startingBalance) = subUInt(address(this).balance, msg.value);\r\n        require(err == MathError.NO_ERROR);\r\n        return startingBalance;\r\n    }\r\n\r\n    /**\r\n     * @notice Perform the actual transfer in, which is a no-op\r\n     * @param from Address sending the Ether\r\n     * @param amount Amount of Ether being sent\r\n     * @return The actual amount of Ether transferred\r\n     */\r\n    function doTransferIn(address from, uint amount) override internal returns (uint) {\r\n        // Sanity checks\r\n        require(msg.sender == from, \"sender mismatch\");\r\n        require(msg.value == amount, \"value mismatch\");\r\n        return amount;\r\n    }\r\n\r\n    function doTransferOut(address payable to, uint amount) override internal {\r\n        /* Send the Ether, with minimal gas and revert on failure */\r\n        to.transfer(amount);\r\n    }\r\n\r\n    function requireNoError(uint errCode, string memory message) internal pure {\r\n        if (errCode == uint(Error.NO_ERROR)) {\r\n            return;\r\n        }\r\n\r\n        bytes memory fullMessage = new bytes(bytes(message).length + 5);\r\n        uint i;\r\n\r\n        for (i = 0; i < bytes(message).length; i++) {\r\n            fullMessage[i] = bytes(message)[i];\r\n        }\r\n\r\n        fullMessage[i+0] = byte(uint8(32));\r\n        fullMessage[i+1] = byte(uint8(40));\r\n        fullMessage[i+2] = byte(uint8(48 + ( errCode / 10 )));\r\n        fullMessage[i+3] = byte(uint8(48 + ( errCode % 10 )));\r\n        fullMessage[i+4] = byte(uint8(41));\r\n\r\n        require(errCode == uint(Error.NO_ERROR), string(fullMessage));\r\n    }\r\n}\r\n"
    },
    "contracts/compound/lens/LendHubLensLHB.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n// pragma experimental ABIEncoderV2;\r\npragma abicoder v2;\r\n\r\nimport \"../LErc20.sol\";\r\nimport \"../CToken.sol\";\r\nimport \"../PriceOracle.sol\";\r\nimport \"../EIP20Interface.sol\";\r\nimport \"../Governance/LendHub.sol\";\r\nimport \"../SimplePriceOracle.sol\";\r\n\r\ninterface ComptrollerLensInterface {\r\n\r\n    function compSpeeds(address) external view returns (uint);\r\n    function compSupplyState(address) external view returns(uint224, uint32);\r\n    function compBorrowState(address) external view returns(uint224, uint32);\r\n    function compSupplierIndex(address, address) external view returns (uint);\r\n    function compBorrowerIndex(address, address) external view returns (uint);\r\n\r\n    function markets(address) external view returns (bool, uint);\r\n    function oracle() external view returns (PriceOracle);\r\n    function getAccountLiquidity(address) external view returns (uint, uint, uint);\r\n    function getAssetsIn(address) external view returns (CToken[] memory);\r\n    function claimComp(address) external;\r\n    function compAccrued(address) external view returns (uint);\r\n    function getCompAddress() external view returns (address);\r\n}\r\n\r\ncontract LendHubLensLHB is ExponentialNoError {\r\n    struct CTokenLHBData {\r\n        address cToken;\r\n        uint supplyLHBAPY;\r\n        uint borrowLHBAPY;\r\n    }\r\n\r\n    function cTokenLHBMetadata(CToken cToken) view public returns (CTokenLHBData memory) {\r\n        ComptrollerLensInterface comptroller = ComptrollerLensInterface(address(cToken.comptroller()));\r\n        uint speed = comptroller.compSpeeds(address(cToken));\r\n        SimplePriceOracle priceOracle = SimplePriceOracle(address(comptroller.oracle()));\r\n        uint lhbPrice = priceOracle.assetPrices(comptroller.getCompAddress());\r\n        // 24位小数\r\n        uint exchangeRateCurrent = cToken.exchangeRateStored();\r\n        uint totalPrice = cToken.totalSupply() * exchangeRateCurrent * priceOracle.getUnderlyingPrice(cToken);\r\n        uint supplyAPY = 1000000000000000000 * 1000000 * 10512000 * speed * lhbPrice / totalPrice;\r\n        uint totalBorrowPrice = cToken.totalBorrows() * priceOracle.getUnderlyingPrice(cToken);\r\n        uint borrowLHBAPY = 1000000 * 10512000 * speed * lhbPrice / totalBorrowPrice;\r\n\r\n        return CTokenLHBData({\r\n            cToken: address(cToken),\r\n            supplyLHBAPY: supplyAPY,\r\n            borrowLHBAPY: borrowLHBAPY\r\n            });\r\n    }\r\n\r\n    function calcLHBAPYs(CToken[] memory cTokens) public view returns (CTokenLHBData[] memory)  {\r\n        uint cTokenCount = cTokens.length;\r\n        CTokenLHBData[] memory res = new CTokenLHBData[](cTokenCount);\r\n\r\n        for (uint i = 0; i < cTokenCount; i++) {\r\n            CToken cToken = cTokens[i];\r\n            res[i] = cTokenLHBMetadata(cToken);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n"
    },
    "contracts/compound/LErc20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\nimport \"./CToken.sol\";\r\n\r\n/**\r\n * @title LendHub's LErc20 Contract\r\n * @notice CTokens which wrap an EIP-20 underlying\r\n * @author LendHub\r\n */\r\ncontract LErc20 is CToken, CErc20Interface {\r\n    /**\r\n     * @notice Initialize the new money market\r\n     * @param underlying_ The address of the underlying asset\r\n     * @param comptroller_ The address of the Comptroller\r\n     * @param interestRateModel_ The address of the interest rate model\r\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\r\n     * @param name_ ERC-20 name of this token\r\n     * @param symbol_ ERC-20 symbol of this token\r\n     * @param decimals_ ERC-20 decimal precision of this token\r\n     */\r\n    function initialize(address underlying_,\r\n                        ComptrollerInterface comptroller_,\r\n                        InterestRateModel interestRateModel_,\r\n                        uint initialExchangeRateMantissa_,\r\n                        string memory name_,\r\n                        string memory symbol_,\r\n                        uint8 decimals_) public {\r\n        // CToken initialize does the bulk of the work\r\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\r\n        // Set underlying and sanity check it\r\n        underlying = underlying_;\r\n        EIP20Interface(underlying).totalSupply();\r\n    }\r\n\r\n    /*** User Interface ***/\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function mint(uint mintAmount) override external returns (uint) {\r\n        (uint err,) = mintInternal(mintAmount);\r\n        return err;\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems cTokens in exchange for the underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemTokens The number of cTokens to redeem into underlying\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeem(uint redeemTokens) override external returns (uint) {\r\n        return redeemInternal(redeemTokens);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemAmount The amount of underlying to redeem\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeemUnderlying(uint redeemAmount) override external returns (uint) {\r\n        return redeemUnderlyingInternal(redeemAmount);\r\n    }\r\n\r\n    /**\r\n      * @notice Sender borrows assets from the protocol to their own address\r\n      * @param borrowAmount The amount of the underlying asset to borrow\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function borrow(uint borrowAmount) override external returns (uint) {\r\n        return borrowInternal(borrowAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender repays their own borrow\r\n     * @param repayAmount The amount to repay\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function repayBorrow(uint repayAmount) override external returns (uint) {\r\n        (uint err,) = repayBorrowInternal(repayAmount);\r\n        return err;\r\n    }\r\n\r\n    /**\r\n     * @notice Sender repays a borrow belonging to borrower\r\n     * @param borrower the account with the debt being payed off\r\n     * @param repayAmount The amount to repay\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) override external returns (uint) {\r\n        (uint err,) = repayBorrowBehalfInternal(borrower, repayAmount);\r\n        return err;\r\n    }\r\n\r\n    /**\r\n     * @notice The sender liquidates the borrowers collateral.\r\n     *  The collateral seized is transferred to the liquidator.\r\n     * @param borrower The borrower of this cToken to be liquidated\r\n     * @param repayAmount The amount of the underlying borrowed asset to repay\r\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function liquidateBorrow(address borrower,\r\n                        uint repayAmount,\r\n                        CTokenInterface cTokenCollateral) override external returns (uint) {\r\n        (uint err,) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\r\n        return err;\r\n    }\r\n\r\n    /**\r\n     * @notice The sender adds to reserves.\r\n     * @param addAmount The amount fo underlying token to add as reserves\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _addReserves(uint addAmount) override external returns (uint) {\r\n        return _addReservesInternal(addAmount);\r\n    }\r\n\r\n    /*** Safe Token ***/\r\n\r\n    /**\r\n     * @notice Gets balance of this contract in terms of the underlying\r\n     * @dev This excludes the value of the current message, if any\r\n     * @return The quantity of underlying tokens owned by this contract\r\n     */\r\n    function getCashPrior() override internal view returns (uint) {\r\n        EIP20Interface token = EIP20Interface(underlying);\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\r\n     *      This will revert due to insufficient balance or insufficient allowance.\r\n     *      This function returns the actual amount received,\r\n     *      which may be less than `amount` if there is a fee attached to the transfer.\r\n     *\r\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\r\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n     */\r\n    function doTransferIn(address from, uint amount) override internal returns (uint) {\r\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\r\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\r\n        token.transferFrom(from, address(this), amount);\r\n\r\n        bool success;\r\n        assembly {\r\n            switch returndatasize()\r\n                case 0 {                       // This is a non-standard ERC-20\r\n                    success := not(0)          // set success to true\r\n                }\r\n                case 32 {                      // This is a compliant ERC-20\r\n                    returndatacopy(0, 0, 32)\r\n                    success := mload(0)        // Set `success = returndata` of external call\r\n                }\r\n                default {                      // This is an excessively non-compliant ERC-20, revert.\r\n                    revert(0, 0)\r\n                }\r\n        }\r\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\r\n\r\n        // Calculate the amount that was *actually* transferred\r\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\r\n        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\r\n        return balanceAfter - balanceBefore;   // underflow already checked above, just subtract\r\n    }\r\n\r\n    /**\r\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\r\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\r\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\r\n     *      it is >= amount, this should not revert in normal conditions.\r\n     *\r\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\r\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n     */\r\n    function doTransferOut(address payable to, uint amount) override internal {\r\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\r\n        token.transfer(to, amount);\r\n\r\n        bool success;\r\n        assembly {\r\n            switch returndatasize()\r\n                case 0 {                      // This is a non-standard ERC-20\r\n                    success := not(0)          // set success to true\r\n                }\r\n                case 32 {                     // This is a complaint ERC-20\r\n                    returndatacopy(0, 0, 32)\r\n                    success := mload(0)        // Set `success = returndata` of external call\r\n                }\r\n                default {                     // This is an excessively non-compliant ERC-20, revert.\r\n                    revert(0, 0)\r\n                }\r\n        }\r\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\r\n    }\r\n}\r\n"
    },
    "contracts/compound/PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\nimport \"./CToken.sol\";\r\n\r\nabstract contract PriceOracle {\r\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\r\n    bool public constant isPriceOracle = true;\r\n\r\n    /**\r\n      * @notice Get the underlying price of a cToken asset\r\n      * @param cToken The cToken to get the underlying price of\r\n      * @return The underlying asset price mantissa (scaled by 1e18).\r\n      *  Zero means the price is unavailable.\r\n      */\r\n    function getUnderlyingPrice(CToken cToken) virtual external view returns (uint);\r\n}\r\n"
    },
    "contracts/compound/Governance/LendHub.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n// pragma experimental ABIEncoderV2;\r\npragma abicoder v2;\r\n\r\ncontract LendHub {\r\n    /// @notice EIP-20 token name for this token\r\n    string public constant name = \"LendHub\";\r\n\r\n    /// @notice EIP-20 token symbol for this token\r\n    string public constant symbol = \"LHB\";\r\n\r\n    /// @notice EIP-20 token decimals for this token\r\n    uint8 public constant decimals = 18;\r\n\r\n    /// @notice Total number of tokens in circulation\r\n    uint public constant totalSupply = 1000000000e18; // 1 billion LHB\r\n\r\n    // @notice Allowance amounts on behalf of others\r\n    mapping (address => mapping (address => uint96)) internal allowances;\r\n\r\n    // @notice Official record of token balances for each account\r\n    mapping (address => uint96) internal balances;\r\n\r\n    /// @notice A record of each accounts delegate\r\n    mapping (address => address) public delegates;\r\n\r\n    /// @notice A checkpoint for marking number of votes from a given block\r\n    struct Checkpoint {\r\n        uint32 fromBlock;\r\n        uint96 votes;\r\n    }\r\n\r\n    /// @notice A record of votes checkpoints for each account, by index\r\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\r\n\r\n    /// @notice The number of checkpoints for each account\r\n    mapping (address => uint32) public numCheckpoints;\r\n\r\n    /// @notice The EIP-712 typehash for the contract's domain\r\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n\r\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\r\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\r\n\r\n    /// @notice A record of states for signing / validating signatures\r\n    mapping (address => uint) public nonces;\r\n\r\n    /// @notice An event thats emitted when an account changes its delegate\r\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\r\n\r\n    /// @notice An event thats emitted when a delegate account's vote balance changes\r\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\r\n\r\n    /// @notice The standard EIP-20 transfer event\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    /// @notice The standard EIP-20 approval event\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /**\r\n     * @notice Construct a new LendHub token\r\n     * @param account The initial account to grant all the tokens\r\n     */\r\n    constructor(address account) {\r\n        balances[account] = uint96(totalSupply);\r\n        emit Transfer(address(0), account, totalSupply);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\r\n     * @param account The address of the account holding the funds\r\n     * @param spender The address of the account spending the funds\r\n     * @return The number of tokens approved\r\n     */\r\n    function allowance(address account, address spender) external view returns (uint) {\r\n        return allowances[account][spender];\r\n    }\r\n\r\n    /**\r\n     * @notice Approve `spender` to transfer up to `amount` from `src`\r\n     * @dev This will overwrite the approval amount for `spender`\r\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\r\n     * @param spender The address of the account which may transfer tokens\r\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\r\n     * @return Whether or not the approval succeeded\r\n     */\r\n    function approve(address spender, uint rawAmount) external returns (bool) {\r\n        uint96 amount;\r\n        if (rawAmount == uint(-1)) {\r\n            amount = uint96(-1);\r\n        } else {\r\n            amount = safe96(rawAmount, \"Lend::approve: amount exceeds 96 bits\");\r\n        }\r\n\r\n        allowances[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the number of tokens held by the `account`\r\n     * @param account The address of the account to get the balance of\r\n     * @return The number of tokens held\r\n     */\r\n    function balanceOf(address account) external view returns (uint) {\r\n        return balances[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n     * @param dst The address of the destination account\r\n     * @param rawAmount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transfer(address dst, uint rawAmount) external returns (bool) {\r\n        uint96 amount = safe96(rawAmount, \"Lend::transfer: amount exceeds 96 bits\");\r\n        _transferTokens(msg.sender, dst, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `src` to `dst`\r\n     * @param src The address of the source account\r\n     * @param dst The address of the destination account\r\n     * @param rawAmount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transferFrom(address src, address dst, uint rawAmount) external returns (bool) {\r\n        address spender = msg.sender;\r\n        uint96 spenderAllowance = allowances[src][spender];\r\n        uint96 amount = safe96(rawAmount, \"Lend::approve: amount exceeds 96 bits\");\r\n\r\n        if (spender != src && spenderAllowance != uint96(-1)) {\r\n            uint96 newAllowance = sub96(spenderAllowance, amount, \"Lend::transferFrom: transfer amount exceeds spender allowance\");\r\n            allowances[src][spender] = newAllowance;\r\n\r\n            emit Approval(src, spender, newAllowance);\r\n        }\r\n\r\n        _transferTokens(src, dst, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Delegate votes from `msg.sender` to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     */\r\n    function delegate(address delegatee) public {\r\n        return _delegate(msg.sender, delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates votes from signatory to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     * @param nonce The contract state required to match the signature\r\n     * @param expiry The time at which to expire the signature\r\n     * @param v The recovery byte of the signature\r\n     * @param r Half of the ECDSA signature pair\r\n     * @param s Half of the ECDSA signature pair\r\n     */\r\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {\r\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\r\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\r\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n        address signatory = ecrecover(digest, v, r, s);\r\n        require(signatory != address(0), \"Lend::delegateBySig: invalid signature\");\r\n        require(nonce == nonces[signatory]++, \"Lend::delegateBySig: invalid nonce\");\r\n        // require(now <= expiry, \"Lend::delegateBySig: signature expired\");\r\n        require(block.timestamp <= expiry, \"Lend::delegateBySig: signature expired\");\r\n        return _delegate(signatory, delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current votes balance for `account`\r\n     * @param account The address to get votes balance\r\n     * @return The number of current votes for `account`\r\n     */\r\n    function getCurrentVotes(address account) external view returns (uint96) {\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the prior number of votes for an account as of a block number\r\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\r\n     * @param account The address of the account to check\r\n     * @param blockNumber The block number to get the vote balance at\r\n     * @return The number of votes the account had as of the given block\r\n     */\r\n    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\r\n        require(blockNumber < block.number, \"Lend::getPriorVotes: not yet determined\");\r\n\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        if (nCheckpoints == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // First check most recent balance\r\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\r\n            return checkpoints[account][nCheckpoints - 1].votes;\r\n        }\r\n\r\n        // Next check implicit zero balance\r\n        if (checkpoints[account][0].fromBlock > blockNumber) {\r\n            return 0;\r\n        }\r\n\r\n        uint32 lower = 0;\r\n        uint32 upper = nCheckpoints - 1;\r\n        while (upper > lower) {\r\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\r\n            Checkpoint memory cp = checkpoints[account][center];\r\n            if (cp.fromBlock == blockNumber) {\r\n                return cp.votes;\r\n            } else if (cp.fromBlock < blockNumber) {\r\n                lower = center;\r\n            } else {\r\n                upper = center - 1;\r\n            }\r\n        }\r\n        return checkpoints[account][lower].votes;\r\n    }\r\n\r\n    function _delegate(address delegator, address delegatee) internal {\r\n        address currentDelegate = delegates[delegator];\r\n        uint96 delegatorBalance = balances[delegator];\r\n        delegates[delegator] = delegatee;\r\n\r\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\r\n\r\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\r\n    }\r\n\r\n    function _transferTokens(address src, address dst, uint96 amount) internal {\r\n        require(src != address(0), \"Lend::_transferTokens: cannot transfer from the zero address\");\r\n        require(dst != address(0), \"Lend::_transferTokens: cannot transfer to the zero address\");\r\n\r\n        balances[src] = sub96(balances[src], amount, \"Lend::_transferTokens: transfer amount exceeds balance\");\r\n        balances[dst] = add96(balances[dst], amount, \"Lend::_transferTokens: transfer amount overflows\");\r\n        emit Transfer(src, dst, amount);\r\n\r\n        _moveDelegates(delegates[src], delegates[dst], amount);\r\n    }\r\n\r\n    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\r\n        if (srcRep != dstRep && amount > 0) {\r\n            if (srcRep != address(0)) {\r\n                uint32 srcRepNum = numCheckpoints[srcRep];\r\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\r\n                uint96 srcRepNew = sub96(srcRepOld, amount, \"Lend::_moveVotes: vote amount underflows\");\r\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\r\n            }\r\n\r\n            if (dstRep != address(0)) {\r\n                uint32 dstRepNum = numCheckpoints[dstRep];\r\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\r\n                uint96 dstRepNew = add96(dstRepOld, amount, \"Lend::_moveVotes: vote amount overflows\");\r\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\r\n        uint32 blockNumber = safe32(block.number, \"Lend::_writeCheckpoint: block number exceeds 32 bits\");\r\n\r\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\r\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\r\n        } else {\r\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\r\n            numCheckpoints[delegatee] = nCheckpoints + 1;\r\n        }\r\n\r\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\r\n    }\r\n\r\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\r\n        require(n < 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\r\n        require(n < 2**96, errorMessage);\r\n        return uint96(n);\r\n    }\r\n\r\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\r\n        uint96 c = a + b;\r\n        require(c >= a, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    function getChainId() internal pure returns (uint) {\r\n        uint256 chainId;\r\n        assembly { chainId := chainid() }\r\n        return chainId;\r\n    }\r\n}\r\n"
    },
    "contracts/compound/SimplePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\nimport \"./PriceOracle.sol\";\r\nimport \"./LErc20.sol\";\r\n\r\ncontract SimplePriceOracle is PriceOracle {\r\n    mapping(address => uint) prices;\r\n    uint baseTokenPrice;\r\n    string public baseSymbol;\r\n\r\n    address admin;\r\n    event PricePosted(address asset, uint previousPriceMantissa, uint requestedPriceMantissa, uint newPriceMantissa);\r\n\r\n    constructor(string memory symbol) {\r\n        admin = msg.sender;\r\n        baseSymbol = symbol;\r\n    }\r\n\r\n    function getUnderlyingPrice(CToken cToken) override public view returns (uint) {\r\n        if (compareStrings(cToken.symbol(), baseSymbol)) {\r\n            return baseTokenPrice;\r\n        } else {\r\n            return prices[address(LErc20(address(cToken)).underlying())];\r\n        }\r\n    }\r\n\r\n    function setUnderlyingPrice(CToken cToken, uint underlyingPriceMantissa) public {\r\n        require(msg.sender == admin, \"only the admin may call setUnderlyingPrice\");\r\n        if (compareStrings(cToken.symbol(), baseSymbol)) {\r\n            baseTokenPrice = underlyingPriceMantissa;\r\n        } else {\r\n            address asset = address(LErc20(address(cToken)).underlying());\r\n            emit PricePosted(asset, prices[asset], underlyingPriceMantissa, underlyingPriceMantissa);\r\n            prices[asset] = underlyingPriceMantissa;\r\n        }\r\n    }\r\n\r\n    function setDirectPrice(address asset, uint price) public {\r\n        require(msg.sender == admin, \"only the admin may call setDirectPrice\");\r\n        emit PricePosted(asset, prices[asset], price, price);\r\n        prices[asset] = price;\r\n    }\r\n\r\n    function changeAdmin(address newAdmin) public {\r\n        require(msg.sender == admin, \"only the admin may call changeAdmin\");\r\n        admin = newAdmin;\r\n    }\r\n\r\n    // v1 price oracle interface for use as backing of proxy\r\n    function assetPrices(address asset) external view returns (uint) {\r\n        return prices[asset];\r\n    }\r\n\r\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\r\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\r\n    }\r\n\r\n    function setSymbol(string memory symbol) public {\r\n        require(msg.sender == admin, \"only the admin may call changeAdmin\");\r\n        baseSymbol = symbol;\r\n    }\r\n}\r\n\r\n"
    },
    "contracts/compound/LErc20Immutable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\nimport \"./LErc20.sol\";\r\n\r\n/**\r\n * @title LendHub's CErc20Immutable Contract\r\n * @notice CTokens which wrap an EIP-20 underlying and are immutable\r\n * @author LendHub\r\n */\r\ncontract LErc20Immutable is LErc20 {\r\n    /**\r\n     * @notice Construct La new money market\r\n     * @param underlying_ The address of the underlying asset\r\n     * @param comptroller_ The address of the Comptroller\r\n     * @param interestRateModel_ The address of the interest rate model\r\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\r\n     * @param name_ ERC-20 name of this token\r\n     * @param symbol_ ERC-20 symbol of this token\r\n     * @param decimals_ ERC-20 decimal precision of this token\r\n     * @param admin_ Address of the administrator of this token\r\n     */\r\n    constructor(address underlying_,\r\n                ComptrollerInterface comptroller_,\r\n                InterestRateModel interestRateModel_,\r\n                uint initialExchangeRateMantissa_,\r\n                string memory name_,\r\n                string memory symbol_,\r\n                uint8 decimals_,\r\n                address payable admin_) {\r\n        // Creator of the contract is admin during initialization\r\n        admin = msg.sender;\r\n\r\n        // Initialize the market\r\n        initialize(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\r\n\r\n        // Set the proper admin now that initialization is done\r\n        admin = admin_;\r\n    }\r\n}\r\n"
    },
    "contracts/compound/LErc20Delegate.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\nimport \"./LErc20.sol\";\r\n\r\n/**\r\n * @title Compound's CErc20Delegate Contract\r\n * @notice CTokens which wrap an EIP-20 underlying and are delegated to\r\n * @author Compound\r\n */\r\ncontract LErc20Delegate is LErc20, CDelegateInterface {\r\n    /**\r\n     * @notice Construct an empty delegate\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     * @notice Called by the delegator on a delegate to initialize it for duty\r\n     * @param data The encoded bytes data for any initialization\r\n     */\r\n    function _becomeImplementation(bytes memory data) override public {\r\n        // Shh -- currently unused\r\n        data;\r\n\r\n        // Shh -- we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            implementation = address(0);\r\n        }\r\n\r\n        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\r\n    }\r\n\r\n    /**\r\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\r\n     */\r\n    function _resignImplementation() override public {\r\n        // Shh -- we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            implementation = address(0);\r\n        }\r\n\r\n        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\r\n    }\r\n}\r\n"
    },
    "contracts/compound/lens/LendHubLens.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n// pragma experimental ABIEncoderV2;\r\npragma abicoder v2;\r\n\r\nimport \"../LErc20.sol\";\r\nimport \"../CToken.sol\";\r\nimport \"../PriceOracle.sol\";\r\nimport \"../EIP20Interface.sol\";\r\nimport \"../Governance/LendHub.sol\";\r\n\r\ninterface ComptrollerLensInterface {\r\n    function markets(address) external view returns (bool, uint);\r\n    function oracle() external view returns (PriceOracle);\r\n    function getAccountLiquidity(address) external view returns (uint, uint, uint);\r\n    function getAssetsIn(address) external view returns (CToken[] memory);\r\n    function claimComp(address) external;\r\n    function compAccrued(address) external view returns (uint);\r\n}\r\n\r\ncontract LendHubLens {\r\n    struct CTokenMetadata {\r\n        address cToken;\r\n        uint exchangeRateCurrent;\r\n        uint supplyRatePerBlock;\r\n        uint borrowRatePerBlock;\r\n        uint reserveFactorMantissa;\r\n        uint totalBorrows;\r\n        uint totalReserves;\r\n        uint totalSupply;\r\n        uint totalCash;\r\n        bool isListed;\r\n        uint collateralFactorMantissa;\r\n        address underlyingAssetAddress;\r\n        uint cTokenDecimals;\r\n        uint underlyingDecimals;\r\n    }\r\n\r\n    function cTokenMetadata(CToken cToken) public returns (CTokenMetadata memory) {\r\n        uint exchangeRateCurrent = cToken.exchangeRateCurrent();\r\n        ComptrollerLensInterface comptroller = ComptrollerLensInterface(address(cToken.comptroller()));\r\n        (bool isListed, uint collateralFactorMantissa) = comptroller.markets(address(cToken));\r\n        address underlyingAssetAddress;\r\n        uint underlyingDecimals;\r\n\r\n        if (compareStrings(cToken.symbol(), \"lHT\")) {\r\n            underlyingAssetAddress = address(0);\r\n            underlyingDecimals = 18;\r\n        } else {\r\n            LErc20 lErc20 = LErc20(address(cToken));\r\n            underlyingAssetAddress = lErc20.underlying();\r\n            underlyingDecimals = EIP20Interface(lErc20.underlying()).decimals();\r\n        }\r\n\r\n        return CTokenMetadata({\r\n            cToken: address(cToken),\r\n            exchangeRateCurrent: exchangeRateCurrent,\r\n            supplyRatePerBlock: cToken.supplyRatePerBlock(),\r\n            borrowRatePerBlock: cToken.borrowRatePerBlock(),\r\n            reserveFactorMantissa: cToken.reserveFactorMantissa(),\r\n            totalBorrows: cToken.totalBorrows(),\r\n            totalReserves: cToken.totalReserves(),\r\n            totalSupply: cToken.totalSupply(),\r\n            totalCash: cToken.getCash(),\r\n            isListed: isListed,\r\n            collateralFactorMantissa: collateralFactorMantissa,\r\n            underlyingAssetAddress: underlyingAssetAddress,\r\n            cTokenDecimals: cToken.decimals(),\r\n            underlyingDecimals: underlyingDecimals\r\n        });\r\n    }\r\n\r\n    function cTokenMetadataAll(CToken[] calldata cTokens) external returns (CTokenMetadata[] memory) {\r\n        uint cTokenCount = cTokens.length;\r\n        CTokenMetadata[] memory res = new CTokenMetadata[](cTokenCount);\r\n        for (uint i = 0; i < cTokenCount; i++) {\r\n            res[i] = cTokenMetadata(cTokens[i]);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    struct CTokenBalances {\r\n        address cToken;\r\n        uint balanceOf;\r\n        uint borrowBalanceCurrent;\r\n        uint balanceOfUnderlying;\r\n        uint tokenBalance;\r\n        uint tokenAllowance;\r\n    }\r\n\r\n    function cTokenBalances(CToken cToken, address payable account) public returns (CTokenBalances memory) {\r\n        uint balanceOf = cToken.balanceOf(account);\r\n        uint borrowBalanceCurrent = cToken.borrowBalanceCurrent(account);\r\n        uint balanceOfUnderlying = cToken.balanceOfUnderlying(account);\r\n        uint tokenBalance;\r\n        uint tokenAllowance;\r\n\r\n        if (compareStrings(cToken.symbol(), \"lHT\")) {\r\n            tokenBalance = account.balance;\r\n            tokenAllowance = account.balance;\r\n        } else {\r\n            LErc20 lErc20 = LErc20(address(cToken));\r\n            EIP20Interface underlying = EIP20Interface(lErc20.underlying());\r\n            tokenBalance = underlying.balanceOf(account);\r\n            tokenAllowance = underlying.allowance(account, address(cToken));\r\n        }\r\n\r\n        return CTokenBalances({\r\n            cToken: address(cToken),\r\n            balanceOf: balanceOf,\r\n            borrowBalanceCurrent: borrowBalanceCurrent,\r\n            balanceOfUnderlying: balanceOfUnderlying,\r\n            tokenBalance: tokenBalance,\r\n            tokenAllowance: tokenAllowance\r\n        });\r\n    }\r\n\r\n    function cTokenBalancesAll(CToken[] calldata cTokens, address payable account) external returns (CTokenBalances[] memory) {\r\n        uint cTokenCount = cTokens.length;\r\n        CTokenBalances[] memory res = new CTokenBalances[](cTokenCount);\r\n        for (uint i = 0; i < cTokenCount; i++) {\r\n            res[i] = cTokenBalances(cTokens[i], account);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    struct CTokenUnderlyingPrice {\r\n        address cToken;\r\n        uint underlyingPrice;\r\n    }\r\n\r\n    function cTokenUnderlyingPrice(CToken cToken) public view returns (CTokenUnderlyingPrice memory) {\r\n        ComptrollerLensInterface comptroller = ComptrollerLensInterface(address(cToken.comptroller()));\r\n        PriceOracle priceOracle = comptroller.oracle();\r\n\r\n        return CTokenUnderlyingPrice({\r\n            cToken: address(cToken),\r\n            underlyingPrice: priceOracle.getUnderlyingPrice(cToken)\r\n        });\r\n    }\r\n\r\n    function cTokenUnderlyingPriceAll(CToken[] calldata cTokens) external view returns (CTokenUnderlyingPrice[] memory) {\r\n        uint cTokenCount = cTokens.length;\r\n        CTokenUnderlyingPrice[] memory res = new CTokenUnderlyingPrice[](cTokenCount);\r\n        for (uint i = 0; i < cTokenCount; i++) {\r\n            res[i] = cTokenUnderlyingPrice(cTokens[i]);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    struct AccountLimits {\r\n        CToken[] markets;\r\n        uint liquidity;\r\n        uint shortfall;\r\n    }\r\n\r\n    function getAccountLimits(ComptrollerLensInterface comptroller, address account) public view returns (AccountLimits memory) {\r\n        (uint errorCode, uint liquidity, uint shortfall) = comptroller.getAccountLiquidity(account);\r\n        require(errorCode == 0);\r\n\r\n        return AccountLimits({\r\n            markets: comptroller.getAssetsIn(account),\r\n            liquidity: liquidity,\r\n            shortfall: shortfall\r\n        });\r\n    }\r\n\r\n    struct CompBalanceMetadata {\r\n        uint balance;\r\n        uint votes;\r\n        address delegate;\r\n    }\r\n\r\n    function getCompBalanceMetadata(LendHub lhb, address account) external view returns (CompBalanceMetadata memory) {\r\n        return CompBalanceMetadata({\r\n            balance: lhb.balanceOf(account),\r\n            votes: uint256(lhb.getCurrentVotes(account)),\r\n            delegate: lhb.delegates(account)\r\n        });\r\n    }\r\n\r\n    struct CompBalanceMetadataExt {\r\n        uint balance;\r\n        uint votes;\r\n        address delegate;\r\n        uint allocated;\r\n    }\r\n\r\n    function getCompBalanceMetadataExt(LendHub lhb, ComptrollerLensInterface comptroller, address account) external returns (CompBalanceMetadataExt memory) {\r\n        uint balance = lhb.balanceOf(account);\r\n        comptroller.claimComp(account);\r\n        uint newBalance = lhb.balanceOf(account);\r\n        uint accrued = comptroller.compAccrued(account);\r\n        uint total = add(accrued, newBalance, \"sum LHB total\");\r\n        uint allocated = sub(total, balance, \"sub allocated\");\r\n\r\n        return CompBalanceMetadataExt({\r\n            balance: balance,\r\n            votes: uint256(lhb.getCurrentVotes(account)),\r\n            delegate: lhb.delegates(account),\r\n            allocated: allocated\r\n        });\r\n    }\r\n\r\n    struct CompVotes {\r\n        uint blockNumber;\r\n        uint votes;\r\n    }\r\n\r\n    function getCompVotes(LendHub lhb, address account, uint32[] calldata blockNumbers) external view returns (CompVotes[] memory) {\r\n        CompVotes[] memory res = new CompVotes[](blockNumbers.length);\r\n        for (uint i = 0; i < blockNumbers.length; i++) {\r\n            res[i] = CompVotes({\r\n                blockNumber: uint256(blockNumbers[i]),\r\n                votes: uint256(lhb.getPriorVotes(account, blockNumbers[i]))\r\n            });\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\r\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\r\n    }\r\n\r\n    function add(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        require(b <= a, errorMessage);\r\n        uint c = a - b;\r\n        return c;\r\n    }\r\n}\r\n"
    },
    "contracts/compound/lp/Chef.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../Governance/LendHub.sol\";\r\n\r\n//\r\n// Note that it's ownable and the owner wields tremendous power. The ownership\r\n// will be transferred to a governance smart contract once LHB is sufficiently\r\n// distributed and the community can show to govern itself.\r\n//\r\n// Have fun reading it. Hopefully it's bug-free. God bless.\r\ncontract Chef is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // Info of each user.\r\n    struct UserInfo {\r\n        uint256 amount;     // How many LP tokens the user has provided.\r\n        uint256 rewardDebt; // Reward debt. See explanation below.\r\n        //\r\n        // We do some fancy math here. Basically, any point in time, the amount of SUSHIs\r\n        // entitled to a user but is pending to be distributed is:\r\n        //\r\n        //   pending reward = (user.amount * pool.accLHBPerShare) - user.rewardDebt\r\n        //\r\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\r\n        //   1. The pool's `accLHBPerShare` (and `lastRewardBlock`) gets updated.\r\n        //   2. User receives the pending reward sent to his/her address.\r\n        //   3. User's `amount` gets updated.\r\n        //   4. User's `rewardDebt` gets updated.\r\n    }\r\n\r\n    // Info of each pool.\r\n    struct PoolInfo {\r\n        IERC20 lpToken;           // Address of LP token contract.\r\n        uint256 allocPoint;       // How many allocation points assigned to this pool. SUSHIs to distribute per block.\r\n        uint256 lastRewardBlock;  // Last block number that SUSHIs distribution occurs.\r\n        uint256 accLHBPerShare; // Accumulated LHB per share, times 1e12. See below.\r\n    }\r\n\r\n    // The LHB TOKEN!\r\n    LendHub public lhb;\r\n    uint256 public userLHBAmount = 0;\r\n    // LHB tokens created per block.\r\n    uint256 public lhbPerBlock;\r\n\r\n    // Info of each pool.\r\n    PoolInfo[] public poolInfo;\r\n    // Info of each user that stakes LP tokens.\r\n    mapping (uint256 => mapping (address => UserInfo)) public userInfo;\r\n    // Total allocation points. Must be the sum of all allocation points in all pools.\r\n    uint256 public totalAllocPoint = 0;\r\n    // The block number when LHB mining starts.\r\n    uint256 public startBlock;\r\n\r\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n\r\n    constructor(\r\n        LendHub _lhb,\r\n        uint256 _lhbPerBlock,\r\n        uint256 _startBlock\r\n    ) {\r\n        lhb = _lhb;\r\n        lhbPerBlock = _lhbPerBlock;\r\n        startBlock = _startBlock;\r\n    }\r\n\r\n    function poolLength() external view returns (uint256) {\r\n        return poolInfo.length;\r\n    }\r\n\r\n    function updateLHBPerBlock(uint256 _lhbPerBlock) public onlyOwner {\r\n        massUpdatePools();\r\n        lhbPerBlock = _lhbPerBlock;\r\n    }\r\n\r\n    // Add a new lp to the pool. Can only be called by the owner.\r\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\r\n    function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner {\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\r\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\r\n        poolInfo.push(PoolInfo({\r\n            lpToken: _lpToken,\r\n            allocPoint: _allocPoint,\r\n            lastRewardBlock: lastRewardBlock,\r\n            accLHBPerShare: 0\r\n        }));\r\n    }\r\n\r\n    // Update the given pool's LHB allocation point. Can only be called by the owner.\r\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner {\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\r\n        poolInfo[_pid].allocPoint = _allocPoint;\r\n    }\r\n\r\n    // Return reward multiplier over the given _from to _to block.\r\n    function getMultiplier(uint256 _from, uint256 _to) public pure returns (uint256) {\r\n        return _to.sub(_from);\r\n    }\r\n\r\n    // View function to see pending SUSHIs on frontend.\r\n    function pendingLHB(uint256 _pid, address _user) external view returns (uint256) {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        uint256 accLHBPerShare = pool.accLHBPerShare;\r\n        uint256 lpSupply = 0;\r\n        if (address(pool.lpToken) == address(lhb)) {\r\n             lpSupply = userLHBAmount;\r\n        } else {\r\n            lpSupply = pool.lpToken.balanceOf(address(this));\r\n        }\r\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\r\n            uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\r\n            uint256 sushiReward = multiplier.mul(lhbPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\r\n            accLHBPerShare = accLHBPerShare.add(sushiReward.mul(1e12).div(lpSupply));\r\n        }\r\n        return user.amount.mul(accLHBPerShare).div(1e12).sub(user.rewardDebt);\r\n    }\r\n\r\n    // Update reward variables for all pools. Be careful of gas spending!\r\n    function massUpdatePools() public {\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            updatePool(pid);\r\n        }\r\n    }\r\n\r\n    // Update reward variables of the given pool to be up-to-date.\r\n    function updatePool(uint256 _pid) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (block.number <= pool.lastRewardBlock) {\r\n            return;\r\n        }\r\n        uint256 lpSupply = 0;\r\n        if (address(pool.lpToken) == address(lhb)) {\r\n            lpSupply = userLHBAmount;\r\n        } else {\r\n            lpSupply = pool.lpToken.balanceOf(address(this));\r\n        }\r\n        if (lpSupply == 0) {\r\n            pool.lastRewardBlock = block.number;\r\n            return;\r\n        }\r\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\r\n        uint256 sushiReward = multiplier.mul(lhbPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\r\n        pool.accLHBPerShare = pool.accLHBPerShare.add(sushiReward.mul(1e12).div(lpSupply));\r\n        pool.lastRewardBlock = block.number;\r\n    }\r\n\r\n    // Deposit LP tokens to MasterChef for LHB allocation.\r\n    function deposit(uint256 _pid, uint256 _amount) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        updatePool(_pid);\r\n        if (user.amount > 0) {\r\n            uint256 pending = user.amount.mul(pool.accLHBPerShare).div(1e12).sub(user.rewardDebt);\r\n            if(pending > 0) {\r\n                safeLHBTransfer(msg.sender, pending);\r\n            }\r\n        }\r\n        if(_amount > 0) {\r\n            pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\r\n            user.amount = user.amount.add(_amount);\r\n            if (address(pool.lpToken) == address(lhb)) {\r\n                userLHBAmount = userLHBAmount.add(_amount);\r\n            }\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accLHBPerShare).div(1e12);\r\n        emit Deposit(msg.sender, _pid, _amount);\r\n    }\r\n\r\n    // Withdraw LP tokens from MasterChef.\r\n    function withdraw(uint256 _pid, uint256 _amount) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        require(user.amount >= _amount, \"withdraw: not good\");\r\n        updatePool(_pid);\r\n        uint256 pending = user.amount.mul(pool.accLHBPerShare).div(1e12).sub(user.rewardDebt);\r\n        if(pending > 0) {\r\n            safeLHBTransfer(msg.sender, pending);\r\n        }\r\n        if(_amount > 0) {\r\n            user.amount = user.amount.sub(_amount);\r\n            if (address(pool.lpToken) == address(lhb)) {\r\n                userLHBAmount = userLHBAmount.sub(_amount);\r\n            }\r\n            pool.lpToken.safeTransfer(address(msg.sender), _amount);\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accLHBPerShare).div(1e12);\r\n        emit Withdraw(msg.sender, _pid, _amount);\r\n    }\r\n\r\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\r\n    function emergencyWithdraw(uint256 _pid) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        uint256 amount = user.amount;\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n        if (address(pool.lpToken) == address(lhb)) {\r\n            userLHBAmount = userLHBAmount.sub(amount);\r\n        }\r\n        pool.lpToken.safeTransfer(address(msg.sender), amount);\r\n        emit EmergencyWithdraw(msg.sender, _pid, amount);\r\n    }\r\n\r\n    // Safe lhb transfer function, just in case if rounding error causes pool to not have enough LHBs.\r\n    function safeLHBTransfer(address _to, uint256 _amount) internal {\r\n        uint256 lhbBalance = lhb.balanceOf(address(this));\r\n        lhbBalance = lhbBalance.sub(userLHBAmount);\r\n        if (_amount > lhbBalance) {\r\n            lhb.transfer(_to, lhbBalance);\r\n        } else {\r\n            lhb.transfer(_to, _amount);\r\n        }\r\n    }\r\n\r\n    function grantCompInternal(address _to, uint _amount) internal returns (uint) {\r\n        uint lhbBalance = lhb.balanceOf(address(this));\r\n        lhbBalance = lhbBalance.sub(userLHBAmount);\r\n        if (_amount <= lhbBalance) {\r\n            lhb.transfer(_to, _amount);\r\n            return 0;\r\n        }\r\n        return _amount;\r\n    }\r\n\r\n    function _grantComp(address recipient, uint amount) public onlyOwner {\r\n        uint amountLeft = grantCompInternal(recipient, amount);\r\n        require(amountLeft == 0, \"insufficient LHB for grant\");\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/swap/mainnet/CoinChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.6;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"../interface/IMdx.sol\";\r\n\r\ninterface IMasterChef {\r\n    function pendingSushi(uint256 pid, address user) external view returns (uint256);\r\n\r\n    function deposit(uint256 pid, uint256 amount) external;\r\n\r\n    function withdraw(uint256 pid, uint256 amount) external;\r\n\r\n    function emergencyWithdraw(uint256 pid) external;\r\n}\r\n\r\ncontract CoinChef is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    EnumerableSet.AddressSet private _sushiLP;\r\n\r\n    // Info of each user.\r\n    struct UserInfo {\r\n        uint256 amount;     // How many LP tokens the user has provided.\r\n        uint256 rewardDebt; // Reward debt.\r\n        uint256 sushiRewardDebt; //sushi Reward debt.\r\n    }\r\n\r\n    // Info of each pool.\r\n    struct PoolInfo {\r\n        IERC20 lpToken;           // Address of LP token contract.\r\n        uint256 allocPoint;       // How many allocation points assigned to this pool. MDXs to distribute per block.\r\n        uint256 lastRewardBlock;  // Last block number that MDXs distribution occurs.\r\n        uint256 accMdxPerShare; // Accumulated MDXs per share, times 1e12.\r\n        uint256 totalAmount;    // Total amount of current pool deposit.\r\n        uint256 accSushiPerShare; //Accumulated SuSHIs per share\r\n    }\r\n\r\n    // The MDX TOKEN!\r\n    IMdx public mdx;\r\n    // MDX tokens created per block.\r\n    uint256 public constant mdxPerBlock = 100 * 1e18;\r\n    // Info of each pool.\r\n    PoolInfo[] public poolInfo;\r\n    // Info of each user that stakes LP tokens.\r\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n    // Corresponding to the pid of the sushi pool\r\n    mapping(uint256 => uint256) public poolCorrespond;\r\n    // Total allocation points. Must be the sum of all allocation points in all pools.\r\n    uint256 public totalAllocPoint = 0;\r\n    // The block number when MDX mining starts.\r\n    uint256 public startBlock;\r\n    // The block number when MDX mining end;\r\n    uint256 public endBlock;\r\n    // SUSHI MasterChef 0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd\r\n    address public constant sushiChef = 0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd;\r\n    // SUSHI Token 0x6B3595068778DD592e39A122f4f5a5cF09C90fE2\r\n    address public constant sushiToken = 0x6B3595068778DD592e39A122f4f5a5cF09C90fE2;\r\n\r\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n\r\n    constructor(\r\n        IMdx _mdx,\r\n        uint256 _startBlock\r\n    ) {\r\n        mdx = _mdx;\r\n        startBlock = _startBlock;\r\n        endBlock = _startBlock.add(200000);\r\n    }\r\n\r\n    function poolLength() public view returns (uint256) {\r\n        return poolInfo.length;\r\n    }\r\n\r\n    function addSushiLP(address _addLP) public onlyOwner returns (bool) {\r\n        require(_addLP != address(0), \"LP is the zero address\");\r\n        IERC20(_addLP).approve(sushiChef, uint256(- 1));\r\n        return EnumerableSet.add(_sushiLP, _addLP);\r\n    }\r\n\r\n    function isSushiLP(address _LP) public view returns (bool) {\r\n        return EnumerableSet.contains(_sushiLP, _LP);\r\n    }\r\n\r\n    function getSushiLPLength() public view returns (uint256) {\r\n        return EnumerableSet.length(_sushiLP);\r\n    }\r\n\r\n    function getSushiLPAddress(uint256 _pid) public view returns (address){\r\n        require(_pid <= getSushiLPLength() - 1, \"not find this SushiLP\");\r\n        return EnumerableSet.at(_sushiLP, _pid);\r\n    }\r\n\r\n    // Add a new lp to the pool. Can only be called by the owner.\r\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\r\n    function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner {\r\n        require(address(_lpToken) != address(0), \"lpToken is the zero address\");\r\n        require(block.number < endBlock, \"All token mining completed\");\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\r\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\r\n        poolInfo.push(PoolInfo({\r\n        lpToken : _lpToken,\r\n        allocPoint : _allocPoint,\r\n        lastRewardBlock : lastRewardBlock,\r\n        accMdxPerShare : 0,\r\n        totalAmount : 0,\r\n        accSushiPerShare : 0\r\n        }));\r\n    }\r\n\r\n    // Update the given pool's MDX allocation point. Can only be called by the owner.\r\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner {\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\r\n        poolInfo[_pid].allocPoint = _allocPoint;\r\n    }\r\n\r\n    // The current pool corresponds to the pid of the sushi pool\r\n    function setPoolCorr(uint256 _pid, uint256 _sid) public onlyOwner {\r\n        require(_pid <= poolLength() - 1, \"not find this pool\");\r\n        poolCorrespond[_pid] = _sid;\r\n    }\r\n\r\n    // Update reward variables for all pools. Be careful of gas spending!\r\n    function massUpdatePools() public {\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            updatePool(pid);\r\n        }\r\n    }\r\n\r\n    // Update reward variables of the given pool to be up-to-date.\r\n    function updatePool(uint256 _pid) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        uint256 number = block.number > endBlock ? endBlock : block.number;\r\n        if (number <= pool.lastRewardBlock) {\r\n            return;\r\n        }\r\n        uint256 lpSupply;\r\n        if (isSushiLP(address(pool.lpToken))) {\r\n            if (pool.totalAmount == 0) {\r\n                pool.lastRewardBlock = number;\r\n                return;\r\n            }\r\n            lpSupply = pool.totalAmount;\r\n        } else {\r\n            lpSupply = pool.lpToken.balanceOf(address(this));\r\n            if (lpSupply == 0) {\r\n                pool.lastRewardBlock = number;\r\n                return;\r\n            }\r\n        }\r\n\r\n        uint256 multiplier = number.sub(pool.lastRewardBlock);\r\n        uint256 mdxReward = multiplier.mul(mdxPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\r\n        bool minRet = mdx.mint(address(this), mdxReward);\r\n        if (minRet) {\r\n            pool.accMdxPerShare = pool.accMdxPerShare.add(mdxReward.mul(1e12).div(lpSupply));\r\n        }\r\n        pool.lastRewardBlock = number;\r\n    }\r\n\r\n    // View function to see pending MDXs on frontend.\r\n    function pending(uint256 _pid, address _user) external view returns (uint256, uint256){\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (isSushiLP(address(pool.lpToken))) {\r\n            (uint256 mdxAmount, uint256 sushiAmount) = pendingMdxAndSushi(_pid, _user);\r\n            return (mdxAmount, sushiAmount);\r\n        } else {\r\n            uint256 mdxAmount = pendingMdx(_pid, _user);\r\n            return (mdxAmount, 0);\r\n        }\r\n    }\r\n\r\n    function pendingMdxAndSushi(uint256 _pid, address _user) private view returns (uint256, uint256){\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        uint256 accMdxPerShare = pool.accMdxPerShare;\r\n        uint256 accSushiPerShare = pool.accSushiPerShare;\r\n        uint256 number = block.number > endBlock ? endBlock : block.number;\r\n        if (user.amount > 0) {\r\n            uint256 sushiPending = IMasterChef(sushiChef).pendingSushi(poolCorrespond[_pid], address(this));\r\n            accSushiPerShare = accSushiPerShare.add(sushiPending.mul(1e12).div(pool.totalAmount));\r\n            uint256 userPending = user.amount.mul(accSushiPerShare).div(1e12).sub(user.sushiRewardDebt);\r\n            if (number > pool.lastRewardBlock) {\r\n                uint256 multiplier = number.sub(pool.lastRewardBlock);\r\n                uint256 mdxReward = multiplier.mul(mdxPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\r\n                accMdxPerShare = accMdxPerShare.add(mdxReward.mul(1e12).div(pool.totalAmount));\r\n                return (user.amount.mul(accMdxPerShare).div(1e12).sub(user.rewardDebt), userPending);\r\n            }\r\n            if (number == pool.lastRewardBlock) {\r\n                return (user.amount.mul(accMdxPerShare).div(1e12).sub(user.rewardDebt), userPending);\r\n            }\r\n        }\r\n        return (0, 0);\r\n    }\r\n\r\n    function pendingMdx(uint256 _pid, address _user) private view returns (uint256){\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        uint256 accMdxPerShare = pool.accMdxPerShare;\r\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\r\n        uint256 number = block.number > endBlock ? endBlock : block.number;\r\n        if (user.amount > 0) {\r\n            if (number > pool.lastRewardBlock) {\r\n                uint256 multiplier = block.number.sub(pool.lastRewardBlock);\r\n                uint256 mdxReward = multiplier.mul(mdxPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\r\n                accMdxPerShare = accMdxPerShare.add(mdxReward.mul(1e12).div(lpSupply));\r\n                return user.amount.mul(accMdxPerShare).div(1e12).sub(user.rewardDebt);\r\n            }\r\n            if (number == pool.lastRewardBlock) {\r\n                return user.amount.mul(accMdxPerShare).div(1e12).sub(user.rewardDebt);\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    // Deposit LP tokens to CoinChef for MDX allocation.\r\n    function deposit(uint256 _pid, uint256 _amount) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (isSushiLP(address(pool.lpToken))) {\r\n            depositMdxAndSushi(_pid, _amount, msg.sender);\r\n        } else {\r\n            depositMdx(_pid, _amount, msg.sender);\r\n        }\r\n    }\r\n\r\n    function depositMdxAndSushi(uint256 _pid, uint256 _amount, address _user) private {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        updatePool(_pid);\r\n        if (user.amount > 0) {\r\n            uint256 pendingAmount = user.amount.mul(pool.accMdxPerShare).div(1e12).sub(user.rewardDebt);\r\n            if (pendingAmount > 0) {\r\n                safeMdxTransfer(_user, pendingAmount);\r\n            }\r\n            uint256 beforeSushi = IERC20(sushiToken).balanceOf(address(this));\r\n            IMasterChef(sushiChef).deposit(poolCorrespond[_pid], 0);\r\n            uint256 afterSushi = IERC20(sushiToken).balanceOf(address(this));\r\n            pool.accSushiPerShare = pool.accSushiPerShare.add(afterSushi.sub(beforeSushi).mul(1e12).div(pool.totalAmount));\r\n            uint256 sushiPending = user.amount.mul(pool.accSushiPerShare).div(1e12).sub(user.sushiRewardDebt);\r\n            if (sushiPending > 0) {\r\n                IERC20(sushiToken).safeTransfer(_user, sushiPending);\r\n            }\r\n        }\r\n        if (_amount > 0) {\r\n            pool.lpToken.safeTransferFrom(_user, address(this), _amount);\r\n            if (pool.totalAmount == 0) {\r\n                IMasterChef(sushiChef).deposit(poolCorrespond[_pid], _amount);\r\n                pool.totalAmount = pool.totalAmount.add(_amount);\r\n                user.amount = user.amount.add(_amount);\r\n            } else {\r\n                uint256 beforeSushi = IERC20(sushiToken).balanceOf(address(this));\r\n                IMasterChef(sushiChef).deposit(poolCorrespond[_pid], _amount);\r\n                uint256 afterSushi = IERC20(sushiToken).balanceOf(address(this));\r\n                pool.accSushiPerShare = pool.accSushiPerShare.add(afterSushi.sub(beforeSushi).mul(1e12).div(pool.totalAmount));\r\n                pool.totalAmount = pool.totalAmount.add(_amount);\r\n                user.amount = user.amount.add(_amount);\r\n            }\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accMdxPerShare).div(1e12);\r\n        user.sushiRewardDebt = user.amount.mul(pool.accSushiPerShare).div(1e12);\r\n        emit Deposit(_user, _pid, _amount);\r\n    }\r\n\r\n    function depositMdx(uint256 _pid, uint256 _amount, address _user) private {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        updatePool(_pid);\r\n        if (user.amount > 0) {\r\n            uint256 pendingAmount = user.amount.mul(pool.accMdxPerShare).div(1e12).sub(user.rewardDebt);\r\n            if (pendingAmount > 0) {\r\n                safeMdxTransfer(_user, pendingAmount);\r\n            }\r\n        }\r\n        if (_amount > 0) {\r\n            pool.lpToken.safeTransferFrom(_user, address(this), _amount);\r\n            user.amount = user.amount.add(_amount);\r\n            pool.totalAmount = pool.totalAmount.add(_amount);\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accMdxPerShare).div(1e12);\r\n        emit Deposit(_user, _pid, _amount);\r\n    }\r\n\r\n    // Withdraw LP tokens from CoinChef.\r\n    function withdraw(uint256 _pid, uint256 _amount) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (isSushiLP(address(pool.lpToken))) {\r\n            withdrawMdxAndSushi(_pid, _amount, msg.sender);\r\n        } else {\r\n            withdrawMdx(_pid, _amount, msg.sender);\r\n        }\r\n    }\r\n\r\n    function withdrawMdxAndSushi(uint256 _pid, uint256 _amount, address _user) private {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        require(user.amount >= _amount, \"withdrawMdxAndSushi: not good\");\r\n        updatePool(_pid);\r\n        uint256 pendingAmount = user.amount.mul(pool.accMdxPerShare).div(1e12).sub(user.rewardDebt);\r\n        if (pendingAmount > 0) {\r\n            safeMdxTransfer(_user, pendingAmount);\r\n        }\r\n        if (_amount > 0) {\r\n            uint256 beforeSushi = IERC20(sushiToken).balanceOf(address(this));\r\n            IMasterChef(sushiChef).withdraw(poolCorrespond[_pid], _amount);\r\n            uint256 afterSushi = IERC20(sushiToken).balanceOf(address(this));\r\n            pool.accSushiPerShare = pool.accSushiPerShare.add(afterSushi.sub(beforeSushi).mul(1e12).div(pool.totalAmount));\r\n            uint256 sushiPending = user.amount.mul(pool.accSushiPerShare).div(1e12).sub(user.sushiRewardDebt);\r\n            if (sushiPending > 0) {\r\n                IERC20(sushiToken).safeTransfer(_user, sushiPending);\r\n            }\r\n            user.amount = user.amount.sub(_amount);\r\n            pool.totalAmount = pool.totalAmount.sub(_amount);\r\n            pool.lpToken.safeTransfer(_user, _amount);\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accMdxPerShare).div(1e12);\r\n        user.sushiRewardDebt = user.amount.mul(pool.accSushiPerShare).div(1e12);\r\n        emit Withdraw(_user, _pid, _amount);\r\n    }\r\n\r\n    function withdrawMdx(uint256 _pid, uint256 _amount, address _user) private {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        require(user.amount >= _amount, \"withdrawMdx: not good\");\r\n        updatePool(_pid);\r\n        uint256 pendingAmount = user.amount.mul(pool.accMdxPerShare).div(1e12).sub(user.rewardDebt);\r\n        if (pendingAmount > 0) {\r\n            safeMdxTransfer(_user, pendingAmount);\r\n        }\r\n        if (_amount > 0) {\r\n            user.amount = user.amount.sub(_amount);\r\n            pool.totalAmount = pool.totalAmount.sub(_amount);\r\n            pool.lpToken.safeTransfer(_user, _amount);\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accMdxPerShare).div(1e12);\r\n        emit Withdraw(_user, _pid, _amount);\r\n    }\r\n\r\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\r\n    function emergencyWithdraw(uint256 _pid) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (isSushiLP(address(pool.lpToken))) {\r\n            emergencyWithdrawMdxAndSushi(_pid, msg.sender);\r\n        } else {\r\n            emergencyWithdrawMdx(_pid, msg.sender);\r\n        }\r\n    }\r\n\r\n    function emergencyWithdrawMdxAndSushi(uint256 _pid, address _user) private {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        uint256 amount = user.amount;\r\n        uint256 beforeSushi = IERC20(sushiToken).balanceOf(address(this));\r\n        IMasterChef(sushiChef).withdraw(poolCorrespond[_pid], amount);\r\n        uint256 afterSushi = IERC20(sushiToken).balanceOf(address(this));\r\n        pool.accSushiPerShare = pool.accSushiPerShare.add(afterSushi.sub(beforeSushi).mul(1e12).div(pool.totalAmount));\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n        pool.lpToken.safeTransfer(_user, amount);\r\n        pool.totalAmount = pool.totalAmount.sub(amount);\r\n        emit EmergencyWithdraw(_user, _pid, amount);\r\n    }\r\n\r\n    function emergencyWithdrawMdx(uint256 _pid, address _user) private {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        uint256 amount = user.amount;\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n        pool.lpToken.safeTransfer(_user, amount);\r\n        pool.totalAmount = pool.totalAmount.sub(amount);\r\n        emit EmergencyWithdraw(_user, _pid, amount);\r\n    }\r\n\r\n    // Safe MDX transfer function, just in case if rounding error causes pool to not have enough MDXs.\r\n    function safeMdxTransfer(address _to, uint256 _amount) internal {\r\n        uint256 mdxBal = mdx.balanceOf(address(this));\r\n        if (_amount > mdxBal) {\r\n            mdx.transfer(_to, mdxBal);\r\n        } else {\r\n            mdx.transfer(_to, _amount);\r\n        }\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/swap/interface/IMdx.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.6;\r\n\r\nimport {IERC20 as SIERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IMdx is SIERC20 {\r\n    function mint(address to, uint256 amount) external returns (bool);\r\n}\r\n"
    },
    "contracts/swap/heco/SwapMining.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.6;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\r\nimport \"../interface/IERC20.sol\";\r\nimport \"../library/SafeMath.sol\";\r\n\r\nimport \"../../common/IMdexFactory.sol\";\r\nimport \"../../common/IMdexPair.sol\";\r\n\r\nimport \"../interface/IMdx.sol\";\r\n\r\ninterface IOracle {\r\n    function update(address tokenA, address tokenB) external;\r\n\r\n    function consult(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut);\r\n}\r\n\r\ncontract SwapMining is Ownable {\r\n    using SafeMath for uint256;\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    EnumerableSet.AddressSet private _whitelist;\r\n\r\n    // MDX tokens created per block\r\n    uint256 public mdxPerBlock;\r\n    // The block number when MDX mining starts.\r\n    uint256 public startBlock;\r\n    // How many blocks are halved\r\n    uint256 public halvingPeriod = 5256000;\r\n    // Total allocation points\r\n    uint256 public totalAllocPoint = 0;\r\n    IOracle public oracle;\r\n    // router address\r\n    address public router;\r\n    // factory address\r\n    IMdexFactory public factory;\r\n    // mdx token address\r\n    IMdx public mdx;\r\n    // Calculate price based on HUSD\r\n    address public targetToken;\r\n    // pair corresponding pid\r\n    mapping(address => uint256) public pairOfPid;\r\n\r\n    constructor(\r\n        IMdx _mdx,\r\n        IMdexFactory _factory,\r\n        IOracle _oracle,\r\n        address _router,\r\n        address _targetToken,\r\n        uint256 _mdxPerBlock,\r\n        uint256 _startBlock\r\n    ) {\r\n        mdx = _mdx;\r\n        factory = _factory;\r\n        oracle = _oracle;\r\n        router = _router;\r\n        targetToken = _targetToken;\r\n        mdxPerBlock = _mdxPerBlock;\r\n        startBlock = _startBlock;\r\n    }\r\n\r\n    struct UserInfo {\r\n        uint256 quantity;       // How many LP tokens the user has provided\r\n        uint256 blockNumber;    // Last transaction block\r\n    }\r\n\r\n    struct PoolInfo {\r\n        address pair;           // Trading pairs that can be mined\r\n        uint256 quantity;       // Current amount of LPs\r\n        uint256 totalQuantity;  // All quantity\r\n        uint256 allocPoint;     // How many allocation points assigned to this pool\r\n        uint256 allocMdxAmount; // How many MDXs\r\n        uint256 lastRewardBlock;// Last transaction block\r\n    }\r\n\r\n    PoolInfo[] public poolInfo;\r\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n\r\n\r\n    function poolLength() public view returns (uint256) {\r\n        return poolInfo.length;\r\n    }\r\n\r\n\r\n    function addPair(uint256 _allocPoint, address _pair, bool _withUpdate) public onlyOwner {\r\n        require(_pair != address(0), \"_pair is the zero address\");\r\n        if (_withUpdate) {\r\n            massMintPools();\r\n        }\r\n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\r\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\r\n        poolInfo.push(PoolInfo({\r\n        pair : _pair,\r\n        quantity : 0,\r\n        totalQuantity : 0,\r\n        allocPoint : _allocPoint,\r\n        allocMdxAmount : 0,\r\n        lastRewardBlock : lastRewardBlock\r\n        }));\r\n        pairOfPid[_pair] = poolLength() - 1;\r\n    }\r\n\r\n    // Update the allocPoint of the pool\r\n    function setPair(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner {\r\n        if (_withUpdate) {\r\n            massMintPools();\r\n        }\r\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\r\n        poolInfo[_pid].allocPoint = _allocPoint;\r\n    }\r\n\r\n    // Set the number of mdx produced by each block\r\n    function setMdxPerBlock(uint256 _newPerBlock) public onlyOwner {\r\n        massMintPools();\r\n        mdxPerBlock = _newPerBlock;\r\n    }\r\n\r\n    // Only tokens in the whitelist can be mined MDX\r\n    function addWhitelist(address _addToken) public onlyOwner returns (bool) {\r\n        require(_addToken != address(0), \"SwapMining: token is the zero address\");\r\n        return EnumerableSet.add(_whitelist, _addToken);\r\n    }\r\n\r\n    function delWhitelist(address _delToken) public onlyOwner returns (bool) {\r\n        require(_delToken != address(0), \"SwapMining: token is the zero address\");\r\n        return EnumerableSet.remove(_whitelist, _delToken);\r\n    }\r\n\r\n    function getWhitelistLength() public view returns (uint256) {\r\n        return EnumerableSet.length(_whitelist);\r\n    }\r\n\r\n    function isWhitelist(address _token) public view returns (bool) {\r\n        return EnumerableSet.contains(_whitelist, _token);\r\n    }\r\n\r\n    function getWhitelist(uint256 _index) public view returns (address){\r\n        require(_index <= getWhitelistLength() - 1, \"SwapMining: index out of bounds\");\r\n        return EnumerableSet.at(_whitelist, _index);\r\n    }\r\n\r\n    function setHalvingPeriod(uint256 _block) public onlyOwner {\r\n        halvingPeriod = _block;\r\n    }\r\n\r\n    function setRouter(address newRouter) public onlyOwner {\r\n        require(newRouter != address(0), \"SwapMining: new router is the zero address\");\r\n        router = newRouter;\r\n    }\r\n\r\n    function setOracle(IOracle _oracle) public onlyOwner {\r\n        require(address(_oracle) != address(0), \"SwapMining: new oracle is the zero address\");\r\n        oracle = _oracle;\r\n    }\r\n\r\n    // At what phase\r\n    function phase(uint256 blockNumber) public view returns (uint256) {\r\n        if (halvingPeriod == 0) {\r\n            return 0;\r\n        }\r\n        if (blockNumber > startBlock) {\r\n            return (blockNumber.sub(startBlock).sub(1)).div(halvingPeriod);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function phase() public view returns (uint256) {\r\n        return phase(block.number);\r\n    }\r\n\r\n    function reward(uint256 blockNumber) public view returns (uint256) {\r\n        uint256 _phase = phase(blockNumber);\r\n        return mdxPerBlock.div(2 ** _phase);\r\n    }\r\n\r\n    function reward() public view returns (uint256) {\r\n        return reward(block.number);\r\n    }\r\n\r\n    // Rewards for the current block\r\n    function getMdxReward(uint256 _lastRewardBlock) public view returns (uint256) {\r\n        require(_lastRewardBlock <= block.number, \"SwapMining: must little than the current block number\");\r\n        uint256 blockReward = 0;\r\n        uint256 n = phase(_lastRewardBlock);\r\n        uint256 m = phase(block.number);\r\n        // If it crosses the cycle\r\n        while (n < m) {\r\n            n++;\r\n            // Get the last block of the previous cycle\r\n            uint256 r = n.mul(halvingPeriod).add(startBlock);\r\n            // Get rewards from previous periods\r\n            blockReward = blockReward.add((r.sub(_lastRewardBlock)).mul(reward(r)));\r\n            _lastRewardBlock = r;\r\n        }\r\n        blockReward = blockReward.add((block.number.sub(_lastRewardBlock)).mul(reward(block.number)));\r\n        return blockReward;\r\n    }\r\n\r\n    // Update all pools Called when updating allocPoint and setting new blocks\r\n    function massMintPools() public {\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            mint(pid);\r\n        }\r\n    }\r\n\r\n    function mint(uint256 _pid) public returns (bool) {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (block.number <= pool.lastRewardBlock) {\r\n            return false;\r\n        }\r\n        uint256 blockReward = getMdxReward(pool.lastRewardBlock);\r\n        if (blockReward <= 0) {\r\n            return false;\r\n        }\r\n        // Calculate the rewards obtained by the pool based on the allocPoint\r\n        uint256 mdxReward = blockReward.mul(pool.allocPoint).div(totalAllocPoint);\r\n        mdx.mint(address(this), mdxReward);\r\n        // Increase the number of tokens in the current pool\r\n        pool.allocMdxAmount = pool.allocMdxAmount.add(mdxReward);\r\n        pool.lastRewardBlock = block.number;\r\n        return true;\r\n    }\r\n\r\n    // swapMining only router\r\n    function swap(address account, address input, address output, uint256 amount) public onlyRouter returns (bool) {\r\n        require(account != address(0), \"SwapMining: taker swap account is the zero address\");\r\n        require(input != address(0), \"SwapMining: taker swap input is the zero address\");\r\n        require(output != address(0), \"SwapMining: taker swap output is the zero address\");\r\n\r\n        if (poolLength() <= 0) {\r\n            return false;\r\n        }\r\n\r\n        if (!isWhitelist(input) || !isWhitelist(output)) {\r\n            return false;\r\n        }\r\n\r\n        address pair = IMdexFactory(factory).pairFor(input, output);\r\n\r\n        PoolInfo storage pool = poolInfo[pairOfPid[pair]];\r\n        // If it does not exist or the allocPoint is 0 then return\r\n        if (pool.pair != pair || pool.allocPoint <= 0) {\r\n            return false;\r\n        }\r\n\r\n        uint256 quantity = getQuantity(output, amount, targetToken);\r\n        if (quantity <= 0) {\r\n            return false;\r\n        }\r\n\r\n        mint(pairOfPid[pair]);\r\n\r\n        pool.quantity = pool.quantity.add(quantity);\r\n        pool.totalQuantity = pool.totalQuantity.add(quantity);\r\n        UserInfo storage user = userInfo[pairOfPid[pair]][account];\r\n        user.quantity = user.quantity.add(quantity);\r\n        user.blockNumber = block.number;\r\n        return true;\r\n    }\r\n\r\n    // The user withdraws all the transaction rewards of the pool\r\n    function takerWithdraw() public {\r\n        uint256 userSub;\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            PoolInfo storage pool = poolInfo[pid];\r\n            UserInfo storage user = userInfo[pid][msg.sender];\r\n            if (user.quantity > 0) {\r\n                mint(pid);\r\n                // The reward held by the user in this pool\r\n                uint256 userReward = pool.allocMdxAmount.mul(user.quantity).div(pool.quantity);\r\n                pool.quantity = pool.quantity.sub(user.quantity);\r\n                pool.allocMdxAmount = pool.allocMdxAmount.sub(userReward);\r\n                user.quantity = 0;\r\n                user.blockNumber = block.number;\r\n                userSub = userSub.add(userReward);\r\n            }\r\n        }\r\n        if (userSub <= 0) {\r\n            return;\r\n        }\r\n        mdx.transfer(msg.sender, userSub);\r\n    }\r\n\r\n    // Get rewards from users in the current pool\r\n    function getUserReward(uint256 _pid) public view returns (uint256, uint256){\r\n        require(_pid <= poolInfo.length - 1, \"SwapMining: Not find this pool\");\r\n        uint256 userSub;\r\n        PoolInfo memory pool = poolInfo[_pid];\r\n        UserInfo memory user = userInfo[_pid][msg.sender];\r\n        if (user.quantity > 0) {\r\n            uint256 blockReward = getMdxReward(pool.lastRewardBlock);\r\n            uint256 mdxReward = blockReward.mul(pool.allocPoint).div(totalAllocPoint);\r\n            userSub = userSub.add((pool.allocMdxAmount.add(mdxReward)).mul(user.quantity).div(pool.quantity));\r\n        }\r\n        //Mdx available to users, User transaction amount\r\n        return (userSub, user.quantity);\r\n    }\r\n\r\n    // Get details of the pool\r\n    function getPoolInfo(uint256 _pid) public view returns (address, address, uint256, uint256, uint256, uint256){\r\n        require(_pid <= poolInfo.length - 1, \"SwapMining: Not find this pool\");\r\n        PoolInfo memory pool = poolInfo[_pid];\r\n        address token0 = IMdexPair(pool.pair).token0();\r\n        address token1 = IMdexPair(pool.pair).token1();\r\n        uint256 mdxAmount = pool.allocMdxAmount;\r\n        uint256 blockReward = getMdxReward(pool.lastRewardBlock);\r\n        uint256 mdxReward = blockReward.mul(pool.allocPoint).div(totalAllocPoint);\r\n        mdxAmount = mdxAmount.add(mdxReward);\r\n        //token0,token1,Pool remaining reward,Total /Current transaction volume of the pool\r\n        return (token0, token1, mdxAmount, pool.totalQuantity, pool.quantity, pool.allocPoint);\r\n    }\r\n\r\n    modifier onlyRouter() {\r\n        require(msg.sender == router, \"SwapMining: caller is not the router\");\r\n        _;\r\n    }\r\n\r\n    function getQuantity(address outputToken, uint256 outputAmount, address anchorToken) public view returns (uint256) {\r\n        uint256 quantity = 0;\r\n        if (outputToken == anchorToken) {\r\n            quantity = outputAmount;\r\n        } else if (IMdexFactory(factory).getPair(outputToken, anchorToken) != address(0)) {\r\n            quantity = IOracle(oracle).consult(outputToken, outputAmount, anchorToken);\r\n        } else {\r\n            uint256 length = getWhitelistLength();\r\n            for (uint256 index = 0; index < length; index++) {\r\n                address intermediate = getWhitelist(index);\r\n                if (IMdexFactory(factory).getPair(outputToken, intermediate) != address(0) && IMdexFactory(factory).getPair(intermediate, anchorToken) != address(0)) {\r\n                    uint256 interQuantity = IOracle(oracle).consult(outputToken, outputAmount, intermediate);\r\n                    quantity = IOracle(oracle).consult(intermediate, interQuantity, anchorToken);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return quantity;\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/swap/interface/IERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity =0.7.6;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n"
    },
    "contracts/swap/library/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity =0.7.6;\r\n\r\nlibrary SafeMath {\r\n    uint256 constant WAD = 10 ** 18;\r\n    uint256 constant RAY = 10 ** 27;\r\n\r\n    function wad() public pure returns (uint256) {\r\n        return WAD;\r\n    }\r\n\r\n    function ray() public pure returns (uint256) {\r\n        return RAY;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a <= b ? a : b;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function sqrt(uint256 a) internal pure returns (uint256 b) {\r\n        if (a > 3) {\r\n            b = a;\r\n            uint256 x = a / 2 + 1;\r\n            while (x < b) {\r\n                b = x;\r\n                x = (a / x + x) / 2;\r\n            }\r\n        } else if (a != 0) {\r\n            b = 1;\r\n        }\r\n    }\r\n\r\n    function wmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mul(a, b) / WAD;\r\n    }\r\n\r\n    function wmulRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, b), WAD / 2) / WAD;\r\n    }\r\n\r\n    function rmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mul(a, b) / RAY;\r\n    }\r\n\r\n    function rmulRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, b), RAY / 2) / RAY;\r\n    }\r\n\r\n    function wdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(mul(a, WAD), b);\r\n    }\r\n\r\n    function wdivRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, WAD), b / 2) / b;\r\n    }\r\n\r\n    function rdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(mul(a, RAY), b);\r\n    }\r\n\r\n    function rdivRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, RAY), b / 2) / b;\r\n    }\r\n\r\n    function wpow(uint256 x, uint256 n) internal pure returns (uint256) {\r\n        uint256 result = WAD;\r\n        while (n > 0) {\r\n            if (n % 2 != 0) {\r\n                result = wmul(result, x);\r\n            }\r\n            x = wmul(x, x);\r\n            n /= 2;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256) {\r\n        uint256 result = RAY;\r\n        while (n > 0) {\r\n            if (n % 2 != 0) {\r\n                result = rmul(result, x);\r\n            }\r\n            x = rmul(x, x);\r\n            n /= 2;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n"
    },
    "contracts/common/IMdexFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity =0.7.6;\r\n\r\ninterface IMdexFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function feeToRate() external view returns (uint256);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function allPairs(uint) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n\r\n    function setFeeToRate(uint256) external;\r\n\r\n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, address token1);\r\n\r\n    function pairFor(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function getReserves(address tokenA, address tokenB) external view returns (uint256 reserveA, uint256 reserveB);\r\n\r\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint256 amountB);\r\n\r\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountOut);\r\n\r\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountIn);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\r\n}\r\n"
    },
    "contracts/common/IMdexPair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity =0.7.6;\r\n\r\ninterface IMdexPair {\r\n    // event Approval(address indexed owner, address indexed spender, uint value);\r\n    // event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function price0CumulativeLast() external view returns (uint);\r\n\r\n    function price1CumulativeLast() external view returns (uint);\r\n\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function mintCToken(address to) external returns (uint liquidity);\r\n\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function price(address token, uint256 baseDecimal) external view returns (uint256);\r\n\r\n    function initialize(address, address) external;\r\n    // initialize ctoken address\r\n    function initializeCTokenAddress(address, address) external;\r\n}\r\n"
    },
    "contracts/swap/oracle/Oracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity =0.7.6;\r\n\r\nimport \"../../common/IMdexFactory.sol\";\r\nimport \"../../common/IMdexPair.sol\";\r\n\r\nimport \"../../common/libraries/FixedPoint.sol\";\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n}\r\n\r\n// library FixedPoint {\r\n//     // range: [0, 2**112 - 1]\r\n//     // resolution: 1 / 2**112\r\n//     struct uq112x112 {\r\n//         uint224 _x;\r\n//     }\r\n\r\n//     // range: [0, 2**144 - 1]\r\n//     // resolution: 1 / 2**112\r\n//     struct uq144x112 {\r\n//         uint _x;\r\n//     }\r\n\r\n//     uint8 private constant RESOLUTION = 112;\r\n\r\n//     // encode a uint112 as a UQ112x112\r\n//     function encode(uint112 x) internal pure returns (uq112x112 memory) {\r\n//         return uq112x112(uint224(x) << RESOLUTION);\r\n//     }\r\n\r\n//     // encodes a uint144 as a UQ144x112\r\n//     function encode144(uint144 x) internal pure returns (uq144x112 memory) {\r\n//         return uq144x112(uint256(x) << RESOLUTION);\r\n//     }\r\n\r\n//     // divide a UQ112x112 by a uint112, returning a UQ112x112\r\n//     function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\r\n//         require(x != 0, 'FixedPoint: DIV_BY_ZERO');\r\n//         return uq112x112(self._x / uint224(x));\r\n//     }\r\n\r\n//     // multiply a UQ112x112 by a uint, returning a UQ144x112\r\n//     // reverts on overflow\r\n//     function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\r\n//         uint z;\r\n//         require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\r\n//         return uq144x112(z);\r\n//     }\r\n\r\n//     // returns a UQ112x112 which represents the ratio of the numerator to the denominator\r\n//     // equivalent to encode(numerator).div(denominator)\r\n//     function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\r\n//         require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\r\n//         return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\r\n//     }\r\n\r\n//     // decode a UQ112x112 into a uint112 by truncating after the radix point\r\n//     function decode(uq112x112 memory self) internal pure returns (uint112) {\r\n//         return uint112(self._x >> RESOLUTION);\r\n//     }\r\n\r\n//     // decode a UQ144x112 into a uint144 by truncating after the radix point\r\n//     function decode144(uq144x112 memory self) internal pure returns (uint144) {\r\n//         return uint144(self._x >> RESOLUTION);\r\n//     }\r\n// }\r\n\r\nlibrary MdexOracleLibrary {\r\n    using FixedPoint for *;\r\n\r\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\r\n    function currentBlockTimestamp() internal view returns (uint32) {\r\n        return uint32(block.timestamp % 2 ** 32);\r\n    }\r\n\r\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\r\n    function currentCumulativePrices(\r\n        address pair\r\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\r\n        blockTimestamp = currentBlockTimestamp();\r\n        price0Cumulative = IMdexPair(pair).price0CumulativeLast();\r\n        price1Cumulative = IMdexPair(pair).price1CumulativeLast();\r\n\r\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\r\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IMdexPair(pair).getReserves();\r\n        if (blockTimestampLast != blockTimestamp) {\r\n            // subtraction overflow is desired\r\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\r\n            // addition overflow is desired\r\n            // counterfactual\r\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\r\n            // counterfactual\r\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Oracle {\r\n    using FixedPoint for *;\r\n    using SafeMath for uint;\r\n\r\n    struct Observation {\r\n        uint timestamp;\r\n        uint price0Cumulative;\r\n        uint price1Cumulative;\r\n    }\r\n\r\n    address public immutable factory;\r\n    uint public constant CYCLE = 30 minutes;\r\n\r\n    // mapping from pair address to a list of price observations of that pair\r\n    mapping(address => Observation) public pairObservations;\r\n\r\n    constructor(address factory_) {\r\n        factory = factory_;\r\n    }\r\n\r\n\r\n    function update(address tokenA, address tokenB) external {\r\n        address pair = IMdexFactory(factory).pairFor(tokenA, tokenB);\r\n\r\n        Observation storage observation = pairObservations[pair];\r\n        uint timeElapsed = block.timestamp - observation.timestamp;\r\n        require(timeElapsed >= CYCLE, 'MDEXOracle: PERIOD_NOT_ELAPSED');\r\n        (uint price0Cumulative, uint price1Cumulative,) = MdexOracleLibrary.currentCumulativePrices(pair);\r\n        observation.timestamp = block.timestamp;\r\n        observation.price0Cumulative = price0Cumulative;\r\n        observation.price1Cumulative = price1Cumulative;\r\n    }\r\n\r\n\r\n    function computeAmountOut(\r\n        uint priceCumulativeStart, uint priceCumulativeEnd,\r\n        uint timeElapsed, uint amountIn\r\n    ) private pure returns (uint amountOut) {\r\n        // overflow is desired.\r\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(\r\n            uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\r\n        );\r\n        amountOut = priceAverage.mul(amountIn).decode144();\r\n    }\r\n\r\n\r\n    function consult(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut) {\r\n        address pair = IMdexFactory(factory).pairFor(tokenIn, tokenOut);\r\n        Observation storage observation = pairObservations[pair];\r\n        uint timeElapsed = block.timestamp - observation.timestamp;\r\n        (uint price0Cumulative, uint price1Cumulative,) = MdexOracleLibrary.currentCumulativePrices(pair);\r\n        (address token0,) = IMdexFactory(factory).sortTokens(tokenIn, tokenOut);\r\n\r\n        if (token0 == tokenIn) {\r\n            return computeAmountOut(observation.price0Cumulative, price0Cumulative, timeElapsed, amountIn);\r\n        } else {\r\n            return computeAmountOut(observation.price1Cumulative, price1Cumulative, timeElapsed, amountIn);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/common/libraries/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity >=0.4.0;\r\n\r\nimport './FullMath.sol';\r\nimport './Babylonian.sol';\r\nimport './BitMath.sol';\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\nlibrary FixedPoint {\r\n    // range: [0, 2**112 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq112x112 {\r\n        uint224 _x;\r\n    }\r\n\r\n    // range: [0, 2**144 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq144x112 {\r\n        uint256 _x;\r\n    }\r\n\r\n    uint8 public constant RESOLUTION = 112;\r\n    uint256 public constant Q112 = 0x10000000000000000000000000000; // 2**112\r\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000; // 2**224\r\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\r\n        return uq112x112(uint224(x) << RESOLUTION);\r\n    }\r\n\r\n    // encodes a uint144 as a UQ144x112\r\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\r\n        return uq144x112(uint256(x) << RESOLUTION);\r\n    }\r\n\r\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\r\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\r\n        return uint112(self._x >> RESOLUTION);\r\n    }\r\n\r\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\r\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\r\n        return uint144(self._x >> RESOLUTION);\r\n    }\r\n\r\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\r\n    // reverts on overflow\r\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\r\n        uint256 z = 0;\r\n        require(y == 0 || (z = self._x * y) / y == self._x, 'FixedPoint::mul: overflow');\r\n        return uq144x112(z);\r\n    }\r\n\r\n    // multiply a UQ112x112 by an int and decode, returning an int\r\n    // reverts on overflow\r\n    function muli(uq112x112 memory self, int256 y) internal pure returns (int256) {\r\n        uint256 z = FullMath.mulDiv(self._x, uint256(y < 0 ? -y : y), Q112);\r\n        require(z < 2**255, 'FixedPoint::muli: overflow');\r\n        return y < 0 ? -int256(z) : int256(z);\r\n    }\r\n\r\n    // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\r\n    // lossy\r\n    function muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\r\n        if (self._x == 0 || other._x == 0) {\r\n            return uq112x112(0);\r\n        }\r\n        uint112 upper_self = uint112(self._x >> RESOLUTION); // * 2^0\r\n        uint112 lower_self = uint112(self._x & LOWER_MASK); // * 2^-112\r\n        uint112 upper_other = uint112(other._x >> RESOLUTION); // * 2^0\r\n        uint112 lower_other = uint112(other._x & LOWER_MASK); // * 2^-112\r\n\r\n        // partial products\r\n        uint224 upper = uint224(upper_self) * upper_other; // * 2^0\r\n        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224\r\n        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112\r\n        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112\r\n\r\n        // so the bit shift does not overflow\r\n        require(upper <= uint112(-1), 'FixedPoint::muluq: upper overflow');\r\n\r\n        // this cannot exceed 256 bits, all values are 224 bits\r\n        uint256 sum = uint256(upper << RESOLUTION) + uppers_lowero + uppero_lowers + (lower >> RESOLUTION);\r\n\r\n        // so the cast does not overflow\r\n        require(sum <= uint224(-1), 'FixedPoint::muluq: sum overflow');\r\n\r\n        return uq112x112(uint224(sum));\r\n    }\r\n\r\n    // divide a UQ112x112 by a UQ112x112, returning a UQ112x112\r\n    function divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\r\n        require(other._x > 0, 'FixedPoint::divuq: division by zero');\r\n        if (self._x == other._x) {\r\n            return uq112x112(uint224(Q112));\r\n        }\r\n        if (self._x <= uint144(-1)) {\r\n            uint256 value = (uint256(self._x) << RESOLUTION) / other._x;\r\n            require(value <= uint224(-1), 'FixedPoint::divuq: overflow');\r\n            return uq112x112(uint224(value));\r\n        }\r\n\r\n        uint256 result = FullMath.mulDiv(Q112, self._x, other._x);\r\n        require(result <= uint224(-1), 'FixedPoint::divuq: overflow');\r\n        return uq112x112(uint224(result));\r\n    }\r\n\r\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\r\n    // can be lossy\r\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\r\n        require(denominator > 0, 'FixedPoint::fraction: division by zero');\r\n        if (numerator == 0) return FixedPoint.uq112x112(0);\r\n\r\n        if (numerator <= uint144(-1)) {\r\n            uint256 result = (numerator << RESOLUTION) / denominator;\r\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\r\n            return uq112x112(uint224(result));\r\n        } else {\r\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\r\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\r\n            return uq112x112(uint224(result));\r\n        }\r\n    }\r\n\r\n    // take the reciprocal of a UQ112x112\r\n    // reverts on overflow\r\n    // lossy\r\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\r\n        require(self._x != 0, 'FixedPoint::reciprocal: reciprocal of zero');\r\n        require(self._x != 1, 'FixedPoint::reciprocal: overflow');\r\n        return uq112x112(uint224(Q224 / self._x));\r\n    }\r\n\r\n    // square root of a UQ112x112\r\n    // lossy between 0/1 and 40 bits\r\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\r\n        if (self._x <= uint144(-1)) {\r\n            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\r\n        }\r\n\r\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\r\n        safeShiftBits -= safeShiftBits % 2;\r\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << safeShiftBits) << ((112 - safeShiftBits) / 2)));\r\n    }\r\n}\r\n"
    },
    "contracts/common/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: CC-BY-4.0\r\npragma solidity >=0.4.0;\r\n\r\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\r\n// license is CC-BY-4.0\r\nlibrary FullMath {\r\n    function fullMul(uint256 x, uint256 y) internal pure returns (uint256 l, uint256 h) {\r\n        uint256 mm = mulmod(x, y, uint256(-1));\r\n        l = x * y;\r\n        h = mm - l;\r\n        if (mm < l) h -= 1;\r\n    }\r\n\r\n    function fullDiv(\r\n        uint256 l,\r\n        uint256 h,\r\n        uint256 d\r\n    ) private pure returns (uint256) {\r\n        uint256 pow2 = d & -d;\r\n        d /= pow2;\r\n        l /= pow2;\r\n        l += h * ((-pow2) / pow2 + 1);\r\n        uint256 r = 1;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        return l * r;\r\n    }\r\n\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 d\r\n    ) internal pure returns (uint256) {\r\n        (uint256 l, uint256 h) = fullMul(x, y);\r\n\r\n        uint256 mm = mulmod(x, y, d);\r\n        if (mm > l) h -= 1;\r\n        l -= mm;\r\n\r\n        if (h == 0) return l / d;\r\n\r\n        require(h < d, 'FullMath: FULLDIV_OVERFLOW');\r\n        return fullDiv(l, h, d);\r\n    }\r\n}\r\n"
    },
    "contracts/common/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity >=0.4.0;\r\n\r\n// computes square roots using the babylonian method\r\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\r\nlibrary Babylonian {\r\n    // credit for this implementation goes to\r\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\r\n    function sqrt(uint256 x) internal pure returns (uint256) {\r\n        if (x == 0) return 0;\r\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\r\n        // however that code costs significantly more gas\r\n        uint256 xx = x;\r\n        uint256 r = 1;\r\n        if (xx >= 0x100000000000000000000000000000000) {\r\n            xx >>= 128;\r\n            r <<= 64;\r\n        }\r\n        if (xx >= 0x10000000000000000) {\r\n            xx >>= 64;\r\n            r <<= 32;\r\n        }\r\n        if (xx >= 0x100000000) {\r\n            xx >>= 32;\r\n            r <<= 16;\r\n        }\r\n        if (xx >= 0x10000) {\r\n            xx >>= 16;\r\n            r <<= 8;\r\n        }\r\n        if (xx >= 0x100) {\r\n            xx >>= 8;\r\n            r <<= 4;\r\n        }\r\n        if (xx >= 0x10) {\r\n            xx >>= 4;\r\n            r <<= 2;\r\n        }\r\n        if (xx >= 0x8) {\r\n            r <<= 1;\r\n        }\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1; // Seven iterations should be enough\r\n        uint256 r1 = x / r;\r\n        return (r < r1 ? r : r1);\r\n    }\r\n}\r\n"
    },
    "contracts/common/libraries/BitMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\nlibrary BitMath {\r\n    // returns the 0 indexed position of the most significant bit of the input x\r\n    // s.t. x >= 2**msb and x < 2**(msb+1)\r\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\r\n        require(x > 0, 'BitMath::mostSignificantBit: zero');\r\n\r\n        if (x >= 0x100000000000000000000000000000000) {\r\n            x >>= 128;\r\n            r += 128;\r\n        }\r\n        if (x >= 0x10000000000000000) {\r\n            x >>= 64;\r\n            r += 64;\r\n        }\r\n        if (x >= 0x100000000) {\r\n            x >>= 32;\r\n            r += 32;\r\n        }\r\n        if (x >= 0x10000) {\r\n            x >>= 16;\r\n            r += 16;\r\n        }\r\n        if (x >= 0x100) {\r\n            x >>= 8;\r\n            r += 8;\r\n        }\r\n        if (x >= 0x10) {\r\n            x >>= 4;\r\n            r += 4;\r\n        }\r\n        if (x >= 0x4) {\r\n            x >>= 2;\r\n            r += 2;\r\n        }\r\n        if (x >= 0x2) r += 1;\r\n    }\r\n\r\n    // returns the 0 indexed position of the least significant bit of the input x\r\n    // s.t. (x & 2**lsb) != 0 and (x & (2**(lsb) - 1)) == 0)\r\n    // i.e. the bit at the index is set and the mask of all lower bits is 0\r\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\r\n        require(x > 0, 'BitMath::leastSignificantBit: zero');\r\n\r\n        r = 255;\r\n        if (x & uint128(-1) > 0) {\r\n            r -= 128;\r\n        } else {\r\n            x >>= 128;\r\n        }\r\n        if (x & uint64(-1) > 0) {\r\n            r -= 64;\r\n        } else {\r\n            x >>= 64;\r\n        }\r\n        if (x & uint32(-1) > 0) {\r\n            r -= 32;\r\n        } else {\r\n            x >>= 32;\r\n        }\r\n        if (x & uint16(-1) > 0) {\r\n            r -= 16;\r\n        } else {\r\n            x >>= 16;\r\n        }\r\n        if (x & uint8(-1) > 0) {\r\n            r -= 8;\r\n        } else {\r\n            x >>= 8;\r\n        }\r\n        if (x & 0xf > 0) {\r\n            r -= 4;\r\n        } else {\r\n            x >>= 4;\r\n        }\r\n        if (x & 0x3 > 0) {\r\n            r -= 2;\r\n        } else {\r\n            x >>= 2;\r\n        }\r\n        if (x & 0x1 > 0) r -= 1;\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/libraries/UniswapV2OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.5.0;\r\n\r\nimport '../../common/IMdexPair.sol';\r\nimport '../../common/libraries/FixedPoint.sol';\r\n\r\n// library with helper methods for oracles that are concerned with computing average prices\r\nlibrary UniswapV2OracleLibrary {\r\n    using FixedPoint for *;\r\n\r\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\r\n    function currentBlockTimestamp() internal view returns (uint32) {\r\n        return uint32(block.timestamp % 2 ** 32);\r\n    }\r\n\r\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\r\n    function currentCumulativePrices(\r\n        address pair\r\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\r\n        blockTimestamp = currentBlockTimestamp();\r\n        price0Cumulative = IMdexPair(pair).price0CumulativeLast();\r\n        price1Cumulative = IMdexPair(pair).price1CumulativeLast();\r\n\r\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\r\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IMdexPair(pair).getReserves();\r\n        if (blockTimestampLast != blockTimestamp) {\r\n            // subtraction overflow is desired\r\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\r\n            // addition overflow is desired\r\n            // counterfactual\r\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\r\n            // counterfactual\r\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/libraries/UniswapV2LiquidityMathLibrary.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.5.0;\r\n\r\nimport '../../common/IMdexPair.sol';\r\nimport '../../common/IMdexFactory.sol';\r\nimport '../../common/libraries/Babylonian.sol';\r\nimport '../../common/libraries/FullMath.sol';\r\n\r\nimport './SafeMath.sol';\r\nimport './UniswapV2Library.sol';\r\n\r\n// library containing some math for dealing with the liquidity shares of a pair, e.g. computing their exact value\r\n// in terms of the underlying tokens\r\nlibrary UniswapV2LiquidityMathLibrary {\r\n    using SafeMath for uint256;\r\n\r\n    // computes the direction and magnitude of the profit-maximizing trade\r\n    function computeProfitMaximizingTrade(\r\n        uint256 truePriceTokenA,\r\n        uint256 truePriceTokenB,\r\n        uint256 reserveA,\r\n        uint256 reserveB\r\n    ) pure internal returns (bool aToB, uint256 amountIn) {\r\n        aToB = FullMath.mulDiv(reserveA, truePriceTokenB, reserveB) < truePriceTokenA;\r\n\r\n        uint256 invariant = reserveA.mul(reserveB);\r\n\r\n        uint256 leftSide = Babylonian.sqrt(\r\n            FullMath.mulDiv(\r\n                invariant.mul(1000),\r\n                aToB ? truePriceTokenA : truePriceTokenB,\r\n                (aToB ? truePriceTokenB : truePriceTokenA).mul(997)\r\n            )\r\n        );\r\n        uint256 rightSide = (aToB ? reserveA.mul(1000) : reserveB.mul(1000)) / 997;\r\n\r\n        if (leftSide < rightSide) return (false, 0);\r\n\r\n        // compute the amount that must be sent to move the price to the profit-maximizing price\r\n        amountIn = leftSide.sub(rightSide);\r\n    }\r\n\r\n    // gets the reserves after an arbitrage moves the price to the profit-maximizing ratio given an externally observed true price\r\n    function getReservesAfterArbitrage(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 truePriceTokenA,\r\n        uint256 truePriceTokenB\r\n    ) view internal returns (uint256 reserveA, uint256 reserveB) {\r\n        // first get reserves before the swap\r\n        (reserveA, reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\r\n\r\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2ArbitrageLibrary: ZERO_PAIR_RESERVES');\r\n\r\n        // then compute how much to swap to arb to the true price\r\n        (bool aToB, uint256 amountIn) = computeProfitMaximizingTrade(truePriceTokenA, truePriceTokenB, reserveA, reserveB);\r\n\r\n        if (amountIn == 0) {\r\n            return (reserveA, reserveB);\r\n        }\r\n\r\n        // now affect the trade to the reserves\r\n        if (aToB) {\r\n            uint amountOut = UniswapV2Library.getAmountOut(amountIn, reserveA, reserveB);\r\n            reserveA += amountIn;\r\n            reserveB -= amountOut;\r\n        } else {\r\n            uint amountOut = UniswapV2Library.getAmountOut(amountIn, reserveB, reserveA);\r\n            reserveB += amountIn;\r\n            reserveA -= amountOut;\r\n        }\r\n    }\r\n\r\n    // computes liquidity value given all the parameters of the pair\r\n    function computeLiquidityValue(\r\n        uint256 reservesA,\r\n        uint256 reservesB,\r\n        uint256 totalSupply,\r\n        uint256 liquidityAmount,\r\n        bool feeOn,\r\n        uint kLast\r\n    ) internal pure returns (uint256 tokenAAmount, uint256 tokenBAmount) {\r\n        if (feeOn && kLast > 0) {\r\n            uint rootK = Babylonian.sqrt(reservesA.mul(reservesB));\r\n            uint rootKLast = Babylonian.sqrt(kLast);\r\n            if (rootK > rootKLast) {\r\n                uint numerator1 = totalSupply;\r\n                uint numerator2 = rootK.sub(rootKLast);\r\n                uint denominator = rootK.mul(5).add(rootKLast);\r\n                uint feeLiquidity = FullMath.mulDiv(numerator1, numerator2, denominator);\r\n                totalSupply = totalSupply.add(feeLiquidity);\r\n            }\r\n        }\r\n        return (reservesA.mul(liquidityAmount) / totalSupply, reservesB.mul(liquidityAmount) / totalSupply);\r\n    }\r\n\r\n    // get all current parameters from the pair and compute value of a liquidity amount\r\n    // **note this is subject to manipulation, e.g. sandwich attacks**. prefer passing a manipulation resistant price to\r\n    // #getLiquidityValueAfterArbitrageToPrice\r\n    function getLiquidityValue(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidityAmount\r\n    ) internal view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\r\n        (uint256 reservesA, uint256 reservesB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\r\n        IMdexPair pair = IMdexPair(UniswapV2Library.pairFor(factory, tokenA, tokenB));\r\n        bool feeOn = IMdexFactory(factory).feeTo() != address(0);\r\n        uint kLast = feeOn ? pair.kLast() : 0;\r\n        uint totalSupply = pair.totalSupply();\r\n        return computeLiquidityValue(reservesA, reservesB, totalSupply, liquidityAmount, feeOn, kLast);\r\n    }\r\n\r\n    // given two tokens, tokenA and tokenB, and their \"true price\", i.e. the observed ratio of value of token A to token B,\r\n    // and a liquidity amount, returns the value of the liquidity in terms of tokenA and tokenB\r\n    function getLiquidityValueAfterArbitrageToPrice(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 truePriceTokenA,\r\n        uint256 truePriceTokenB,\r\n        uint256 liquidityAmount\r\n    ) internal view returns (\r\n        uint256 tokenAAmount,\r\n        uint256 tokenBAmount\r\n    ) {\r\n        bool feeOn = IMdexFactory(factory).feeTo() != address(0);\r\n        IMdexPair pair = IMdexPair(UniswapV2Library.pairFor(factory, tokenA, tokenB));\r\n        uint kLast = feeOn ? pair.kLast() : 0;\r\n        uint totalSupply = pair.totalSupply();\r\n\r\n        // this also checks that totalSupply > 0\r\n        require(totalSupply >= liquidityAmount && liquidityAmount > 0, 'ComputeLiquidityValue: LIQUIDITY_AMOUNT');\r\n\r\n        (uint reservesA, uint reservesB) = getReservesAfterArbitrage(factory, tokenA, tokenB, truePriceTokenA, truePriceTokenB);\r\n\r\n        return computeLiquidityValue(reservesA, reservesB, totalSupply, liquidityAmount, feeOn, kLast);\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity =0.7.6;\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/libraries/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.5.0;\r\n\r\nimport '../../common/IMdexPair.sol';\r\n\r\nimport \"./SafeMath.sol\";\r\n\r\nlibrary UniswapV2Library {\r\n    using SafeMath for uint;\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                factory,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\r\n            ))));\r\n    }\r\n\r\n    // fetches and sorts the reserves for a pair\r\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        (uint reserve0, uint reserve1,) = IMdexPair(pairFor(factory, tokenA, tokenB)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n\r\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\r\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\r\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\r\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        amountB = amountA.mul(reserveB) / reserveA;\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\r\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint denominator = reserveOut.sub(amountOut).mul(997);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n    // performs chained getAmountOut calculations on any number of pairs\r\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\r\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n\r\n    // performs chained getAmountIn calculations on any number of pairs\r\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[amounts.length - 1] = amountOut;\r\n        for (uint i = path.length - 1; i > 0; i--) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\r\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/UniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity =0.7.6;\r\n\r\nimport '../common/IMdexFactory.sol';\r\nimport '../common/TransferHelper.sol';\r\n\r\nimport './libraries/UniswapV2Library.sol';\r\nimport './interfaces/IUniswapV2Router01.sol';\r\nimport './interfaces/IERC20.sol';\r\nimport './interfaces/IWETH.sol';\r\n\r\ncontract UniswapV2Router01 is IUniswapV2Router01 {\r\n    address public immutable override factory;\r\n    address public immutable override WETH;\r\n\r\n    modifier ensure(uint deadline) {\r\n        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\r\n        _;\r\n    }\r\n\r\n    constructor(address _factory, address _WETH) {\r\n        factory = _factory;\r\n        WETH = _WETH;\r\n    }\r\n\r\n    receive() external payable {\r\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\r\n    }\r\n\r\n    // **** ADD LIQUIDITY ****\r\n    function _addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin\r\n    ) private returns (uint amountA, uint amountB) {\r\n        // create the pair if it doesn't exist yet\r\n        if (IMdexFactory(factory).getPair(tokenA, tokenB) == address(0)) {\r\n            IMdexFactory(factory).createPair(tokenA, tokenB);\r\n        }\r\n        (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\r\n        if (reserveA == 0 && reserveB == 0) {\r\n            (amountA, amountB) = (amountADesired, amountBDesired);\r\n        } else {\r\n            uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\r\n            if (amountBOptimal <= amountBDesired) {\r\n                require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\r\n                (amountA, amountB) = (amountADesired, amountBOptimal);\r\n            } else {\r\n                uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\r\n                assert(amountAOptimal <= amountADesired);\r\n                require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\r\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\r\n            }\r\n        }\r\n    }\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\r\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\r\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\r\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\r\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\r\n        liquidity = IMdexPair(pair).mint(to);\r\n    }\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\r\n        (amountToken, amountETH) = _addLiquidity(\r\n            token,\r\n            WETH,\r\n            amountTokenDesired,\r\n            msg.value,\r\n            amountTokenMin,\r\n            amountETHMin\r\n        );\r\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\r\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\r\n        IWETH(WETH).deposit{value: amountETH}();\r\n        assert(IWETH(WETH).transfer(pair, amountETH));\r\n        liquidity = IMdexPair(pair).mint(to);\r\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH); // refund dust eth, if any\r\n    }\r\n\r\n    // **** REMOVE LIQUIDITY ****\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) public override ensure(deadline) returns (uint amountA, uint amountB) {\r\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\r\n        IMdexPair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\r\n        (uint amount0, uint amount1) = IMdexPair(pair).burn(to);\r\n        (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);\r\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\r\n        require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\r\n        require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\r\n    }\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) public override ensure(deadline) returns (uint amountToken, uint amountETH) {\r\n        (amountToken, amountETH) = removeLiquidity(\r\n            token,\r\n            WETH,\r\n            liquidity,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            address(this),\r\n            deadline\r\n        );\r\n        TransferHelper.safeTransfer(token, to, amountToken);\r\n        IWETH(WETH).withdraw(amountETH);\r\n        TransferHelper.safeTransferETH(to, amountETH);\r\n    }\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external override returns (uint amountA, uint amountB) {\r\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\r\n        uint value = approveMax ? uint(-1) : liquidity;\r\n        IMdexPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\r\n    }\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external override returns (uint amountToken, uint amountETH) {\r\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\r\n        uint value = approveMax ? uint(-1) : liquidity;\r\n        IMdexPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\r\n    }\r\n\r\n    // **** SWAP ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swap(uint[] memory amounts, address[] memory path, address _to) private {\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\r\n            uint amountOut = amounts[i + 1];\r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\r\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\r\n            IMdexPair(UniswapV2Library.pairFor(factory, input, output)).swap(amount0Out, amount1Out, to, new bytes(0));\r\n        }\r\n    }\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external override ensure(deadline) returns (uint[] memory amounts) {\r\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]);\r\n        _swap(amounts, path, to);\r\n    }\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external override ensure(deadline) returns (uint[] memory amounts) {\r\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]);\r\n        _swap(amounts, path, to);\r\n    }\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        override\r\n        payable\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\r\n        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        IWETH(WETH).deposit{value: amounts[0]}();\r\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\r\n        _swap(amounts, path, to);\r\n    }\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        override\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\r\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]);\r\n        _swap(amounts, path, address(this));\r\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        override\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\r\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]);\r\n        _swap(amounts, path, address(this));\r\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        override\r\n        payable\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\r\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n        require(amounts[0] <= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\r\n        IWETH(WETH).deposit{value: amounts[0]}();\r\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\r\n        _swap(amounts, path, to);\r\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]); // refund dust eth, if any\r\n    }\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) public pure override returns (uint amountB) {\r\n        return UniswapV2Library.quote(amountA, reserveA, reserveB);\r\n    }\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) public pure override returns (uint amountOut) {\r\n        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) public pure override returns (uint amountIn) {\r\n        return UniswapV2Library.getAmountOut(amountOut, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getAmountsOut(uint amountIn, address[] memory path) public view override returns (uint[] memory amounts) {\r\n        return UniswapV2Library.getAmountsOut(factory, amountIn, path);\r\n    }\r\n\r\n    function getAmountsIn(uint amountOut, address[] memory path) public view override returns (uint[] memory amounts) {\r\n        return UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n    }\r\n}\r\n"
    },
    "contracts/common/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity =0.7.6;\r\n\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value : value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/interfaces/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external view returns (address);\r\n    function WETH() external view returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n"
    },
    "contracts/periphery/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.5.0;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n"
    },
    "contracts/periphery/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.5.0;\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\n"
    },
    "contracts/periphery/UniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity =0.7.6;\r\n\r\nimport '../common/IMdexFactory.sol';\r\nimport '../common/TransferHelper.sol';\r\n\r\nimport './interfaces/IUniswapV2Router02.sol';\r\nimport './libraries/UniswapV2Library.sol';\r\nimport './libraries/SafeMath.sol';\r\nimport './interfaces/IERC20.sol';\r\nimport './interfaces/IWETH.sol';\r\n\r\ncontract UniswapV2Router02 is IUniswapV2Router02 {\r\n    using SafeMath for uint;\r\n\r\n    address public immutable override factory;\r\n    address public immutable override WETH;\r\n\r\n    modifier ensure(uint deadline) {\r\n        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\r\n        _;\r\n    }\r\n\r\n    constructor(address _factory, address _WETH) {\r\n        factory = _factory;\r\n        WETH = _WETH;\r\n    }\r\n\r\n    receive() external payable {\r\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\r\n    }\r\n\r\n    // **** ADD LIQUIDITY ****\r\n    function _addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin\r\n    ) internal virtual returns (uint amountA, uint amountB) {\r\n        // create the pair if it doesn't exist yet\r\n        if (IMdexFactory(factory).getPair(tokenA, tokenB) == address(0)) {\r\n            IMdexFactory(factory).createPair(tokenA, tokenB);\r\n        }\r\n        (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\r\n        if (reserveA == 0 && reserveB == 0) {\r\n            (amountA, amountB) = (amountADesired, amountBDesired);\r\n        } else {\r\n            uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\r\n            if (amountBOptimal <= amountBDesired) {\r\n                require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\r\n                (amountA, amountB) = (amountADesired, amountBOptimal);\r\n            } else {\r\n                uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\r\n                assert(amountAOptimal <= amountADesired);\r\n                require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\r\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\r\n            }\r\n        }\r\n    }\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\r\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\r\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\r\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\r\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\r\n        liquidity = IMdexPair(pair).mint(to);\r\n    }\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\r\n        (amountToken, amountETH) = _addLiquidity(\r\n            token,\r\n            WETH,\r\n            amountTokenDesired,\r\n            msg.value,\r\n            amountTokenMin,\r\n            amountETHMin\r\n        );\r\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\r\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\r\n        IWETH(WETH).deposit{value: amountETH}();\r\n        assert(IWETH(WETH).transfer(pair, amountETH));\r\n        liquidity = IMdexPair(pair).mint(to);\r\n        // refund dust eth, if any\r\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\r\n    }\r\n\r\n    // **** REMOVE LIQUIDITY ****\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\r\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\r\n        IMdexPair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\r\n        (uint amount0, uint amount1) = IMdexPair(pair).burn(to);\r\n        (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);\r\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\r\n        require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\r\n        require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\r\n    }\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\r\n        (amountToken, amountETH) = removeLiquidity(\r\n            token,\r\n            WETH,\r\n            liquidity,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            address(this),\r\n            deadline\r\n        );\r\n        TransferHelper.safeTransfer(token, to, amountToken);\r\n        IWETH(WETH).withdraw(amountETH);\r\n        TransferHelper.safeTransferETH(to, amountETH);\r\n    }\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external virtual override returns (uint amountA, uint amountB) {\r\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\r\n        uint value = approveMax ? uint(-1) : liquidity;\r\n        IMdexPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\r\n    }\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external virtual override returns (uint amountToken, uint amountETH) {\r\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\r\n        uint value = approveMax ? uint(-1) : liquidity;\r\n        IMdexPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\r\n    }\r\n\r\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) public virtual override ensure(deadline) returns (uint amountETH) {\r\n        (, amountETH) = removeLiquidity(\r\n            token,\r\n            WETH,\r\n            liquidity,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            address(this),\r\n            deadline\r\n        );\r\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\r\n        IWETH(WETH).withdraw(amountETH);\r\n        TransferHelper.safeTransferETH(to, amountETH);\r\n    }\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external virtual override returns (uint amountETH) {\r\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\r\n        uint value = approveMax ? uint(-1) : liquidity;\r\n        IMdexPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\r\n            token, liquidity, amountTokenMin, amountETHMin, to, deadline\r\n        );\r\n    }\r\n\r\n    // **** SWAP ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\r\n            uint amountOut = amounts[i + 1];\r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\r\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\r\n            IMdexPair(UniswapV2Library.pairFor(factory, input, output)).swap(\r\n                amount0Out, amount1Out, to, new bytes(0)\r\n            );\r\n        }\r\n    }\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\r\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, to);\r\n    }\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\r\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, to);\r\n    }\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        virtual\r\n        override\r\n        payable\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\r\n        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        IWETH(WETH).deposit{value: amounts[0]}();\r\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\r\n        _swap(amounts, path, to);\r\n    }\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\r\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, address(this));\r\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\r\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, address(this));\r\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        virtual\r\n        override\r\n        payable\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\r\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n        require(amounts[0] <= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\r\n        IWETH(WETH).deposit{value: amounts[0]}();\r\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\r\n        _swap(amounts, path, to);\r\n        // refund dust eth, if any\r\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\r\n    }\r\n\r\n    // **** SWAP (supporting fee-on-transfer tokens) ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\r\n            IMdexPair pair = IMdexPair(UniswapV2Library.pairFor(factory, input, output));\r\n            uint amountInput;\r\n            uint amountOutput;\r\n            { // scope to avoid stack too deep errors\r\n            (uint reserve0, uint reserve1,) = pair.getReserves();\r\n            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n            amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\r\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\r\n            }\r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\r\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\r\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\r\n        }\r\n    }\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override ensure(deadline) {\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\r\n        );\r\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\r\n        _swapSupportingFeeOnTransferTokens(path, to);\r\n        require(\r\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\r\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\r\n        );\r\n    }\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    )\r\n        external\r\n        virtual\r\n        override\r\n        payable\r\n        ensure(deadline)\r\n    {\r\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\r\n        uint amountIn = msg.value;\r\n        IWETH(WETH).deposit{value: amountIn}();\r\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));\r\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\r\n        _swapSupportingFeeOnTransferTokens(path, to);\r\n        require(\r\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\r\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\r\n        );\r\n    }\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    )\r\n        external\r\n        virtual\r\n        override\r\n        ensure(deadline)\r\n    {\r\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\r\n        );\r\n        _swapSupportingFeeOnTransferTokens(path, address(this));\r\n        uint amountOut = IERC20(WETH).balanceOf(address(this));\r\n        require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        IWETH(WETH).withdraw(amountOut);\r\n        TransferHelper.safeTransferETH(to, amountOut);\r\n    }\r\n\r\n    // **** LIBRARY FUNCTIONS ****\r\n    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {\r\n        return UniswapV2Library.quote(amountA, reserveA, reserveB);\r\n    }\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\r\n        public\r\n        pure\r\n        virtual\r\n        override\r\n        returns (uint amountOut)\r\n    {\r\n        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\r\n        public\r\n        pure\r\n        virtual\r\n        override\r\n        returns (uint amountIn)\r\n    {\r\n        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getAmountsOut(uint amountIn, address[] memory path)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint[] memory amounts)\r\n    {\r\n        return UniswapV2Library.getAmountsOut(factory, amountIn, path);\r\n    }\r\n\r\n    function getAmountsIn(uint amountOut, address[] memory path)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint[] memory amounts)\r\n    {\r\n        return UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/interfaces/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.6.2;\r\n\r\nimport './IUniswapV2Router01.sol';\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n"
    },
    "contracts/periphery/UniswapV2Migrator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity =0.7.6;\r\n\r\nimport '../common/TransferHelper.sol';\r\n\r\nimport './interfaces/IUniswapV2Migrator.sol';\r\nimport './interfaces/V1/IUniswapV1Factory.sol';\r\nimport './interfaces/V1/IUniswapV1Exchange.sol';\r\nimport './interfaces/IUniswapV2Router01.sol';\r\nimport './interfaces/IERC20.sol';\r\n\r\ncontract UniswapV2Migrator is IUniswapV2Migrator {\r\n    IUniswapV1Factory immutable factoryV1;\r\n    IUniswapV2Router01 immutable router;\r\n\r\n    constructor(address _factoryV1, address _router) {\r\n        factoryV1 = IUniswapV1Factory(_factoryV1);\r\n        router = IUniswapV2Router01(_router);\r\n    }\r\n\r\n    // needs to accept ETH from any v1 exchange and the router. ideally this could be enforced, as in the router,\r\n    // but it's not possible because it requires a call to the v1 factory, which takes too much gas\r\n    receive() external payable {}\r\n\r\n    function migrate(address token, uint amountTokenMin, uint amountETHMin, address to, uint deadline)\r\n        external\r\n        override\r\n    {\r\n        IUniswapV1Exchange exchangeV1 = IUniswapV1Exchange(factoryV1.getExchange(token));\r\n        uint liquidityV1 = exchangeV1.balanceOf(msg.sender);\r\n        require(exchangeV1.transferFrom(msg.sender, address(this), liquidityV1), 'TRANSFER_FROM_FAILED');\r\n        (uint amountETHV1, uint amountTokenV1) = exchangeV1.removeLiquidity(liquidityV1, 1, 1, uint(-1));\r\n        TransferHelper.safeApprove(token, address(router), amountTokenV1);\r\n        (uint amountTokenV2, uint amountETHV2,) = router.addLiquidityETH{value: amountETHV1}(\r\n            token,\r\n            amountTokenV1,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            to,\r\n            deadline\r\n        );\r\n        if (amountTokenV1 > amountTokenV2) {\r\n            TransferHelper.safeApprove(token, address(router), 0); // be a good blockchain citizen, reset allowance to 0\r\n            TransferHelper.safeTransfer(token, msg.sender, amountTokenV1 - amountTokenV2);\r\n        } else if (amountETHV1 > amountETHV2) {\r\n            // addLiquidityETH guarantees that all of amountETHV1 or amountTokenV1 will be used, hence this else is safe\r\n            TransferHelper.safeTransferETH(msg.sender, amountETHV1 - amountETHV2);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/interfaces/IUniswapV2Migrator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Migrator {\r\n    function migrate(address token, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external;\r\n}\r\n"
    },
    "contracts/periphery/interfaces/V1/IUniswapV1Factory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV1Factory {\r\n    function getExchange(address) external view returns (address);\r\n}\r\n"
    },
    "contracts/periphery/interfaces/V1/IUniswapV1Exchange.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV1Exchange {\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function removeLiquidity(uint, uint, uint, uint) external returns (uint, uint);\r\n    function tokenToEthSwapInput(uint, uint, uint) external returns (uint);\r\n    function ethToTokenSwapInput(uint, uint) external payable returns (uint);\r\n}\r\n"
    },
    "contracts/periphery/test/RouterEventEmitter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity =0.7.6;\r\n\r\nimport '../interfaces/IUniswapV2Router01.sol';\r\n\r\ncontract RouterEventEmitter {\r\n    event Amounts(uint[] amounts);\r\n\r\n    receive() external payable {}\r\n\r\n    function swapExactTokensForTokens(\r\n        address router,\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external {\r\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\r\n            IUniswapV2Router01(router).swapExactTokensForTokens.selector, amountIn, amountOutMin, path, to, deadline\r\n        ));\r\n        assert(success);\r\n        emit Amounts(abi.decode(returnData, (uint[])));\r\n    }\r\n\r\n    function swapTokensForExactTokens(\r\n        address router,\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external {\r\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\r\n            IUniswapV2Router01(router).swapTokensForExactTokens.selector, amountOut, amountInMax, path, to, deadline\r\n        ));\r\n        assert(success);\r\n        emit Amounts(abi.decode(returnData, (uint[])));\r\n    }\r\n\r\n    function swapExactETHForTokens(\r\n        address router,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable {\r\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\r\n            IUniswapV2Router01(router).swapExactETHForTokens.selector, amountOutMin, path, to, deadline\r\n        ));\r\n        assert(success);\r\n        emit Amounts(abi.decode(returnData, (uint[])));\r\n    }\r\n\r\n    function swapTokensForExactETH(\r\n        address router,\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external {\r\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\r\n            IUniswapV2Router01(router).swapTokensForExactETH.selector, amountOut, amountInMax, path, to, deadline\r\n        ));\r\n        assert(success);\r\n        emit Amounts(abi.decode(returnData, (uint[])));\r\n    }\r\n\r\n    function swapExactTokensForETH(\r\n        address router,\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external {\r\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\r\n            IUniswapV2Router01(router).swapExactTokensForETH.selector, amountIn, amountOutMin, path, to, deadline\r\n        ));\r\n        assert(success);\r\n        emit Amounts(abi.decode(returnData, (uint[])));\r\n    }\r\n\r\n    function swapETHForExactTokens(\r\n        address router,\r\n        uint amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable {\r\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\r\n            IUniswapV2Router01(router).swapETHForExactTokens.selector, amountOut, path, to, deadline\r\n        ));\r\n        assert(success);\r\n        emit Amounts(abi.decode(returnData, (uint[])));\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/test/ERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity =0.7.6;\r\n\r\nimport '../libraries/SafeMath.sol';\r\n\r\ncontract ERC20 {\r\n    using SafeMath for uint;\r\n\r\n    string public constant name = 'Test Token';\r\n    string public constant symbol = 'TT';\r\n    uint8 public constant decimals = 18;\r\n    uint  public totalSupply;\r\n    mapping(address => uint) public balanceOf;\r\n    mapping(address => mapping(address => uint)) public allowance;\r\n\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n    mapping(address => uint) public nonces;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    constructor(uint _totalSupply) {\r\n        uint chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes('1')),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n        _mint(msg.sender, _totalSupply);\r\n    }\r\n\r\n    function _mint(address to, uint value) internal {\r\n        totalSupply = totalSupply.add(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint value) internal {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint value) private {\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint value) private {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint value) external returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint value) external returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool) {\r\n        if (allowance[from][msg.sender] != uint(-1)) {\r\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n        require(deadline >= block.timestamp, 'EXPIRED');\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\r\n            )\r\n        );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'INVALID_SIGNATURE');\r\n        _approve(owner, spender, value);\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/test/DeflatingERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity =0.7.6;\r\n\r\nimport '../libraries/SafeMath.sol';\r\n\r\ncontract DeflatingERC20 {\r\n    using SafeMath for uint;\r\n\r\n    string public constant name = 'Deflating Test Token';\r\n    string public constant symbol = 'DTT';\r\n    uint8 public constant decimals = 18;\r\n    uint  public totalSupply;\r\n    mapping(address => uint) public balanceOf;\r\n    mapping(address => mapping(address => uint)) public allowance;\r\n\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n    mapping(address => uint) public nonces;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    constructor(uint _totalSupply) {\r\n        uint chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes('1')),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n        _mint(msg.sender, _totalSupply);\r\n    }\r\n\r\n    function _mint(address to, uint value) internal {\r\n        totalSupply = totalSupply.add(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint value) internal {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint value) private {\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint value) private {\r\n        uint burnAmount = value / 100;\r\n        _burn(from, burnAmount);\r\n        uint transferAmount = value.sub(burnAmount);\r\n        balanceOf[from] = balanceOf[from].sub(transferAmount);\r\n        balanceOf[to] = balanceOf[to].add(transferAmount);\r\n        emit Transfer(from, to, transferAmount);\r\n    }\r\n\r\n    function approve(address spender, uint value) external returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint value) external returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool) {\r\n        if (allowance[from][msg.sender] != uint(-1)) {\r\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n        require(deadline >= block.timestamp, 'EXPIRED');\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\r\n            )\r\n        );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'INVALID_SIGNATURE');\r\n        _approve(owner, spender, value);\r\n    }\r\n}\r\n"
    },
    "contracts/swap/heco/Router.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity =0.7.6;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../library/SafeMath.sol\";\r\nimport \"../interface/IERC20.sol\";\r\nimport \"../../common/IMdexFactory.sol\";\r\nimport \"../../common/IMdexPair.sol\";\r\n\r\ninterface IMdexRouter {\r\n    function factory() external view returns (address);\r\n\r\n    function WHT() external view returns (address);\r\n\r\n    function swapMining() external view returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external view returns (uint256 amountB);\r\n\r\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountOut);\r\n\r\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountIn);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\r\n\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface ISwapMining {\r\n    function swap(address account, address input, address output, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IWHT {\r\n    function deposit() external payable;\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function withdraw(uint) external;\r\n}\r\n\r\ncontract MdexRouter is IMdexRouter, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    address public immutable override factory;\r\n    address public immutable override WHT;\r\n    address public override swapMining;\r\n\r\n    modifier ensure(uint deadline) {\r\n        require(deadline >= block.timestamp, 'MdexRouter: EXPIRED');\r\n        _;\r\n    }\r\n\r\n    constructor(address _factory, address _WHT) {\r\n        factory = _factory;\r\n        WHT = _WHT;\r\n    }\r\n\r\n    receive() external payable {\r\n        assert(msg.sender == WHT);\r\n        // only accept HT via fallback from the WHT contract\r\n    }\r\n\r\n    function pairFor(address tokenA, address tokenB) public view returns (address pair){\r\n        pair = IMdexFactory(factory).pairFor(tokenA, tokenB);\r\n    }\r\n\r\n    function setSwapMining(address _swapMininng) public onlyOwner {\r\n        swapMining = _swapMininng;\r\n    }\r\n\r\n    // **** ADD LIQUIDITY ****\r\n    function _addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin\r\n    ) internal virtual returns (uint amountA, uint amountB) {\r\n        // create the pair if it doesn't exist yet\r\n        if (IMdexFactory(factory).getPair(tokenA, tokenB) == address(0)) {\r\n            IMdexFactory(factory).createPair(tokenA, tokenB);\r\n        }\r\n        (uint reserveA, uint reserveB) = IMdexFactory(factory).getReserves(tokenA, tokenB);\r\n        if (reserveA == 0 && reserveB == 0) {\r\n            (amountA, amountB) = (amountADesired, amountBDesired);\r\n        } else {\r\n            uint amountBOptimal = IMdexFactory(factory).quote(amountADesired, reserveA, reserveB);\r\n            if (amountBOptimal <= amountBDesired) {\r\n                require(amountBOptimal >= amountBMin, 'MdexRouter: INSUFFICIENT_B_AMOUNT');\r\n                (amountA, amountB) = (amountADesired, amountBOptimal);\r\n            } else {\r\n                uint amountAOptimal = IMdexFactory(factory).quote(amountBDesired, reserveB, reserveA);\r\n                assert(amountAOptimal <= amountADesired);\r\n                require(amountAOptimal >= amountAMin, 'MdexRouter: INSUFFICIENT_A_AMOUNT');\r\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\r\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\r\n        address pair = pairFor(tokenA, tokenB);\r\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\r\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\r\n        liquidity = IMdexPair(pair).mint(to);\r\n    }\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\r\n        (amountToken, amountETH) = _addLiquidity(\r\n            token,\r\n            WHT,\r\n            amountTokenDesired,\r\n            msg.value,\r\n            amountTokenMin,\r\n            amountETHMin\r\n        );\r\n        address pair = pairFor(token, WHT);\r\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\r\n        IWHT(WHT).deposit{value : amountETH}();\r\n        assert(IWHT(WHT).transfer(pair, amountETH));\r\n        liquidity = IMdexPair(pair).mint(to);\r\n        // refund dust eth, if any\r\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\r\n    }\r\n\r\n    // **** REMOVE LIQUIDITY ****\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\r\n        address pair = pairFor(tokenA, tokenB);\r\n        IMdexPair(pair).transferFrom(msg.sender, pair, liquidity);\r\n        // send liquidity to pair\r\n        (uint amount0, uint amount1) = IMdexPair(pair).burn(to);\r\n        (address token0,) = IMdexFactory(factory).sortTokens(tokenA, tokenB);\r\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\r\n        require(amountA >= amountAMin, 'MdexRouter: INSUFFICIENT_A_AMOUNT');\r\n        require(amountB >= amountBMin, 'MdexRouter: INSUFFICIENT_B_AMOUNT');\r\n    }\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\r\n        (amountToken, amountETH) = removeLiquidity(\r\n            token,\r\n            WHT,\r\n            liquidity,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            address(this),\r\n            deadline\r\n        );\r\n        TransferHelper.safeTransfer(token, to, amountToken);\r\n        IWHT(WHT).withdraw(amountETH);\r\n        TransferHelper.safeTransferETH(to, amountETH);\r\n    }\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external virtual override returns (uint amountA, uint amountB) {\r\n        address pair = pairFor(tokenA, tokenB);\r\n        uint value = approveMax ? uint(- 1) : liquidity;\r\n        IMdexPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\r\n    }\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external virtual override returns (uint amountToken, uint amountETH) {\r\n        address pair = pairFor(token, WHT);\r\n        uint value = approveMax ? uint(- 1) : liquidity;\r\n        IMdexPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\r\n    }\r\n\r\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) public virtual override ensure(deadline) returns (uint amountETH) {\r\n        (, amountETH) = removeLiquidity(\r\n            token,\r\n            WHT,\r\n            liquidity,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            address(this),\r\n            deadline\r\n        );\r\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\r\n        IWHT(WHT).withdraw(amountETH);\r\n        TransferHelper.safeTransferETH(to, amountETH);\r\n    }\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external virtual override returns (uint amountETH) {\r\n        address pair = pairFor(token, WHT);\r\n        uint value = approveMax ? uint(- 1) : liquidity;\r\n        IMdexPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\r\n            token, liquidity, amountTokenMin, amountETHMin, to, deadline\r\n        );\r\n    }\r\n\r\n    // **** SWAP ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = IMdexFactory(factory).sortTokens(input, output);\r\n            uint amountOut = amounts[i + 1];\r\n            if (swapMining != address(0)) {\r\n                ISwapMining(swapMining).swap(msg.sender, input, output, amountOut);\r\n            }\r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\r\n            address to = i < path.length - 2 ? pairFor(output, path[i + 2]) : _to;\r\n            IMdexPair(pairFor(input, output)).swap(\r\n                amount0Out, amount1Out, to, new bytes(0)\r\n            );\r\n        }\r\n    }\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\r\n        amounts = IMdexFactory(factory).getAmountsOut(amountIn, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'MdexRouter: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, to);\r\n    }\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\r\n        amounts = IMdexFactory(factory).getAmountsIn(amountOut, path);\r\n        require(amounts[0] <= amountInMax, 'MdexRouter: EXCESSIVE_INPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, to);\r\n    }\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    virtual\r\n    override\r\n    payable\r\n    ensure(deadline)\r\n    returns (uint[] memory amounts)\r\n    {\r\n        require(path[0] == WHT, 'MdexRouter: INVALID_PATH');\r\n        amounts = IMdexFactory(factory).getAmountsOut(msg.value, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'MdexRouter: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        IWHT(WHT).deposit{value : amounts[0]}();\r\n        assert(IWHT(WHT).transfer(pairFor(path[0], path[1]), amounts[0]));\r\n        _swap(amounts, path, to);\r\n    }\r\n\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    virtual\r\n    override\r\n    ensure(deadline)\r\n    returns (uint[] memory amounts)\r\n    {\r\n        require(path[path.length - 1] == WHT, 'MdexRouter: INVALID_PATH');\r\n        amounts = IMdexFactory(factory).getAmountsIn(amountOut, path);\r\n        require(amounts[0] <= amountInMax, 'MdexRouter: EXCESSIVE_INPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, address(this));\r\n        IWHT(WHT).withdraw(amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    virtual\r\n    override\r\n    ensure(deadline)\r\n    returns (uint[] memory amounts)\r\n    {\r\n        require(path[path.length - 1] == WHT, 'MdexRouter: INVALID_PATH');\r\n        amounts = IMdexFactory(factory).getAmountsOut(amountIn, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'MdexRouter: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, address(this));\r\n        IWHT(WHT).withdraw(amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    virtual\r\n    override\r\n    payable\r\n    ensure(deadline)\r\n    returns (uint[] memory amounts)\r\n    {\r\n        require(path[0] == WHT, 'MdexRouter: INVALID_PATH');\r\n        amounts = IMdexFactory(factory).getAmountsIn(amountOut, path);\r\n        require(amounts[0] <= msg.value, 'MdexRouter: EXCESSIVE_INPUT_AMOUNT');\r\n        IWHT(WHT).deposit{value : amounts[0]}();\r\n        assert(IWHT(WHT).transfer(pairFor(path[0], path[1]), amounts[0]));\r\n        _swap(amounts, path, to);\r\n        // refund dust eth, if any\r\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\r\n    }\r\n\r\n    // **** SWAP (supporting fee-on-transfer tokens) ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = IMdexFactory(factory).sortTokens(input, output);\r\n            IMdexPair pair = IMdexPair(pairFor(input, output));\r\n            uint amountInput;\r\n            uint amountOutput;\r\n            {// scope to avoid stack too deep errors\r\n                (uint reserve0, uint reserve1,) = pair.getReserves();\r\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n                amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\r\n                amountOutput = IMdexFactory(factory).getAmountOut(amountInput, reserveInput, reserveOutput);\r\n            }\r\n            if (swapMining != address(0)) {\r\n                ISwapMining(swapMining).swap(msg.sender, input, output, amountOutput);\r\n            }\r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\r\n            address to = i < path.length - 2 ? pairFor(output, path[i + 2]) : _to;\r\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\r\n        }\r\n    }\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override ensure(deadline) {\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, pairFor(path[0], path[1]), amountIn\r\n        );\r\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\r\n        _swapSupportingFeeOnTransferTokens(path, to);\r\n        require(\r\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\r\n            'MdexRouter: INSUFFICIENT_OUTPUT_AMOUNT'\r\n        );\r\n    }\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    )\r\n    external\r\n    virtual\r\n    override\r\n    payable\r\n    ensure(deadline)\r\n    {\r\n        require(path[0] == WHT, 'MdexRouter: INVALID_PATH');\r\n        uint amountIn = msg.value;\r\n        IWHT(WHT).deposit{value : amountIn}();\r\n        assert(IWHT(WHT).transfer(pairFor(path[0], path[1]), amountIn));\r\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\r\n        _swapSupportingFeeOnTransferTokens(path, to);\r\n        require(\r\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\r\n            'MdexRouter: INSUFFICIENT_OUTPUT_AMOUNT'\r\n        );\r\n    }\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    )\r\n    external\r\n    virtual\r\n    override\r\n    ensure(deadline)\r\n    {\r\n        require(path[path.length - 1] == WHT, 'MdexRouter: INVALID_PATH');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, pairFor(path[0], path[1]), amountIn\r\n        );\r\n        _swapSupportingFeeOnTransferTokens(path, address(this));\r\n        uint amountOut = IERC20(WHT).balanceOf(address(this));\r\n        require(amountOut >= amountOutMin, 'MdexRouter: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        IWHT(WHT).withdraw(amountOut);\r\n        TransferHelper.safeTransferETH(to, amountOut);\r\n    }\r\n\r\n    // **** LIBRARY FUNCTIONS ****\r\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) public view override returns (uint256 amountB) {\r\n        return IMdexFactory(factory).quote(amountA, reserveA, reserveB);\r\n    }\r\n\r\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) public view override returns (uint256 amountOut){\r\n        return IMdexFactory(factory).getAmountOut(amountIn, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) public view override returns (uint256 amountIn){\r\n        return IMdexFactory(factory).getAmountIn(amountOut, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] memory path) public view override returns (uint256[] memory amounts){\r\n        return IMdexFactory(factory).getAmountsOut(amountIn, path);\r\n    }\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] memory path) public view override returns (uint256[] memory amounts){\r\n        return IMdexFactory(factory).getAmountsIn(amountOut, path);\r\n    }\r\n\r\n}\r\n\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value : value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n"
    },
    "contracts/swap/heco/Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity =0.7.6;\r\n\r\nimport \"../library/SafeMath.sol\";\r\nimport \"../interface/IERC20.sol\";\r\nimport \"../../common/IMdexFactory.sol\";\r\nimport \"../../common/IMdexPair.sol\";\r\n\r\nimport \"../../common/LErc20DelegatorInterface.sol\";\r\nimport \"../../common/CTokenInterfaces.sol\";\r\n\r\ninterface IHswapV2Callee {\r\n    function hswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\r\n}\r\n\r\ninterface IMdexERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n\r\ncontract MdexERC20 is IMdexERC20 {\r\n    using SafeMath for uint;\r\n\r\n    string public constant override name = 'HSwap LP Token';\r\n    // function name() override external pure returns (string memory) {\r\n    //     return \"HSwap LP Token\";\r\n    // }\r\n    string public constant override symbol = 'HMDX';\r\n    uint8 public constant override decimals = 18;\r\n    uint  public override totalSupply;\r\n    mapping(address => uint) public override balanceOf;\r\n    mapping(address => mapping(address => uint)) public override allowance;\r\n\r\n    bytes32 public override DOMAIN_SEPARATOR;\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant override PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n    mapping(address => uint) public override nonces;\r\n\r\n    // event Approval(address indexed owner, address indexed spender, uint value);\r\n    // event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    constructor() {\r\n        uint chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes('1')),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    function _mint(address to, uint value) internal {\r\n        totalSupply = totalSupply.add(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint value) internal {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint value) private {\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint value) private {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint value) override external returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint value) override external returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value) override external returns (bool) {\r\n        if (allowance[from][msg.sender] != uint(- 1)) {\r\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) override external {\r\n        require(deadline >= block.timestamp, 'MdexSwap: EXPIRED');\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\r\n            )\r\n        );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'MdexSwap: INVALID_SIGNATURE');\r\n        _approve(owner, spender, value);\r\n    }\r\n}\r\n\r\ncontract MdexPair is IMdexERC20, IMdexPair {\r\n    using SafeMath  for uint;\r\n    using UQ112x112 for uint224;\r\n\r\n    uint public constant override MINIMUM_LIQUIDITY = 10 ** 3;\r\n    bytes4 private constant _SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n\r\n    address public override factory;\r\n    address public override token0;\r\n    address public override token1;\r\n\r\n    // 存到lend池中的 ctoken0 amount\r\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\r\n    // 存到lend池中的 ctoken1 amount\r\n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\r\n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\r\n\r\n    address public cToken0;              // 对应 token0 在 lend 池中的 cToken\r\n    address public cToken1;              // 对应 token1 在 lend 池中的 cToken\r\n    uint112 public vReserve0;           // 虚拟的 token0 数量, 因为实际上 token0 已经存入 ctoken 合约中\r\n    uint112 public vReserve1;           // 虚拟的 token1 数量, 因为实际上 token1 已经存入 ctoken 合约中\r\n\r\n    uint public override price0CumulativeLast;\r\n    uint public override price1CumulativeLast;\r\n    uint public override kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\r\n\r\n    uint private _unlocked = 1;\r\n    modifier lock() {\r\n        require(_unlocked == 1, 'MdexSwap: LOCKED');\r\n        _unlocked = 0;\r\n        _;\r\n        _unlocked = 1;\r\n    }\r\n    // using SafeMath for uint;\r\n\r\n    string public constant override(IMdexERC20, IMdexPair) name = 'LP Token';\r\n    string public constant override(IMdexERC20, IMdexPair) symbol = 'HMDX';\r\n    uint8 public constant override(IMdexERC20, IMdexPair) decimals = 18;\r\n    uint  public override(IMdexERC20, IMdexPair) totalSupply;\r\n    mapping(address => uint) public override(IMdexERC20, IMdexPair) balanceOf;\r\n    mapping(address => mapping(address => uint)) public override(IMdexERC20, IMdexPair) allowance;\r\n\r\n    bytes32 public override(IMdexERC20, IMdexPair) DOMAIN_SEPARATOR;\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant override(IMdexERC20, IMdexPair) PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n    mapping(address => uint) public override(IMdexERC20, IMdexPair) nonces;\r\n\r\n    // event Approval(address indexed owner, address indexed spender, uint value);\r\n    // event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    constructor() {\r\n        uint chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes('1')),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n        factory = msg.sender;\r\n    }\r\n\r\n    function _mint(address to, uint value) internal {\r\n        totalSupply = totalSupply.add(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint value) internal {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint value) private {\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint value) private {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint value) override(IMdexERC20, IMdexPair) external returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint value) override(IMdexERC20, IMdexPair) external returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value) override(IMdexERC20, IMdexPair) external returns (bool) {\r\n        if (allowance[from][msg.sender] != uint(- 1)) {\r\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline,\r\n                    uint8 v, bytes32 r, bytes32 s) override(IMdexERC20, IMdexPair) external {\r\n        require(deadline >= block.timestamp, 'Swap: EXPIRED');\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\r\n            )\r\n        );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'Swap: INVALID_SIGNATURE');\r\n        _approve(owner, spender, value);\r\n    }\r\n    ///////////////////////////////////////////////////////////////\r\n\r\n    function getReserves() override public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\r\n        _reserve0 = reserve0;\r\n        _reserve1 = reserve1;\r\n        _blockTimestampLast = blockTimestampLast;\r\n    }\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(_SELECTOR, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Swap: TRANSFER_FAILED');\r\n    }\r\n\r\n    // event Mint(address indexed sender, uint amount0, uint amount1);\r\n    // event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    // event Swap(\r\n    //     address indexed sender,\r\n    //     uint amount0In,\r\n    //     uint amount1In,\r\n    //     uint amount0Out,\r\n    //     uint amount1Out,\r\n    //     address indexed to\r\n    // );\r\n    // event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    // constructor() public {\r\n    //     factory = msg.sender;\r\n    // }\r\n\r\n    // called once by the factory at time of deployment\r\n    function initialize(address _token0, address _token1) override external {\r\n        require(msg.sender == factory, 'MdexSwap: FORBIDDEN');\r\n        // sufficient check\r\n        token0 = _token0;\r\n        token1 = _token1;\r\n    }\r\n\r\n    // called once by the factory at time of deployment\r\n    function initializeCTokenAddress(address _token0, address _token1) override external {\r\n        require(msg.sender == factory, 'MdexSwap: FORBIDDEN');\r\n        // sufficient check\r\n        cToken0 = _token0;\r\n        cToken1 = _token1;\r\n    }\r\n\r\n    // update reserves and, on the first call per block, price accumulators\r\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\r\n        require(balance0 <= uint112(- 1) && balance1 <= uint112(- 1), 'MdexSwap: OVERFLOW');\r\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\r\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast;\r\n        // overflow is desired\r\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\r\n            // * never overflows, and + overflow is desired\r\n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\r\n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\r\n        }\r\n        reserve0 = uint112(balance0);\r\n        reserve1 = uint112(balance1);\r\n        blockTimestampLast = blockTimestamp;\r\n        emit Sync(reserve0, reserve1);\r\n    }\r\n\r\n    // update reserves and, on the first call per block, price accumulators\r\n    function _addVreserve(uint balance0, uint balance1) private {\r\n        require(balance0 <= uint112(- 1) && balance1 <= uint112(- 1), 'MdexSwap: OVERFLOW');\r\n        // uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\r\n        // uint32 timeElapsed = blockTimestamp - blockTimestampLast;\r\n        // // overflow is desired\r\n        // if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\r\n        //     // * never overflows, and + overflow is desired\r\n        //     price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\r\n        //     price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\r\n        // }\r\n        vReserve0 += uint112(balance0);\r\n        vReserve1 += uint112(balance1);\r\n        // blockTimestampLast = blockTimestamp;\r\n        // emit Sync(reserve0, reserve1);\r\n    }\r\n\r\n    function _delVreserve(uint balance0, uint balance1) private {\r\n        require(balance0 <= vReserve0, \"Swap: NOT ENOUGHT\");\r\n        require(balance1 <= vReserve1, \"Swap: NOT ENOUGHT\");\r\n        \r\n        vReserve0 -= uint112(balance0);\r\n        vReserve1 -= uint112(balance1);\r\n    }\r\n\r\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\r\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\r\n        address feeTo = IMdexFactory(factory).feeTo();\r\n        feeOn = feeTo != address(0);\r\n        uint _kLast = kLast;\r\n        // gas savings\r\n        if (feeOn) {\r\n            if (_kLast != 0) {\r\n                uint rootK = SafeMath.sqrt(uint(_reserve0).mul(_reserve1));\r\n                uint rootKLast = SafeMath.sqrt(_kLast);\r\n                if (rootK > rootKLast) {\r\n                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));\r\n                    uint denominator = rootK.mul(IMdexFactory(factory).feeToRate()).add(rootKLast);\r\n                    uint liquidity = numerator / denominator;\r\n                    if (liquidity > 0) _mint(feeTo, liquidity);\r\n                }\r\n            }\r\n        } else if (_kLast != 0) {\r\n            kLast = 0;\r\n        }\r\n    }\r\n\r\n    function mintCToken(address to) override external lock returns (uint liquidity) {\r\n\r\n    }\r\n\r\n    // ETH/HT/BNB 不能直接 mint\r\n    // 存入的是 token 而不是 ctoken; 如果存入的是 ctoken 或不确定, 调用 mintCToken\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function mint(address to) override external lock returns (uint liquidity) {\r\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves();\r\n        // gas savings\r\n        uint balance0 = IERC20(token0).balanceOf(address(this));\r\n        uint balance1 = IERC20(token1).balanceOf(address(this));\r\n        // uint amount0 = balance0.sub(_reserve0);\r\n        // uint amount1 = balance1.sub(_reserve1);\r\n\r\n        // guotie\r\n        // 分别将 token0 token1 transer 到 lend 池, 获取 ctoken0 ctoken1 的 amount0 amount1\r\n        //\r\n        uint cBalanceBefore0 = IERC20(cToken0).balanceOf(address(this));\r\n        uint cBalanceBefore1 = IERC20(cToken1).balanceOf(address(this));\r\n        // approve, mint ctoken0\r\n        IERC20(cToken0).approve(cToken0, balance0);\r\n        CErc20Interface(cToken0).mint(balance0);\r\n        IERC20(cToken0).approve(cToken0, 0);\r\n\r\n        // approve, mint ctoken1\r\n        IERC20(cToken1).approve(cToken1, balance1);\r\n        CErc20Interface(cToken1).mint(balance1);\r\n        IERC20(cToken1).approve(cToken1, 0);\r\n        uint cBalanceAfter0 = IERC20(cToken0).balanceOf(address(this));\r\n        uint cBalanceAfter1 = IERC20(cToken1).balanceOf(address(this));\r\n\r\n        // amount0 amount1 均为存入 lend 池后得到的 ctoken 的数量\r\n        uint amount0 = cBalanceBefore0.sub(cBalanceAfter0); // .sub(_reserve0);\r\n        uint amount1 = cBalanceBefore1.sub(cBalanceAfter1); // .sub(_reserve1);\r\n\r\n        bool feeOn = _mintFee(_reserve0, _reserve1);\r\n        uint _totalSupply = totalSupply;\r\n        // gas savings, must be defined here since totalSupply can update in _mintFee\r\n        if (_totalSupply == 0) {\r\n            liquidity = SafeMath.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\r\n            _mint(address(0), MINIMUM_LIQUIDITY);\r\n            // permanently lock the first MINIMUM_LIQUIDITY tokens\r\n        } else {\r\n            liquidity = SafeMath.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\r\n        }\r\n        require(liquidity > 0, 'MdexSwap: INSUFFICIENT_LIQUIDITY_MINTED');\r\n        _mint(to, liquidity);\r\n\r\n        _update(cBalanceAfter0, cBalanceAfter1, _reserve0, _reserve1);\r\n        // _addVreserve(balance0, balance1);\r\n        if (feeOn) kLast = uint(reserve0).mul(reserve1);\r\n        // reserve0 and reserve1 are up-to-date\r\n        emit Mint(msg.sender, amount0, amount1);\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function burn(address to) override external lock returns (uint amount0, uint amount1) {\r\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves();\r\n        // gas savings\r\n        // address _token0 = token0;\r\n        // gas savings\r\n        // address _token1 = token1;\r\n        // gas savings\r\n        address _ctoken0 = cToken0;\r\n        // gas savings\r\n        address _ctoken1 = cToken1;\r\n        // gas savings\r\n        // uint balance0 = IERC20(_token0).balanceOf(address(this));  // 应该是0 因为token 都存在 lend 池中\r\n        // uint balance1 = IERC20(_token1).balanceOf(address(this));  // 应该是0 因为token 都存在 lend 池中\r\n        uint cbalance0 = IERC20(_ctoken0).balanceOf(address(this));  // ctoken0 数量\r\n        uint cbalance1 = IERC20(_ctoken1).balanceOf(address(this));  // ctoken1 数量\r\n        uint liquidity = balanceOf[address(this)];  // 用户操作 burn 之前转入的 LP 代币数量\r\n\r\n        bool feeOn = _mintFee(_reserve0, _reserve1);\r\n        uint _totalSupply = totalSupply;\r\n        // gas savings, must be defined here since totalSupply can update in _mintFee\r\n        uint camount0 = liquidity.mul(cbalance0) / _totalSupply;\r\n        // using balances ensures pro-rata distribution\r\n        uint camount1 = liquidity.mul(cbalance1) / _totalSupply;\r\n        // using balances ensures pro-rata distribution\r\n        require(camount0 > 0 && camount1 > 0, 'MdexSwap: INSUFFICIENT_LIQUIDITY_BURNED');\r\n        _burn(address(this), liquidity);\r\n\r\n        // 先把 ctoken 转给 pair\r\n        _redeemOrTransfer(to, _ctoken0, token0, camount0);\r\n        _redeemOrTransfer(to, _ctoken1, token1, camount1);\r\n        // _safeTransfer(_ctoken0, address(this), camount0);\r\n        // _safeTransfer(_ctoken1, address(this), camount1);\r\n        cbalance0 = IERC20(_ctoken0).balanceOf(address(this));\r\n        cbalance1 = IERC20(_ctoken1).balanceOf(address(this));\r\n\r\n        _update(cbalance0, cbalance1, _reserve0, _reserve1);\r\n        if (feeOn) kLast = uint(reserve0).mul(reserve1);\r\n        // reserve0 and reserve1 are up-to-date\r\n        emit Burn(msg.sender, amount0, amount1, to);\r\n    }\r\n\r\n    // 从 lend 池中把 token 赎回, camount 为 ctoken 数量\r\n    // 赎回 token, 如果赎回成功, 将 token 转给 to; 否则, 将 ctoken 转给 to\r\n    function _redeemOrTransfer(address to, address ctoken, address token, uint camount) private {\r\n        uint ret;\r\n\r\n        ret = CErc20Interface(ctoken).redeem(camount);\r\n        if (ret == 0) {\r\n            // success\r\n            // 将赎回的 token 全部转给 to\r\n            _safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\r\n        } else {\r\n            // failed\r\n            IERC20(ctoken).transfer(to, camount);\r\n        }\r\n    }\r\n\r\n    // 从 lend 池中把 token 赎回, amount 为待赎回的 token 数量\r\n    // 赎回 token, 如果赎回成功, 将 token 转给 to; 否则, 将 ctoken 转给 to\r\n    function _redeemUnderlyingOrTransfer(address to, address ctoken, address token, uint amount) private {\r\n        uint ret;\r\n\r\n        ret = CErc20Interface(ctoken).redeemUnderlying(amount);\r\n        if (ret == 0) {\r\n            // success\r\n            // 将赎回的 token 全部转给 to\r\n            _safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\r\n        } else {\r\n            // failed\r\n            // 转多少呢? 这里需要获取 ctoken 和 token 的比例关系, 获取最新的 exchangeRate\r\n            //\r\n            uint camount = amount / CTokenInterface(ctoken).exchangeRateCurrent();\r\n            IERC20(ctoken).transfer(to, camount);\r\n        }\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) override external lock {\r\n        require(amount0Out > 0 || amount1Out > 0, 'Swap: INVALID_AMOUNT');\r\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves();\r\n        // gas savings\r\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'Swap: INSUFFICIENT_LIQUIDITY');\r\n\r\n        uint balance0;\r\n        uint balance1;\r\n        {// scope for _token{0,1}, avoids stack too deep errors\r\n            address _token0 = token0;\r\n            address _token1 = token1;\r\n            require(to != _token0 && to != _token1, 'Swap: INVALID_TO');\r\n            require(to != cToken0 && to != cToken1, 'Swap: INVALID_TO');\r\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out);\r\n            // optimistically transfer tokens\r\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out);\r\n            // optimistically transfer tokens\r\n            if (data.length > 0) IHswapV2Callee(to).hswapV2Call(msg.sender, amount0Out, amount1Out, data);\r\n            balance0 = IERC20(_token0).balanceOf(address(this));\r\n            balance1 = IERC20(_token1).balanceOf(address(this));\r\n        }\r\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\r\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\r\n        require(amount0In > 0 || amount1In > 0, 'Swap: INSUFFICIENT_INPUT_AMOUNT');\r\n        {// scope for reserve{0,1}Adjusted, avoids stack too deep errors\r\n            uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\r\n            uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\r\n            require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000 ** 2), 'Swap: K');\r\n        }\r\n\r\n        _update(balance0, balance1, _reserve0, _reserve1);\r\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\r\n    }\r\n\r\n    struct TokenLocalVars {\r\n        uint balance;\r\n        // uint balance0Adjusted;  // cToken: x1 - 0.003xin\r\n        address token;\r\n        address ctoken;\r\n        uint amountIn;\r\n        uint cAmountIn;\r\n        uint cAmountOut;\r\n    }\r\n    // amount0Out: 预计得到的 token0 的数量, 在外围合约中计算好, 计算时需要考虑 exchangeRate 兑换比例\r\n    // amount1Out: 预计得到的 token1 的数量, 在外围合约中计算好, 计算时需要考虑 exchangeRate 兑换比例\r\n    // 转入的币应该是 token 而不是 ctoken\r\n    function swap2x(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {\r\n        require(amount0Out > 0 || amount1Out > 0, 'Swap: INVALID_AMOUNT');\r\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves();\r\n        // gas savings\r\n        // 不能比较 因为 _reserve0 是 ctoken0 的数量\r\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'Swap: INSUFFICIENT_LIQUIDITY');\r\n        TokenLocalVars memory vars0;\r\n        TokenLocalVars memory vars1;\r\n\r\n        // 这里记录转入的 token 数量\r\n        vars0.token = token0;\r\n        vars1.token = token1;\r\n        vars0.ctoken = cToken0;\r\n        vars1.ctoken = cToken1;\r\n\r\n        // uint balance0;\r\n        // uint balance1;\r\n        // 这里记录转入的 token 数量\r\n        // uint amount0In; // = IERC20(_token0).balanceOf(address(this));\r\n        // uint amount1In; // = IERC20(_token1).balanceOf(address(this));\r\n\r\n        // uint camount0In; // = IERC20(_token0).balanceOf(address(this));\r\n        // uint camount1In; // = IERC20(_token1).balanceOf(address(this));\r\n        {// scope for _token{0,1}, avoids stack too deep errors\r\n            // address _ctoken0 = cToken0;\r\n            // address _ctoken1 = cToken1;\r\n            require(to != vars0.token && to != vars1.token, 'Swap: INVALID_TO');\r\n            require(to != vars0.ctoken && to != vars1.ctoken, 'Swap: INVALID_TO');\r\n            if (amount0Out > 0) {\r\n                vars0.cAmountOut = amount0Out / CTokenInterface(vars0.ctoken).exchangeRateCurrent();\r\n                _redeemUnderlyingOrTransfer(to, vars0.ctoken, vars0.token, amount0Out);\r\n            } // _safeTransfer(_token0, to, amount0Out);\r\n            // optimistically transfer tokens\r\n            if (amount1Out > 0) {\r\n                vars1.cAmountOut = amount1Out / CTokenInterface(vars1.ctoken).exchangeRateCurrent();\r\n                _redeemUnderlyingOrTransfer(to, vars1.ctoken, vars1.token, amount1Out);\r\n            } // _safeTransfer(_token1, to, amount1Out);\r\n            // optimistically transfer tokens\r\n            if (data.length > 0) IHswapV2Callee(to).hswapV2Call(msg.sender, amount0Out, amount1Out, data);\r\n\r\n            // 这里 mint cToken\r\n            // todo 收手续费\r\n            vars0.amountIn = IERC20(vars0.token).balanceOf(address(this));\r\n            vars1.amountIn = IERC20(vars1.token).balanceOf(address(this));\r\n            require(vars0.amountIn > 0 || vars1.amountIn > 0, 'Swap: INSUFFICIENT_INPUT_AMOUNT');\r\n            if (vars0.amountIn > 0) {\r\n                // 将转入的 token0 存入借贷池\r\n                CErc20Interface(vars0.ctoken).mint(vars0.amountIn);\r\n            }\r\n            if (vars1.amountIn > 0) {\r\n                // 将转入的 token1 存入借贷池\r\n                CErc20Interface(vars1.ctoken).mint(vars1.amountIn);\r\n            }\r\n\r\n            vars0.balance = IERC20(vars0.ctoken).balanceOf(address(this));\r\n            vars1.balance = IERC20(vars1.ctoken).balanceOf(address(this));\r\n        }\r\n        // 注意: x * y = K 是两个 cToken 之间的关系\r\n        vars0.cAmountIn = vars0.balance > _reserve0 - vars0.cAmountOut ? vars0.balance - (_reserve0 - vars0.cAmountOut) : 0;\r\n        vars1.cAmountIn = vars1.balance > _reserve1 - vars1.cAmountOut ? vars1.balance - (_reserve1 - vars1.cAmountOut) : 0;\r\n        // uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\r\n        {// scope for reserve{0,1}Adjusted, avoids stack too deep errors\r\n            uint balance0Adjusted = vars0.balance.mul(1000).sub(vars0.cAmountIn.mul(3));\r\n            uint balance1Adjusted = vars1.balance.mul(1000).sub(vars1.cAmountIn.mul(3));\r\n            require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000 ** 2), 'Swap: K');\r\n        }\r\n\r\n        _update(vars0.balance, vars1.balance, _reserve0, _reserve1);\r\n        emit Swap(msg.sender, vars0.amountIn, vars1.amountIn, amount0Out, amount1Out, to);\r\n    }\r\n\r\n    // force balances to match reserves\r\n    function skim(address to) override external lock {\r\n        address _token0 = token0;\r\n        // gas savings\r\n        address _token1 = token1;\r\n        // gas savings\r\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\r\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\r\n    }\r\n\r\n    // force reserves to match balances\r\n    function sync() override external lock {\r\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\r\n    }\r\n\r\n    function price(address token, uint256 baseDecimal) override public view returns (uint256) {\r\n        if ((token0 != token && token1 != token) || 0 == reserve0 || 0 == reserve1) {\r\n            return 0;\r\n        }\r\n        if (token0 == token) {\r\n            return uint256(reserve1).mul(baseDecimal).div(uint256(reserve0));\r\n        } else {\r\n            return uint256(reserve0).mul(baseDecimal).div(uint256(reserve1));\r\n        }\r\n    }\r\n}\r\n\r\ncontract MdexFactory is IMdexFactory {\r\n    using SafeMath for uint256;\r\n    address public override feeTo;\r\n    address public override feeToSetter;\r\n    uint256 public override feeToRate;\r\n    bytes32 public initCodeHash;\r\n\r\n    // lend controller address. should be unitroller address, which is proxy of comptroller\r\n    LErc20DelegatorInterface public lErc20DelegatorFactory;\r\n\r\n    mapping(address => mapping(address => address)) public override getPair;\r\n    address[] public override allPairs;\r\n\r\n    // event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    // 创建时需要设置 LERC20 factory 地址\r\n    constructor(address _feeToSetter, address _comptroller) {\r\n        feeToSetter = _feeToSetter;\r\n        lErc20DelegatorFactory = LErc20DelegatorInterface(_comptroller);\r\n        initCodeHash = keccak256(abi.encodePacked(type(MdexPair).creationCode));\r\n    }\r\n\r\n    function allPairsLength() external view override returns (uint) {\r\n        return allPairs.length;\r\n    }\r\n\r\n    // 创建交易对\r\n    // tokenA tokenB 都不能是 cToken\r\n    function createPair(address tokenA, address tokenB) external override returns (address pair) {\r\n        require(tokenA != tokenB, 'SwapFactory: IDENTICAL_ADDRESSES');\r\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'SwapFactory: ZERO_ADDRESS');\r\n        require(getPair[token0][token1] == address(0), 'SwapFactory: PAIR_EXISTS');\r\n        \r\n        // guotie\r\n        // token0 token1 不能是 cToken\r\n        (address ctoken0, address ctoken1) = _checkOrCreateCToken(token0, token1);\r\n\r\n        // single check is sufficient\r\n        bytes memory bytecode = type(MdexPair).creationCode;\r\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\r\n        assembly {\r\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n        }\r\n        IMdexPair(pair).initialize(token0, token1);\r\n\r\n        // guotie\r\n        // set compound ctoken address\r\n        IMdexPair(pair).initializeCTokenAddress(ctoken0, ctoken1);\r\n\r\n        getPair[token0][token1] = pair;\r\n        getPair[token1][token0] = pair;\r\n        // populate mapping in the reverse direction\r\n        allPairs.push(pair);\r\n        emit PairCreated(token0, token1, pair, allPairs.length);\r\n    }\r\n\r\n    function setFeeTo(address _feeTo) external override {\r\n        require(msg.sender == feeToSetter, 'SwapFactory: FORBIDDEN');\r\n        feeTo = _feeTo;\r\n    }\r\n\r\n    function setFeeToSetter(address _feeToSetter) external override {\r\n        require(msg.sender == feeToSetter, 'SwapFactory: FORBIDDEN');\r\n        require(_feeToSetter != address(0), \"MdexSwapFactory: FeeToSetter is zero address\");\r\n        feeToSetter = _feeToSetter;\r\n    }\r\n\r\n    function setFeeToRate(uint256 _rate) external override {\r\n        require(msg.sender == feeToSetter, 'SwapFactory: FORBIDDEN');\r\n        require(_rate > 0, \"MdexSwapFactory: FEE_TO_RATE_OVERFLOW\");\r\n        feeToRate = _rate.sub(1);\r\n    }\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(address tokenA, address tokenB) public pure override returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'SwapFactory: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'SwapFactory: ZERO_ADDRESS');\r\n    }\r\n\r\n    // guotie\r\n    // 检查 token 不是 cToken\r\n    function _checkTokenIsNotCToken(address token0, address token1) private view returns (uint) {\r\n        address ctoken0 = lErc20DelegatorFactory.getCTokenAddressPure(token0);\r\n        if (ctoken0 == address(0)) {\r\n            return 1;\r\n        }\r\n\r\n        address ctoken1 = lErc20DelegatorFactory.getCTokenAddressPure(token1);\r\n        if (ctoken1 == address(0)) {\r\n            return 2;\r\n        }\r\n\r\n        if(ctoken0 == ctoken1) {\r\n            return 3;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function _checkOrCreateCToken(address token0, address token1) private returns (address ctoken0, address ctoken1) {\r\n        ctoken0 = lErc20DelegatorFactory.getCTokenAddress(token0);\r\n        require(ctoken0 != address(0), 'SwapFactory: cToken is 0');\r\n        ctoken1 = lErc20DelegatorFactory.getCTokenAddress(token1);\r\n        require(ctoken1 != address(0), 'SwapFactory: cToken is 0');\r\n\r\n        require(ctoken0 != ctoken1, 'SwapFactory: Dup cToken');\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(address tokenA, address tokenB) public view override returns (address pair) {\r\n        // guotie 这里不关心顺序\r\n        uint err = _checkTokenIsNotCToken(tokenA, tokenB);\r\n        require(err == 0, \"check token failed\");\r\n\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                address(this),\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                initCodeHash\r\n            ))));\r\n    }\r\n\r\n    // fetches and sorts the reserves for a pair\r\n    function getReserves(address tokenA, address tokenB) public view override returns (uint reserveA, uint reserveB) {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        (uint reserve0, uint reserve1,) = IMdexPair(pairFor(tokenA, tokenB)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n\r\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\r\n    function quote(uint amountA, uint reserveA, uint reserveB) public pure override returns (uint amountB) {\r\n        require(amountA > 0, 'SwapFactory: INSUFFICIENT_AMOUNT');\r\n        require(reserveA > 0 && reserveB > 0, 'SwapFactory: INSUFFICIENT_LIQUIDITY');\r\n        amountB = amountA.mul(reserveB) / reserveA;\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) public pure override returns (uint amountOut) {\r\n        require(amountIn > 0, 'SwapFactory: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'SwapFactory: INSUFFICIENT_LIQUIDITY');\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) public pure override returns (uint amountIn) {\r\n        require(amountOut > 0, 'SwapFactory: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'SwapFactory: INSUFFICIENT_LIQUIDITY');\r\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint denominator = reserveOut.sub(amountOut).mul(997);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n    // performs chained getAmountOut calculations on any number of pairs\r\n    function getAmountsOut(uint amountIn, address[] memory path) public view override returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'SwapFactory: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(path[i], path[i + 1]);\r\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n\r\n    // performs chained getAmountIn calculations on any number of pairs\r\n    function getAmountsIn(uint amountOut, address[] memory path) public view override returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'SwapFactory: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[amounts.length - 1] = amountOut;\r\n        for (uint i = path.length - 1; i > 0; i--) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(path[i - 1], path[i]);\r\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary UQ112x112 {\r\n    uint224 constant Q112 = 2 ** 112;\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 y) internal pure returns (uint224 z) {\r\n        z = uint224(y) * Q112;\r\n        // never overflows\r\n    }\r\n\r\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\r\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\r\n        z = x / uint224(y);\r\n    }\r\n}\r\n"
    },
    "contracts/common/LErc20DelegatorInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity =0.7.6;\r\nimport \"./CTokenInterfaces.sol\";\r\n\r\nabstract contract LErc20DelegatorInterface {\r\n      function delegateToInitialize(address underlying_,\r\n                ComptrollerInterface comptroller_,\r\n                InterestRateModel interestRateModel_,\r\n                uint initialExchangeRateMantissa_,\r\n                string memory name_,\r\n                string memory symbol_,\r\n                uint8 decimals_,\r\n                address payable admin_,\r\n                address implementation_,\r\n                bytes memory becomeImplementationData) public {}\r\n\r\n      // get or create ctoken\r\n      function getCTokenAddress(address token) virtual external returns (address cToken);\r\n      function getCTokenAddressPure(address cToken) virtual external view returns (address);\r\n      function getTokenAddress(address cToken) virtual external view returns (address);\r\n}"
    },
    "contracts/compound/LErc20Delegator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\nimport \"../common/CTokenInterfaces.sol\";\r\n\r\n/**\r\n * @title Compound's CErc20Delegator Contract\r\n * @notice CTokens which wrap an EIP-20 underlying and delegate to an implementation\r\n * @author Compound\r\n */\r\ncontract LErc20Delegator is CTokenInterface, CErc20Interface, CDelegatorInterface {\r\n    /**\r\n     * @notice Construct a new money market\r\n     * @param underlying_ The address of the underlying asset\r\n     * @param comptroller_ The address of the Comptroller\r\n     * @param interestRateModel_ The address of the interest rate model\r\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\r\n     * @param name_ ERC-20 name of this token\r\n     * @param symbol_ ERC-20 symbol of this token\r\n     * @param decimals_ ERC-20 decimal precision of this token\r\n     * @param admin_ Address of the administrator of this token\r\n     * @param implementation_ The address of the implementation the contract delegates to\r\n     * @param becomeImplementationData The encoded args for becomeImplementation\r\n     */\r\n    function delegateToInitialize(address underlying_,\r\n                ComptrollerInterface comptroller_,\r\n                InterestRateModel interestRateModel_,\r\n                uint initialExchangeRateMantissa_,\r\n                string memory name_,\r\n                string memory symbol_,\r\n                uint8 decimals_,\r\n                address payable admin_,\r\n                address implementation_,\r\n                bytes memory becomeImplementationData) public {\r\n        // Creator of the contract is admin during initialization\r\n        admin = msg.sender;\r\n\r\n        // First delegate gets to initialize the delegator (i.e. storage contract)\r\n        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,address,uint256,string,string,uint8)\",\r\n                                                            underlying_,\r\n                                                            comptroller_,\r\n                                                            interestRateModel_,\r\n                                                            initialExchangeRateMantissa_,\r\n                                                            name_,\r\n                                                            symbol_,\r\n                                                            decimals_));\r\n\r\n        // New implementations always get set via the settor (post-initialize)\r\n        _setImplementation(implementation_, false, becomeImplementationData);\r\n\r\n        // Set the proper admin now that initialization is done\r\n        admin = admin_;\r\n    }\r\n\r\n    /**\r\n     * @notice Called by the admin to update the implementation of the delegator\r\n     * @param implementation_ The address of the new implementation for delegation\r\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\r\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\r\n     */\r\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) override public {\r\n        require(msg.sender == admin, \"CErc20Delegator::_setImplementation: Caller must be admin\");\r\n\r\n        if (allowResign) {\r\n            delegateToImplementation(abi.encodeWithSignature(\"_resignImplementation()\"));\r\n        }\r\n\r\n        address oldImplementation = implementation;\r\n        implementation = implementation_;\r\n\r\n        delegateToImplementation(abi.encodeWithSignature(\"_becomeImplementation(bytes)\", becomeImplementationData));\r\n\r\n        emit NewImplementation(oldImplementation, implementation);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function mint(uint mintAmount) override external returns (uint) {\r\n        mintAmount; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems cTokens in exchange for the underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemTokens The number of cTokens to redeem into underlying\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeem(uint redeemTokens) override external returns (uint) {\r\n        redeemTokens; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemAmount The amount of underlying to redeem\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeemUnderlying(uint redeemAmount) override external returns (uint) {\r\n        redeemAmount; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n      * @notice Sender borrows assets from the protocol to their own address\r\n      * @param borrowAmount The amount of the underlying asset to borrow\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function borrow(uint borrowAmount) override external returns (uint) {\r\n        borrowAmount; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Sender repays their own borrow\r\n     * @param repayAmount The amount to repay\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function repayBorrow(uint repayAmount) override external returns (uint) {\r\n        repayAmount; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Sender repays a borrow belonging to borrower\r\n     * @param borrower the account with the debt being payed off\r\n     * @param repayAmount The amount to repay\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) override external returns (uint) {\r\n        borrower; repayAmount; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice The sender liquidates the borrowers collateral.\r\n     *  The collateral seized is transferred to the liquidator.\r\n     * @param borrower The borrower of this cToken to be liquidated\r\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\r\n     * @param repayAmount The amount of the underlying borrowed asset to repay\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function liquidateBorrow(address borrower, uint repayAmount,\r\n                        CTokenInterface cTokenCollateral) override external returns (uint) {\r\n        borrower; repayAmount; cTokenCollateral; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n     * @param dst The address of the destination account\r\n     * @param amount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transfer(address dst, uint amount) override external returns (bool) {\r\n        dst; amount; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `src` to `dst`\r\n     * @param src The address of the source account\r\n     * @param dst The address of the destination account\r\n     * @param amount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transferFrom(address src, address dst, uint256 amount) override external returns (bool) {\r\n        src; dst; amount; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Approve `spender` to transfer up to `amount` from `src`\r\n     * @dev This will overwrite the approval amount for `spender`\r\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\r\n     * @param spender The address of the account which may transfer tokens\r\n     * @param amount The number of tokens that are approved (-1 means infinite)\r\n     * @return Whether or not the approval succeeded\r\n     */\r\n    function approve(address spender, uint256 amount) override external returns (bool) {\r\n        spender; amount; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Get the current allowance from `owner` for `spender`\r\n     * @param owner The address of the account which owns the tokens to be spent\r\n     * @param spender The address of the account which may transfer tokens\r\n     * @return The number of tokens allowed to be spent (-1 means infinite)\r\n     */\r\n    function allowance(address owner, address spender) override external view returns (uint) {\r\n        owner; spender; // Shh\r\n        delegateToViewAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Get the token balance of the `owner`\r\n     * @param owner The address of the account to query\r\n     * @return The number of tokens owned by `owner`\r\n     */\r\n    function balanceOf(address owner) override external view returns (uint) {\r\n        owner; // Shh\r\n        delegateToViewAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Get the underlying balance of the `owner`\r\n     * @dev This also accrues interest in a transaction\r\n     * @param owner The address of the account to query\r\n     * @return The amount of underlying owned by `owner`\r\n     */\r\n    function balanceOfUnderlying(address owner) override external returns (uint) {\r\n        owner; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\r\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\r\n     * @param account Address of the account to snapshot\r\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\r\n     */\r\n    function getAccountSnapshot(address account) override external view returns (uint, uint, uint, uint) {\r\n        account; // Shh\r\n        delegateToViewAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current per-block borrow interest rate for this cToken\r\n     * @return The borrow interest rate per block, scaled by 1e18\r\n     */\r\n    function borrowRatePerBlock() override external view returns (uint) {\r\n        delegateToViewAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current per-block supply interest rate for this cToken\r\n     * @return The supply interest rate per block, scaled by 1e18\r\n     */\r\n    function supplyRatePerBlock() override external view returns (uint) {\r\n        delegateToViewAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current total borrows plus accrued interest\r\n     * @return The total borrows with interest\r\n     */\r\n    function totalBorrowsCurrent() override external returns (uint) {\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\r\n     * @param account The address whose balance should be calculated after updating borrowIndex\r\n     * @return The calculated balance\r\n     */\r\n    function borrowBalanceCurrent(address account) override external returns (uint) {\r\n        account; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Return the borrow balance of account based on stored data\r\n     * @param account The address whose balance should be calculated\r\n     * @return The calculated balance\r\n     */\r\n    function borrowBalanceStored(address account) override public view returns (uint) {\r\n        account; // Shh\r\n        delegateToViewAndReturn();\r\n    }\r\n\r\n   /**\r\n     * @notice Accrue interest then return the up-to-date exchange rate\r\n     * @return Calculated exchange rate scaled by 1e18\r\n     */\r\n    function exchangeRateCurrent() override public returns (uint) {\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the exchange rate from the underlying to the CToken\r\n     * @dev This function does not accrue interest before calculating the exchange rate\r\n     * @return Calculated exchange rate scaled by 1e18\r\n     */\r\n    function exchangeRateStored() override public view returns (uint) {\r\n        delegateToViewAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Get cash balance of this cToken in the underlying asset\r\n     * @return The quantity of underlying asset owned by this contract\r\n     */\r\n    function getCash() override external view returns (uint) {\r\n        delegateToViewAndReturn();\r\n    }\r\n\r\n    /**\r\n      * @notice Applies accrued interest to total borrows and reserves.\r\n      * @dev This calculates interest accrued from the last checkpointed block\r\n      *      up to the current block and writes new checkpoint to storage.\r\n      */\r\n    function accrueInterest() override public returns (uint) {\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers collateral tokens (this market) to the liquidator.\r\n     * @dev Will fail unless called by another cToken during the process of liquidation.\r\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\r\n     * @param liquidator The account receiving seized collateral\r\n     * @param borrower The account having collateral seized\r\n     * @param seizeTokens The number of cTokens to seize\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function seize(address liquidator, address borrower, uint seizeTokens) override external returns (uint) {\r\n        liquidator; borrower; seizeTokens; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    /**\r\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @param newPendingAdmin New pending admin.\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPendingAdmin(address payable newPendingAdmin) override external returns (uint) {\r\n        newPendingAdmin; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n      * @notice Sets a new comptroller for the market\r\n      * @dev Admin function to set a new comptroller\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setComptroller(ComptrollerInterface newComptroller) override public returns (uint) {\r\n        newComptroller; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\r\n      * @dev Admin function to accrue interest and set a new reserve factor\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setReserveFactor(uint newReserveFactorMantissa) override external returns (uint) {\r\n        newReserveFactorMantissa; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\r\n      * @dev Admin function for pending admin to accept role and update admin\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _acceptAdmin() override external returns (uint) {\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Accrues interest and adds reserves by transferring from admin\r\n     * @param addAmount Amount of reserves to add\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _addReserves(uint addAmount) override external returns (uint) {\r\n        addAmount; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Accrues interest and reduces reserves by transferring to admin\r\n     * @param reduceAmount Amount of reduction to reserves\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _reduceReserves(uint reduceAmount) override external returns (uint) {\r\n        reduceAmount; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Accrues interest and updates the interest rate model using _setInterestRateModelFresh\r\n     * @dev Admin function to accrue interest and update the interest rate model\r\n     * @param newInterestRateModel the new interest rate model to use\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) override public returns (uint) {\r\n        newInterestRateModel; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Internal method to delegate execution to another contract\r\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\r\n     * @param callee The contract to delegatecall\r\n     * @param data The raw data to delegatecall\r\n     * @return The returned bytes from the delegatecall\r\n     */\r\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\r\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\r\n        assembly {\r\n            if eq(success, 0) {\r\n                revert(add(returnData, 0x20), returndatasize())\r\n            }\r\n        }\r\n        return returnData;\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates execution to the implementation contract\r\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\r\n     * @param data The raw data to delegatecall\r\n     * @return The returned bytes from the delegatecall\r\n     */\r\n    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\r\n        return delegateTo(implementation, data);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates execution to an implementation contract\r\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\r\n     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\r\n     * @param data The raw data to delegatecall\r\n     * @return The returned bytes from the delegatecall\r\n     */\r\n    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\r\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\r\n        assembly {\r\n            if eq(success, 0) {\r\n                revert(add(returnData, 0x20), returndatasize())\r\n            }\r\n        }\r\n        return abi.decode(returnData, (bytes));\r\n    }\r\n\r\n    function delegateToViewAndReturn() private view returns (bytes memory) {\r\n        (bool success, ) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", msg.data));\r\n\r\n        assembly {\r\n            let free_mem_ptr := mload(0x40)\r\n            returndatacopy(free_mem_ptr, 0, returndatasize())\r\n\r\n            switch success\r\n            case 0 { revert(free_mem_ptr, returndatasize()) }\r\n            default { return(add(free_mem_ptr, 0x40), returndatasize()) }\r\n        }\r\n    }\r\n\r\n    function delegateAndReturn() private returns (bytes memory) {\r\n        (bool success, ) = implementation.delegatecall(msg.data);\r\n\r\n        assembly {\r\n            let free_mem_ptr := mload(0x40)\r\n            returndatacopy(free_mem_ptr, 0, returndatasize())\r\n\r\n            switch success\r\n            case 0 { revert(free_mem_ptr, returndatasize()) }\r\n            default { return(free_mem_ptr, returndatasize()) }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates execution to an implementation contract\r\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\r\n     */\r\n    // function () external payable {\r\n    fallback () external payable {\r\n        require(msg.value == 0, \"LErc20Delegator:fallback: cannot send value to fallback\");\r\n\r\n        // delegate all other functions to current implementation\r\n        delegateAndReturn();\r\n    }\r\n    receive () external payable {\r\n        require(msg.value == 0, \"LErc20Delegator:receive: cannot send value to receive\");\r\n\r\n        // delegate all other functions to current implementation\r\n        // delegateAndReturn();\r\n    }\r\n}\r\n"
    },
    "contracts/compound/LErc20DelegatorFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity =0.7.6;\r\n\r\nimport \"../common/LErc20DelegatorInterface.sol\";\r\nimport \"./LErc20Delegator.sol\";\r\nimport \"./EIP20Interface.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract LErc20DelegatorFactory is LErc20DelegatorInterface {\r\n    \r\n    event NewDelegator(address token,address delegator);\r\n    \r\n    /**\r\n     * @notice Construct\r\n     */\r\n    constructor(address _implementation, address comptroller_, address intersetRateModel) {\r\n        // Creator of the contract is admin during initialization\r\n        admin_ = msg.sender;\r\n        comptroller = ComptrollerInterface(comptroller_);\r\n        implementation_ = _implementation;\r\n        interestRateModel_ = InterestRateModel(intersetRateModel);\r\n    }\r\n    \r\n    //可以设置\r\n    ComptrollerInterface public comptroller; // = ComptrollerInterface(0x07D7654836ee31D5Dc20c1Ee9716CCF240fC7BD2);\r\n    //可以设置\r\n    InterestRateModel public interestRateModel_; // = InterestRateModel(0x5f75DEB780493f57A82283aDc1Def47de8873E50);\r\n    //?根据小数位数  计算\r\n    uint initialExchangeRateMantissa_ = 10000000000000000000000000;\r\n    uint8 public decimals_ = 18;\r\n    address payable admin_ = 0x78A3970a965d347AD83c8350ab49eBFa62aC2Dc5;\r\n    // delegate 地址\r\n    address implementation_; // = 0x98872083585Cd54f6dfc2dB9894C5C1B816C3A55;\r\n    //comptroller_ 地址\r\n    bytes  becomeImplementationData ;\r\n    //模拟\r\n     mapping (address => address) public tokenKeyMapping;\r\n     mapping (address => address) public cTokenKeyMapping;\r\n    \r\n    //根据 'token' 获得 'cToken'\r\n    function getCTokenAddress(address token) override external returns (address cToken){\r\n        //判断调用方这是否是swap pair 地址\r\n        cToken =  tokenKeyMapping[token];\r\n        //判断comptroller 中有没有 ctoken,有的话直接返回\r\n        if(cToken == address(0)){\r\n            console.log('ctoken not exist, create it:', token);\r\n            cToken = newDelegator(token);\r\n        }\r\n        //没有 则创建并返回\r\n        return cToken;\r\n    }\r\n    \r\n    // 只读 如果不存在 返回 0\r\n    function getCTokenAddressPure(address cToken) override external view returns (address) {\r\n        return tokenKeyMapping[cToken];\r\n    }\r\n\r\n    function getTokenAddress(address cToken) override external view returns (address) {\r\n        return cTokenKeyMapping[cToken];\r\n    }\r\n    \r\n    function newDelegator(address token_) public returns (address delegator) {\r\n        require(token_ != address(0), 'ZERO_ADDRESS');\r\n        \r\n       // require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient\r\n        bytes memory bytecode = type(LErc20Delegator).creationCode;\r\n        bytes32 salt = keccak256(abi.encodePacked(token_));\r\n        console.logBytes32(salt);\r\n        // console.logBytes(bytecode);\r\n        assembly {\r\n            delegator := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n        }\r\n\r\n        console.log('delegator:', delegator);\r\n        //获得参数\r\n        EIP20Interface hrc20 = EIP20Interface(token_);\r\n        LErc20DelegatorInterface(delegator).delegateToInitialize(token_,\r\n                comptroller,\r\n                interestRateModel_,\r\n                initialExchangeRateMantissa_,\r\n                strConcat(\"L\", hrc20.name()) ,\r\n                strConcat(\"L\",hrc20.symbol()) ,\r\n                decimals_,\r\n                admin_,\r\n                implementation_,\r\n                becomeImplementationData);\r\n\r\n        addNewCToken(token_, delegator);\r\n        // bytes4(keccak256(bytes('_supportMarket(address)')))\r\n        address(comptroller).call(abi.encodeWithSelector(bytes4(keccak256(bytes('_supportMarket(address)'))), delegator));\r\n        emit NewDelegator(token_, address(delegator));\r\n        return delegator;\r\n    }\r\n    \r\n    //像comportable 添加新币 对应关系\r\n    function addNewCToken(address token,address cToken) private returns (uint){\r\n        //包含两个币互相对应关系\r\n        tokenKeyMapping[token] = cToken;\r\n        cTokenKeyMapping[cToken] = token;\r\n    }\r\n    \r\n     function strConcat(string memory _a ,string memory _b) public view returns (string memory){\r\n            bytes memory _ba = bytes(_a);\r\n            bytes memory _bb = bytes(_b);\r\n            string memory ret = new string(_ba.length + _bb.length);\r\n            bytes memory bret = bytes(ret);\r\n            uint k = 0;\r\n            for (uint i = 0; i < _ba.length; i++)bret[k++] = _ba[i];\r\n            for (uint i = 0; i < _bb.length; i++) bret[k++] = _bb[i];\r\n            return string(ret);\r\n       }  \r\n\r\n}\r\n\r\n\r\n"
    },
    "contracts/compound/Reservoir.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\n/**\r\n * @title Reservoir Contract\r\n * @notice Distributes a token to a different contract at a fixed rate.\r\n * @dev This contract must be poked via the `drip()` function every so often.\r\n * @author Compound\r\n */\r\ncontract Reservoir {\r\n\r\n  /// @notice The block number when the Reservoir started (immutable)\r\n  uint public dripStart;\r\n\r\n  /// @notice Tokens per block that to drip to target (immutable)\r\n  uint public dripRate;\r\n\r\n  /// @notice Reference to token to drip (immutable)\r\n  EIP20Interface public token;\r\n\r\n  /// @notice Target to receive dripped tokens (immutable)\r\n  address public target;\r\n\r\n  /// @notice Amount that has already been dripped\r\n  uint public dripped;\r\n\r\n  /**\r\n    * @notice Constructs a Reservoir\r\n    * @param dripRate_ Numer of tokens per block to drip\r\n    * @param token_ The token to drip\r\n    * @param target_ The recipient of dripped tokens\r\n    */\r\n  constructor(uint dripRate_, EIP20Interface token_, address target_) {\r\n    dripStart = block.number;\r\n    dripRate = dripRate_;\r\n    token = token_;\r\n    target = target_;\r\n    dripped = 0;\r\n  }\r\n\r\n  /**\r\n    * @notice Drips the maximum amount of tokens to match the drip rate since inception\r\n    * @dev Note: this will only drip up to the amount of tokens available.\r\n    * @return The amount of tokens dripped in this call\r\n    */\r\n  function drip() public returns (uint) {\r\n    // First, read storage into memory\r\n    EIP20Interface token_ = token;\r\n    uint reservoirBalance_ = token_.balanceOf(address(this)); // TODO: Verify this is a static call\r\n    uint dripRate_ = dripRate;\r\n    uint dripStart_ = dripStart;\r\n    uint dripped_ = dripped;\r\n    address target_ = target;\r\n    uint blockNumber_ = block.number;\r\n\r\n    // Next, calculate intermediate values\r\n    uint dripTotal_ = mul(dripRate_, blockNumber_ - dripStart_, \"dripTotal overflow\");\r\n    uint deltaDrip_ = sub(dripTotal_, dripped_, \"deltaDrip underflow\");\r\n    uint toDrip_ = min(reservoirBalance_, deltaDrip_);\r\n    uint drippedNext_ = add(dripped_, toDrip_, \"tautological\");\r\n\r\n    // Finally, write new `dripped` value and transfer tokens to target\r\n    dripped = drippedNext_;\r\n    token_.transfer(target_, toDrip_);\r\n\r\n    return toDrip_;\r\n  }\r\n\r\n  /* Internal helper functions for safe math */\r\n\r\n  function add(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    require(c >= a, errorMessage);\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n    require(b <= a, errorMessage);\r\n    uint c = a - b;\r\n    return c;\r\n  }\r\n\r\n  function mul(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint c = a * b;\r\n    require(c / a == b, errorMessage);\r\n    return c;\r\n  }\r\n\r\n  function min(uint a, uint b) internal pure returns (uint) {\r\n    if (a <= b) {\r\n      return a;\r\n    } else {\r\n      return b;\r\n    }\r\n  }\r\n}\r\n\r\nimport \"./EIP20Interface.sol\";\r\n"
    },
    "contracts/compound/WhitePaperInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\nimport \"../common/InterestRateModel.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\n/**\r\n  * @title debankex's WhitePaperInterestRateModel Contract\r\n  * @author debankex\r\n  * @notice The parameterized model described in section 2.4 of the original debankex Protocol whitepaper\r\n  */\r\ncontract WhitePaperInterestRateModel is InterestRateModel {\r\n    using SafeMath for uint;\r\n\r\n    event NewInterestParams(uint baseRatePerBlock, uint multiplierPerBlock);\r\n\r\n    /**\r\n     * @notice The approximate number of blocks per year that is assumed by the interest rate model\r\n     */\r\n    uint public constant blocksPerYear = 10512000;\r\n\r\n    /**\r\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\r\n     */\r\n    uint public multiplierPerBlock;\r\n\r\n    /**\r\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\r\n     */\r\n    uint public baseRatePerBlock;\r\n\r\n    /**\r\n     * @notice Construct an interest rate model\r\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\r\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\r\n     */\r\n    constructor(uint baseRatePerYear, uint multiplierPerYear) {\r\n        baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\r\n        multiplierPerBlock = multiplierPerYear.div(blocksPerYear);\r\n\r\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\r\n     * @param cash The amount of cash in the market\r\n     * @param borrows The amount of borrows in the market\r\n     * @param reserves The amount of reserves in the market (currently unused)\r\n     * @return The utilization rate as a mantissa between [0, 1e18]\r\n     */\r\n    function utilizationRate(uint cash, uint borrows, uint reserves) public pure returns (uint) {\r\n        // Utilization rate is 0 when there are no borrows\r\n        if (borrows == 0) {\r\n            return 0;\r\n        }\r\n\r\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\r\n     * @param cash The amount of cash in the market\r\n     * @param borrows The amount of borrows in the market\r\n     * @param reserves The amount of reserves in the market\r\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\r\n     */\r\n    function getBorrowRate(uint cash, uint borrows, uint reserves) override public view returns (uint) {\r\n        uint ur = utilizationRate(cash, borrows, reserves);\r\n        return ur.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the current supply rate per block\r\n     * @param cash The amount of cash in the market\r\n     * @param borrows The amount of borrows in the market\r\n     * @param reserves The amount of reserves in the market\r\n     * @param reserveFactorMantissa The current reserve factor for the market\r\n     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\r\n     */\r\n    function getSupplyRate(uint cash, uint borrows,\r\n                        uint reserves, uint reserveFactorMantissa) override public view returns (uint) {\r\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactorMantissa);\r\n        uint borrowRate = getBorrowRate(cash, borrows, reserves);\r\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\r\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\r\n    }\r\n}\r\n"
    },
    "contracts/compound/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\r\n// Subject to the MIT license.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction underflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/SwapRouter03.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity =0.7.6;\r\n\r\nimport \"./UniswapV2Router02.sol\";\r\n\r\ncontract SwapV2Router03 is UniswapV2Router02 {\r\n  address public lerc20Factory;\r\n\r\n  constructor(address _factory, address _WETH, address _lerc20Factory) UniswapV2Router02(_factory, _WETH) {\r\n      // factory = _factory;\r\n      // WETH = _WETH;\r\n      lerc20Factory = _lerc20Factory;\r\n  }\r\n}"
    },
    "contracts/swap/assets/Repurchase.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.6;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\r\n\r\nimport \"../../common/IMdexPair.sol\";\r\n\r\ncontract Repurchase is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    EnumerableSet.AddressSet private _caller;\r\n\r\n    address public constant USDT = 0xa71EdC38d189767582C38A3145b5873052c3e47a;\r\n    address public constant MDX = 0x25D2e80cB6B86881Fd7e07dd263Fb79f4AbE033c;\r\n    address public constant MDX_USDT = 0x615E6285c5944540fd8bd921c9c8c56739Fd1E13;\r\n    address public constant destroyAddress = 0xF9852C6588b70ad3c26daE47120f174527e03a25;\r\n    address public emergencyAddress;\r\n    uint256 public amountIn;\r\n\r\n    constructor (uint256 _amount, address _emergencyAddress) {\r\n        require(_amount > 0, \"Amount must be greater than zero\");\r\n        require(_emergencyAddress != address(0), \"Is zero address\");\r\n        amountIn = _amount;\r\n        emergencyAddress = _emergencyAddress;\r\n    }\r\n\r\n    function setAmountIn(uint256 _newIn) public onlyOwner {\r\n        amountIn = _newIn;\r\n    }\r\n\r\n    function setEmergencyAddress(address _newAddress) public onlyOwner {\r\n        require(_newAddress != address(0), \"Is zero address\");\r\n        emergencyAddress = _newAddress;\r\n    }\r\n\r\n    function addCaller(address _newCaller) public onlyOwner returns (bool) {\r\n        require(_newCaller != address(0), \"NewCaller is the zero address\");\r\n        return EnumerableSet.add(_caller, _newCaller);\r\n    }\r\n\r\n    function delCaller(address _delCaller) public onlyOwner returns (bool) {\r\n        require(_delCaller != address(0), \"DelCaller is the zero address\");\r\n        return EnumerableSet.remove(_caller, _delCaller);\r\n    }\r\n\r\n    function getCallerLength() public view returns (uint256) {\r\n        return EnumerableSet.length(_caller);\r\n    }\r\n\r\n    function isCaller(address _call) public view returns (bool) {\r\n        return EnumerableSet.contains(_caller, _call);\r\n    }\r\n\r\n    function getCaller(uint256 _index) public view returns (address){\r\n        require(_index <= getCallerLength() - 1, \"index out of bounds\");\r\n        return EnumerableSet.at(_caller, _index);\r\n    }\r\n\r\n    function swap() external onlyCaller returns (uint256 amountOut){\r\n        require(IERC20(USDT).balanceOf(address(this)) >= amountIn, \"Insufficient contract balance\");\r\n        (uint256 reserve0, uint256 reserve1,) = IMdexPair(MDX_USDT).getReserves();\r\n        uint256 amountInWithFee = amountIn.mul(997);\r\n        amountOut = amountIn.mul(997).mul(reserve0) / reserve1.mul(1000).add(amountInWithFee);\r\n        IERC20(USDT).safeTransfer(MDX_USDT, amountIn);\r\n        IMdexPair(MDX_USDT).swap(amountOut, 0, destroyAddress, new bytes(0));\r\n    }\r\n\r\n    modifier onlyCaller() {\r\n        require(isCaller(msg.sender), \"Not the caller\");\r\n        _;\r\n    }\r\n\r\n    function emergencyWithdraw(address _token) public onlyOwner {\r\n        require(IERC20(_token).balanceOf(address(this)) > 0, \"Insufficient contract balance\");\r\n        IERC20(_token).transfer(emergencyAddress, IERC20(_token).balanceOf(address(this)));\r\n    }\r\n}\r\n"
    },
    "contracts/swap/heco/HecoPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.6;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"../interface/IMdx.sol\";\r\n\r\ninterface IMasterChefHeco {\r\n    function pending(uint256 pid, address user) external view returns (uint256);\r\n\r\n    function deposit(uint256 pid, uint256 amount) external;\r\n\r\n    function withdraw(uint256 pid, uint256 amount) external;\r\n\r\n    function emergencyWithdraw(uint256 pid) external;\r\n}\r\n\r\ncontract HecoPool is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    EnumerableSet.AddressSet private _multLP;\r\n\r\n    // Info of each user.\r\n    struct UserInfo {\r\n        uint256 amount;     // How many LP tokens the user has provided.\r\n        uint256 rewardDebt; // Reward debt.\r\n        uint256 multLpRewardDebt; //multLp Reward debt.\r\n    }\r\n\r\n    // Info of each pool.\r\n    struct PoolInfo {\r\n        IERC20 lpToken;           // Address of LP token contract.\r\n        uint256 allocPoint;       // How many allocation points assigned to this pool. MDXs to distribute per block.\r\n        uint256 lastRewardBlock;  // Last block number that MDXs distribution occurs.\r\n        uint256 accMdxPerShare; // Accumulated MDXs per share, times 1e12.\r\n        uint256 accMultLpPerShare; //Accumulated multLp per share\r\n        uint256 totalAmount;    // Total amount of current pool deposit.\r\n    }\r\n\r\n    // The MDX Token!\r\n    IMdx public mdx;\r\n    // MDX tokens created per block.\r\n    uint256 public mdxPerBlock;\r\n    // Info of each pool.\r\n    PoolInfo[] public poolInfo;\r\n    // Info of each user that stakes LP tokens.\r\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n    // Corresponding to the pid of the multLP pool\r\n    mapping(uint256 => uint256) public poolCorrespond;\r\n    // pid corresponding address\r\n    mapping(address => uint256) public LpOfPid;\r\n    // Control mining\r\n    bool public paused = false;\r\n    // Total allocation points. Must be the sum of all allocation points in all pools.\r\n    uint256 public totalAllocPoint = 0;\r\n    // The block number when MDX mining starts.\r\n    uint256 public startBlock;\r\n    // multLP MasterChef\r\n    address public multLpChef;\r\n    // multLP Token\r\n    address public multLpToken;\r\n    // How many blocks are halved\r\n    uint256 public halvingPeriod = 5256000;\r\n\r\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n\r\n    constructor(\r\n        IMdx _mdx,\r\n        uint256 _mdxPerBlock,\r\n        uint256 _startBlock\r\n    ) {\r\n        mdx = _mdx;\r\n        mdxPerBlock = _mdxPerBlock;\r\n        startBlock = _startBlock;\r\n    }\r\n\r\n    function setHalvingPeriod(uint256 _block) public onlyOwner {\r\n        halvingPeriod = _block;\r\n    }\r\n\r\n    // Set the number of mdx produced by each block\r\n    function setMdxPerBlock(uint256 _newPerBlock) public onlyOwner {\r\n        massUpdatePools();\r\n        mdxPerBlock = _newPerBlock;\r\n    }\r\n\r\n    function poolLength() public view returns (uint256) {\r\n        return poolInfo.length;\r\n    }\r\n\r\n    function addMultLP(address _addLP) public onlyOwner returns (bool) {\r\n        require(_addLP != address(0), \"LP is the zero address\");\r\n        IERC20(_addLP).approve(multLpChef, uint256(- 1));\r\n        return EnumerableSet.add(_multLP, _addLP);\r\n    }\r\n\r\n    function isMultLP(address _LP) public view returns (bool) {\r\n        return EnumerableSet.contains(_multLP, _LP);\r\n    }\r\n\r\n    function getMultLPLength() public view returns (uint256) {\r\n        return EnumerableSet.length(_multLP);\r\n    }\r\n\r\n    function getMultLPAddress(uint256 _pid) public view returns (address){\r\n        require(_pid <= getMultLPLength() - 1, \"not find this multLP\");\r\n        return EnumerableSet.at(_multLP, _pid);\r\n    }\r\n\r\n    function setPause() public onlyOwner {\r\n        paused = !paused;\r\n    }\r\n\r\n    function setMultLP(address _multLpToken, address _multLpChef) public onlyOwner {\r\n        require(_multLpToken != address(0) && _multLpChef != address(0), \"is the zero address\");\r\n        multLpToken = _multLpToken;\r\n        multLpChef = _multLpChef;\r\n    }\r\n\r\n    function replaceMultLP(address _multLpToken, address _multLpChef) public onlyOwner {\r\n        require(_multLpToken != address(0) && _multLpChef != address(0), \"is the zero address\");\r\n        require(paused == true, \"No mining suspension\");\r\n        multLpToken = _multLpToken;\r\n        multLpChef = _multLpChef;\r\n        uint256 length = getMultLPLength();\r\n        while (length > 0) {\r\n            address dAddress = EnumerableSet.at(_multLP, 0);\r\n            uint256 pid = LpOfPid[dAddress];\r\n            IMasterChefHeco(multLpChef).emergencyWithdraw(poolCorrespond[pid]);\r\n            EnumerableSet.remove(_multLP, dAddress);\r\n            length--;\r\n        }\r\n    }\r\n\r\n    // Add a new lp to the pool. Can only be called by the owner.\r\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\r\n    function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner {\r\n        require(address(_lpToken) != address(0), \"_lpToken is the zero address\");\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\r\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\r\n        poolInfo.push(PoolInfo({\r\n        lpToken : _lpToken,\r\n        allocPoint : _allocPoint,\r\n        lastRewardBlock : lastRewardBlock,\r\n        accMdxPerShare : 0,\r\n        accMultLpPerShare : 0,\r\n        totalAmount : 0\r\n        }));\r\n        LpOfPid[address(_lpToken)] = poolLength() - 1;\r\n    }\r\n\r\n    // Update the given pool's MDX allocation point. Can only be called by the owner.\r\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner {\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\r\n        poolInfo[_pid].allocPoint = _allocPoint;\r\n    }\r\n\r\n    // The current pool corresponds to the pid of the multLP pool\r\n    function setPoolCorr(uint256 _pid, uint256 _sid) public onlyOwner {\r\n        require(_pid <= poolLength() - 1, \"not find this pool\");\r\n        poolCorrespond[_pid] = _sid;\r\n    }\r\n\r\n    function phase(uint256 blockNumber) public view returns (uint256) {\r\n        if (halvingPeriod == 0) {\r\n            return 0;\r\n        }\r\n        if (blockNumber > startBlock) {\r\n            return (blockNumber.sub(startBlock).sub(1)).div(halvingPeriod);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function reward(uint256 blockNumber) public view returns (uint256) {\r\n        uint256 _phase = phase(blockNumber);\r\n        return mdxPerBlock.div(2 ** _phase);\r\n    }\r\n\r\n    function getMdxBlockReward(uint256 _lastRewardBlock) public view returns (uint256) {\r\n        uint256 blockReward = 0;\r\n        uint256 n = phase(_lastRewardBlock);\r\n        uint256 m = phase(block.number);\r\n        while (n < m) {\r\n            n++;\r\n            uint256 r = n.mul(halvingPeriod).add(startBlock);\r\n            blockReward = blockReward.add((r.sub(_lastRewardBlock)).mul(reward(r)));\r\n            _lastRewardBlock = r;\r\n        }\r\n        blockReward = blockReward.add((block.number.sub(_lastRewardBlock)).mul(reward(block.number)));\r\n        return blockReward;\r\n    }\r\n\r\n    // Update reward variables for all pools. Be careful of gas spending!\r\n    function massUpdatePools() public {\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            updatePool(pid);\r\n        }\r\n    }\r\n\r\n    // Update reward variables of the given pool to be up-to-date.\r\n    function updatePool(uint256 _pid) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (block.number <= pool.lastRewardBlock) {\r\n            return;\r\n        }\r\n        uint256 lpSupply;\r\n        if (isMultLP(address(pool.lpToken))) {\r\n            if (pool.totalAmount == 0) {\r\n                pool.lastRewardBlock = block.number;\r\n                return;\r\n            }\r\n            lpSupply = pool.totalAmount;\r\n        } else {\r\n            lpSupply = pool.lpToken.balanceOf(address(this));\r\n            if (lpSupply == 0) {\r\n                pool.lastRewardBlock = block.number;\r\n                return;\r\n            }\r\n        }\r\n        uint256 blockReward = getMdxBlockReward(pool.lastRewardBlock);\r\n        if (blockReward <= 0) {\r\n            return;\r\n        }\r\n        uint256 mdxReward = blockReward.mul(pool.allocPoint).div(totalAllocPoint);\r\n        bool minRet = mdx.mint(address(this), mdxReward);\r\n        if (minRet) {\r\n            pool.accMdxPerShare = pool.accMdxPerShare.add(mdxReward.mul(1e12).div(lpSupply));\r\n        }\r\n        pool.lastRewardBlock = block.number;\r\n    }\r\n\r\n    // View function to see pending MDXs on frontend.\r\n    function pending(uint256 _pid, address _user) external view returns (uint256, uint256){\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (isMultLP(address(pool.lpToken))) {\r\n            (uint256 mdxAmount, uint256 tokenAmount) = pendingMdxAndToken(_pid, _user);\r\n            return (mdxAmount, tokenAmount);\r\n        } else {\r\n            uint256 mdxAmount = pendingMdx(_pid, _user);\r\n            return (mdxAmount, 0);\r\n        }\r\n    }\r\n\r\n    function pendingMdxAndToken(uint256 _pid, address _user) private view returns (uint256, uint256){\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        uint256 accMdxPerShare = pool.accMdxPerShare;\r\n        uint256 accMultLpPerShare = pool.accMultLpPerShare;\r\n        if (user.amount > 0) {\r\n            uint256 TokenPending = IMasterChefHeco(multLpChef).pending(poolCorrespond[_pid], address(this));\r\n            accMultLpPerShare = accMultLpPerShare.add(TokenPending.mul(1e12).div(pool.totalAmount));\r\n            uint256 userPending = user.amount.mul(accMultLpPerShare).div(1e12).sub(user.multLpRewardDebt);\r\n            if (block.number > pool.lastRewardBlock) {\r\n                uint256 blockReward = getMdxBlockReward(pool.lastRewardBlock);\r\n                uint256 mdxReward = blockReward.mul(pool.allocPoint).div(totalAllocPoint);\r\n                accMdxPerShare = accMdxPerShare.add(mdxReward.mul(1e12).div(pool.totalAmount));\r\n                return (user.amount.mul(accMdxPerShare).div(1e12).sub(user.rewardDebt), userPending);\r\n            }\r\n            if (block.number == pool.lastRewardBlock) {\r\n                return (user.amount.mul(accMdxPerShare).div(1e12).sub(user.rewardDebt), userPending);\r\n            }\r\n        }\r\n        return (0, 0);\r\n    }\r\n\r\n    function pendingMdx(uint256 _pid, address _user) private view returns (uint256){\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        uint256 accMdxPerShare = pool.accMdxPerShare;\r\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\r\n        if (user.amount > 0) {\r\n            if (block.number > pool.lastRewardBlock) {\r\n                uint256 blockReward = getMdxBlockReward(pool.lastRewardBlock);\r\n                uint256 mdxReward = blockReward.mul(pool.allocPoint).div(totalAllocPoint);\r\n                accMdxPerShare = accMdxPerShare.add(mdxReward.mul(1e12).div(lpSupply));\r\n                return user.amount.mul(accMdxPerShare).div(1e12).sub(user.rewardDebt);\r\n            }\r\n            if (block.number == pool.lastRewardBlock) {\r\n                return user.amount.mul(accMdxPerShare).div(1e12).sub(user.rewardDebt);\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    // Deposit LP tokens to HecoPool for MDX allocation.\r\n    function deposit(uint256 _pid, uint256 _amount) public notPause {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (isMultLP(address(pool.lpToken))) {\r\n            depositMdxAndToken(_pid, _amount, msg.sender);\r\n        } else {\r\n            depositMdx(_pid, _amount, msg.sender);\r\n        }\r\n    }\r\n\r\n    function depositMdxAndToken(uint256 _pid, uint256 _amount, address _user) private {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        updatePool(_pid);\r\n        if (user.amount > 0) {\r\n            uint256 pendingAmount = user.amount.mul(pool.accMdxPerShare).div(1e12).sub(user.rewardDebt);\r\n            if (pendingAmount > 0) {\r\n                safeMdxTransfer(_user, pendingAmount);\r\n            }\r\n            uint256 beforeToken = IERC20(multLpToken).balanceOf(address(this));\r\n            IMasterChefHeco(multLpChef).deposit(poolCorrespond[_pid], 0);\r\n            uint256 afterToken = IERC20(multLpToken).balanceOf(address(this));\r\n            pool.accMultLpPerShare = pool.accMultLpPerShare.add(afterToken.sub(beforeToken).mul(1e12).div(pool.totalAmount));\r\n            uint256 tokenPending = user.amount.mul(pool.accMultLpPerShare).div(1e12).sub(user.multLpRewardDebt);\r\n            if (tokenPending > 0) {\r\n                IERC20(multLpToken).safeTransfer(_user, tokenPending);\r\n            }\r\n        }\r\n        if (_amount > 0) {\r\n            pool.lpToken.safeTransferFrom(_user, address(this), _amount);\r\n            if (pool.totalAmount == 0) {\r\n                IMasterChefHeco(multLpChef).deposit(poolCorrespond[_pid], _amount);\r\n                user.amount = user.amount.add(_amount);\r\n                pool.totalAmount = pool.totalAmount.add(_amount);\r\n            } else {\r\n                uint256 beforeToken = IERC20(multLpToken).balanceOf(address(this));\r\n                IMasterChefHeco(multLpChef).deposit(poolCorrespond[_pid], _amount);\r\n                uint256 afterToken = IERC20(multLpToken).balanceOf(address(this));\r\n                pool.accMultLpPerShare = pool.accMultLpPerShare.add(afterToken.sub(beforeToken).mul(1e12).div(pool.totalAmount));\r\n                user.amount = user.amount.add(_amount);\r\n                pool.totalAmount = pool.totalAmount.add(_amount);\r\n            }\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accMdxPerShare).div(1e12);\r\n        user.multLpRewardDebt = user.amount.mul(pool.accMultLpPerShare).div(1e12);\r\n        emit Deposit(_user, _pid, _amount);\r\n    }\r\n\r\n    function depositMdx(uint256 _pid, uint256 _amount, address _user) private {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        updatePool(_pid);\r\n        if (user.amount > 0) {\r\n            uint256 pendingAmount = user.amount.mul(pool.accMdxPerShare).div(1e12).sub(user.rewardDebt);\r\n            if (pendingAmount > 0) {\r\n                safeMdxTransfer(_user, pendingAmount);\r\n            }\r\n        }\r\n        if (_amount > 0) {\r\n            pool.lpToken.safeTransferFrom(_user, address(this), _amount);\r\n            user.amount = user.amount.add(_amount);\r\n            pool.totalAmount = pool.totalAmount.add(_amount);\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accMdxPerShare).div(1e12);\r\n        emit Deposit(_user, _pid, _amount);\r\n    }\r\n\r\n    // Withdraw LP tokens from HecoPool.\r\n    function withdraw(uint256 _pid, uint256 _amount) public notPause {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (isMultLP(address(pool.lpToken))) {\r\n            withdrawMdxAndToken(_pid, _amount, msg.sender);\r\n        } else {\r\n            withdrawMdx(_pid, _amount, msg.sender);\r\n        }\r\n    }\r\n\r\n    function withdrawMdxAndToken(uint256 _pid, uint256 _amount, address _user) private {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        require(user.amount >= _amount, \"withdrawMdxAndToken: not good\");\r\n        updatePool(_pid);\r\n        uint256 pendingAmount = user.amount.mul(pool.accMdxPerShare).div(1e12).sub(user.rewardDebt);\r\n        if (pendingAmount > 0) {\r\n            safeMdxTransfer(_user, pendingAmount);\r\n        }\r\n        if (_amount > 0) {\r\n            uint256 beforeToken = IERC20(multLpToken).balanceOf(address(this));\r\n            IMasterChefHeco(multLpChef).withdraw(poolCorrespond[_pid], _amount);\r\n            uint256 afterToken = IERC20(multLpToken).balanceOf(address(this));\r\n            pool.accMultLpPerShare = pool.accMultLpPerShare.add(afterToken.sub(beforeToken).mul(1e12).div(pool.totalAmount));\r\n            uint256 tokenPending = user.amount.mul(pool.accMultLpPerShare).div(1e12).sub(user.multLpRewardDebt);\r\n            if (tokenPending > 0) {\r\n                IERC20(multLpToken).safeTransfer(_user, tokenPending);\r\n            }\r\n            user.amount = user.amount.sub(_amount);\r\n            pool.totalAmount = pool.totalAmount.sub(_amount);\r\n            pool.lpToken.safeTransfer(_user, _amount);\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accMdxPerShare).div(1e12);\r\n        user.multLpRewardDebt = user.amount.mul(pool.accMultLpPerShare).div(1e12);\r\n        emit Withdraw(_user, _pid, _amount);\r\n    }\r\n\r\n    function withdrawMdx(uint256 _pid, uint256 _amount, address _user) private {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        require(user.amount >= _amount, \"withdrawMdx: not good\");\r\n        updatePool(_pid);\r\n        uint256 pendingAmount = user.amount.mul(pool.accMdxPerShare).div(1e12).sub(user.rewardDebt);\r\n        if (pendingAmount > 0) {\r\n            safeMdxTransfer(_user, pendingAmount);\r\n        }\r\n        if (_amount > 0) {\r\n            user.amount = user.amount.sub(_amount);\r\n            pool.totalAmount = pool.totalAmount.sub(_amount);\r\n            pool.lpToken.safeTransfer(_user, _amount);\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accMdxPerShare).div(1e12);\r\n        emit Withdraw(_user, _pid, _amount);\r\n    }\r\n\r\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\r\n    function emergencyWithdraw(uint256 _pid) public notPause {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (isMultLP(address(pool.lpToken))) {\r\n            emergencyWithdrawMdxAndToken(_pid, msg.sender);\r\n        } else {\r\n            emergencyWithdrawMdx(_pid, msg.sender);\r\n        }\r\n    }\r\n\r\n    function emergencyWithdrawMdxAndToken(uint256 _pid, address _user) private {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        uint256 amount = user.amount;\r\n        uint256 beforeToken = IERC20(multLpToken).balanceOf(address(this));\r\n        IMasterChefHeco(multLpChef).withdraw(poolCorrespond[_pid], amount);\r\n        uint256 afterToken = IERC20(multLpToken).balanceOf(address(this));\r\n        pool.accMultLpPerShare = pool.accMultLpPerShare.add(afterToken.sub(beforeToken).mul(1e12).div(pool.totalAmount));\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n        pool.lpToken.safeTransfer(_user, amount);\r\n        pool.totalAmount = pool.totalAmount.sub(amount);\r\n        emit EmergencyWithdraw(_user, _pid, amount);\r\n    }\r\n\r\n    function emergencyWithdrawMdx(uint256 _pid, address _user) private {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        uint256 amount = user.amount;\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n        pool.lpToken.safeTransfer(_user, amount);\r\n        pool.totalAmount = pool.totalAmount.sub(amount);\r\n        emit EmergencyWithdraw(_user, _pid, amount);\r\n    }\r\n\r\n    // Safe MDX transfer function, just in case if rounding error causes pool to not have enough MDXs.\r\n    function safeMdxTransfer(address _to, uint256 _amount) internal {\r\n        uint256 mdxBal = mdx.balanceOf(address(this));\r\n        if (_amount > mdxBal) {\r\n            mdx.transfer(_to, mdxBal);\r\n        } else {\r\n            mdx.transfer(_to, _amount);\r\n        }\r\n    }\r\n\r\n    modifier notPause() {\r\n        require(paused == false, \"Mining has been suspended\");\r\n        _;\r\n    }\r\n}\r\n"
    },
    "contracts/swap/timeLock/TeamTimeLock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity =0.7.6;\r\n\r\nimport '@openzeppelin/contracts/math/SafeMath.sol';\r\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\r\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\r\n\r\n\r\ncontract TeamTimeLock {\r\n    using SafeMath for uint;\r\n    using SafeERC20 for IERC20;\r\n\r\n    IERC20 public token;\r\n    uint constant  public PERIOD = 30 days;\r\n    uint constant  public CYCLE_TIMES = 24;\r\n    uint public fixedQuantity;  // Monthly rewards are fixed\r\n    uint public startTime;\r\n    uint public delay;\r\n    uint public cycle;      // cycle already received\r\n    uint public hasReward;  // Rewards already withdrawn\r\n    address public beneficiary;\r\n    string public introduce;\r\n\r\n    event WithDraw(address indexed operator, address indexed to, uint amount);\r\n\r\n    constructor(\r\n        address _beneficiary,\r\n        address _token,\r\n        uint _fixedQuantity,\r\n        uint _startTime,\r\n        uint _delay,\r\n        string memory _introduce\r\n    ) {\r\n        require(_beneficiary != address(0) && _token != address(0), \"TimeLock: zero address\");\r\n        require(_fixedQuantity > 0, \"TimeLock: fixedQuantity is zero\");\r\n        beneficiary = _beneficiary;\r\n        token = IERC20(_token);\r\n        fixedQuantity = _fixedQuantity;\r\n        delay = _delay;\r\n        startTime = _startTime.add(_delay);\r\n        introduce = _introduce;\r\n    }\r\n\r\n\r\n    function getBalance() public view returns (uint) {\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    function getReward() public view returns (uint) {\r\n        // Has ended or not started\r\n        if (cycle >= CYCLE_TIMES || block.timestamp <= startTime) {\r\n            return 0;\r\n        }\r\n        uint pCycle = (block.timestamp.sub(startTime)).div(PERIOD);\r\n        if (pCycle >= CYCLE_TIMES) {\r\n            return token.balanceOf(address(this));\r\n        }\r\n        return pCycle.sub(cycle).mul(fixedQuantity);\r\n    }\r\n\r\n    function withDraw() external {\r\n        uint reward = getReward();\r\n        require(reward > 0, \"TimeLock: no reward\");\r\n        uint pCycle = (block.timestamp.sub(startTime)).div(PERIOD);\r\n        cycle = pCycle >= CYCLE_TIMES ? CYCLE_TIMES : pCycle;\r\n        hasReward = hasReward.add(reward);\r\n        token.safeTransfer(beneficiary, reward);\r\n        emit WithDraw(msg.sender, beneficiary, reward);\r\n    }\r\n\r\n    // Update beneficiary address by the previous beneficiary.\r\n    function setBeneficiary(address _newBeneficiary) public {\r\n        require(msg.sender == beneficiary, \"Not beneficiary\");\r\n        beneficiary = _newBeneficiary;\r\n    }\r\n}\r\n"
    },
    "contracts/swap/assets/AirdropMDX.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.6;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\n\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n}\r\n\r\ncontract AirdropMDX is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    struct UserInfo {\r\n        uint256 amount;\r\n        uint256 rewardDebt;\r\n    }\r\n\r\n    struct PoolInfo {\r\n        IERC20 lpToken;\r\n        uint256 allocPoint;\r\n        uint256 lastRewardBlock;\r\n        uint256 accMDXPerShare;\r\n        uint256 mdxAmount;\r\n    }\r\n\r\n    address public mdx;\r\n    // Airdrop tokens for per block.\r\n    uint256 public mdxPerBlock;\r\n    // Info of each pool.\r\n    PoolInfo[] public poolInfo;\r\n    // Info of each user that stakes LP tokens.\r\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n    // Total allocation points. Must be the sum of all allocation points in all pools.\r\n    uint256 public totalAllocPoint = 0;\r\n    // The block number when mdx mining starts.\r\n    uint256 public startBlock;\r\n    // The block number when mdx mining end;\r\n    uint256 public endBlock;\r\n    // Airdrop cycle default 1day\r\n    uint256 public cycle;\r\n\r\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n\r\n    constructor(\r\n        address _mdx,\r\n        uint256 _cycle\r\n    ) {\r\n        mdx = _mdx;\r\n        cycle = _cycle;\r\n    }\r\n\r\n    function poolLength() external view returns (uint256) {\r\n        return poolInfo.length;\r\n    }\r\n\r\n    function newAirdrop(uint256 _mdxAmount, uint256 _newPerBlock, uint256 _startBlock) public onlyOwner {\r\n        require(block.number > endBlock && _startBlock >= endBlock, \"Not finished\");\r\n        massUpdatePools();\r\n        uint256 beforeAmount = IERC20(mdx).balanceOf(address(this));\r\n        TransferHelper.safeTransferFrom(mdx, msg.sender, address(this), _mdxAmount);\r\n        uint256 afterAmount = IERC20(mdx).balanceOf(address(this));\r\n        uint256 balance = afterAmount.sub(beforeAmount);\r\n        require(balance == _mdxAmount, \"Error balance\");\r\n        require(balance > 0 && (cycle * _newPerBlock) <= balance, \"Balance not enough\");\r\n        mdxPerBlock = _newPerBlock;\r\n        startBlock = _startBlock;\r\n        endBlock = _startBlock.add(cycle);\r\n        updatePoolLastRewardBlock(_startBlock);\r\n    }\r\n\r\n    function updatePoolLastRewardBlock(uint256 _lastRewardBlock) private {\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            PoolInfo storage pool = poolInfo[pid];\r\n            pool.lastRewardBlock = _lastRewardBlock;\r\n        }\r\n    }\r\n\r\n    function setCycle(uint256 _newCycle) public onlyOwner {\r\n        cycle = _newCycle;\r\n    }\r\n\r\n    // Add a new lp to the pool. Can only be called by the owner.\r\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\r\n    function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner {\r\n        require(address(_lpToken) != address(0), \"lpToken is the zero address\");\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\r\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\r\n        poolInfo.push(PoolInfo({\r\n        lpToken : _lpToken,\r\n        allocPoint : _allocPoint,\r\n        lastRewardBlock : lastRewardBlock,\r\n        accMDXPerShare : 0,\r\n        mdxAmount : 0\r\n        }));\r\n    }\r\n\r\n    // Update the given pool's wht allocation point. Can only be called by the owner.\r\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner {\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\r\n        poolInfo[_pid].allocPoint = _allocPoint;\r\n    }\r\n\r\n    // Update reward variables for all pools. Be careful of gas spending!\r\n    function massUpdatePools() public {\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            updatePool(pid);\r\n        }\r\n    }\r\n\r\n    // Update reward variables of the given pool to be up-to-date.\r\n    function updatePool(uint256 _pid) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        uint256 number = block.number > endBlock ? endBlock : block.number;\r\n        if (number <= pool.lastRewardBlock) {\r\n            return;\r\n        }\r\n        uint256 lpSupply;\r\n        if (address(pool.lpToken) == mdx) {\r\n            lpSupply = pool.mdxAmount;\r\n        } else {\r\n            lpSupply = pool.lpToken.balanceOf(address(this));\r\n        }\r\n        if (lpSupply == 0) {\r\n            pool.lastRewardBlock = number;\r\n            return;\r\n        }\r\n        uint256 multiplier = number.sub(pool.lastRewardBlock);\r\n        uint256 mdxReward = multiplier.mul(mdxPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\r\n        pool.accMDXPerShare = pool.accMDXPerShare.add(mdxReward.mul(1e12).div(lpSupply));\r\n        pool.lastRewardBlock = number;\r\n    }\r\n\r\n\r\n    function pending(uint256 _pid, address _user) external view returns (uint256) {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        uint256 accMDXPerShare = pool.accMDXPerShare;\r\n        uint256 lpSupply;\r\n        if (address(pool.lpToken) == mdx) {\r\n            lpSupply = pool.mdxAmount;\r\n        } else {\r\n            lpSupply = pool.lpToken.balanceOf(address(this));\r\n        }\r\n        uint256 number = block.number > endBlock ? endBlock : block.number;\r\n        if (number > pool.lastRewardBlock && lpSupply != 0) {\r\n            uint256 multiplier = number.sub(pool.lastRewardBlock);\r\n            uint256 mdxReward = multiplier.mul(mdxPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\r\n            accMDXPerShare = accMDXPerShare.add(mdxReward.mul(1e12).div(lpSupply));\r\n        }\r\n        return user.amount.mul(accMDXPerShare).div(1e12).sub(user.rewardDebt);\r\n    }\r\n\r\n\r\n    // Deposit LP tokens dividends WHT;\r\n    function deposit(uint256 _pid, uint256 _amount) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        updatePool(_pid);\r\n        if (user.amount > 0) {\r\n            uint256 pendingAmount = user.amount.mul(pool.accMDXPerShare).div(1e12).sub(user.rewardDebt);\r\n            if (pendingAmount > 0) {\r\n                safeMDXTransfer(msg.sender, pendingAmount, pool.mdxAmount);\r\n            }\r\n        }\r\n        if (_amount > 0) {\r\n            pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\r\n            user.amount = user.amount.add(_amount);\r\n            if (address(pool.lpToken) == mdx) {\r\n                pool.mdxAmount = pool.mdxAmount.add(_amount);\r\n            }\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accMDXPerShare).div(1e12);\r\n        emit Deposit(msg.sender, _pid, _amount);\r\n    }\r\n\r\n    // Withdraw LP tokens.\r\n    function withdraw(uint256 _pid, uint256 _amount) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        require(user.amount >= _amount, \"withdraw: not good\");\r\n        updatePool(_pid);\r\n        uint256 pendingAmount = user.amount.mul(pool.accMDXPerShare).div(1e12).sub(user.rewardDebt);\r\n        if (pendingAmount > 0) {\r\n            safeMDXTransfer(msg.sender, pendingAmount, pool.mdxAmount);\r\n        }\r\n        if (_amount > 0) {\r\n            user.amount = user.amount.sub(_amount);\r\n            if (address(pool.lpToken) == mdx) {\r\n                pool.mdxAmount = pool.mdxAmount.sub(_amount);\r\n            }\r\n            pool.lpToken.safeTransfer(address(msg.sender), _amount);\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accMDXPerShare).div(1e12);\r\n        emit Withdraw(msg.sender, _pid, _amount);\r\n    }\r\n\r\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\r\n    function emergencyWithdraw(uint256 _pid) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        uint256 amount = user.amount;\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n        if (address(pool.lpToken) == mdx) {\r\n            pool.mdxAmount = pool.mdxAmount.sub(amount);\r\n        }\r\n        pool.lpToken.safeTransfer(address(msg.sender), amount);\r\n        emit EmergencyWithdraw(msg.sender, _pid, amount);\r\n    }\r\n\r\n    // Safe mdx transfer function, just in case if rounding error causes pool to not have enough mdxs.\r\n    function safeMDXTransfer(address _to, uint256 _amount, uint256 _poolMDXAmount) internal {\r\n        uint256 mdxBalance = IERC20(mdx).balanceOf(address(this));\r\n        mdxBalance = mdxBalance.sub(_poolMDXAmount);\r\n        if (_amount > mdxBalance) {\r\n            IERC20(mdx).transfer(_to, mdxBalance);\r\n        } else {\r\n            IERC20(mdx).transfer(_to, _amount);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/swap/assets/Airdrop.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.6;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n}\r\n\r\ninterface IWHT {\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n}\r\n\r\ncontract Airdrop is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    struct UserInfo {\r\n        uint256 amount;\r\n        uint256 rewardDebt;\r\n    }\r\n\r\n    struct PoolInfo {\r\n        IERC20 lpToken;\r\n        uint256 allocPoint;\r\n        uint256 lastRewardBlock;\r\n        uint256 accWhtPerShare;\r\n    }\r\n\r\n    IWHT public wht;\r\n    // Airdrop tokens for per block.\r\n    uint256 public whtPerBlock;\r\n    // Info of each pool.\r\n    PoolInfo[] public poolInfo;\r\n    // Info of each user that stakes LP tokens.\r\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n    // Total allocation points. Must be the sum of all allocation points in all pools.\r\n    uint256 public totalAllocPoint = 0;\r\n    // The block number when wht mining starts.\r\n    uint256 public startBlock;\r\n    // The block number when wht mining end;\r\n    uint256 public endBlock;\r\n    // Airdrop cycle default 1day\r\n    uint256 public cycle;\r\n\r\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n\r\n    constructor(\r\n        IWHT _wht,\r\n        uint256 _cycle\r\n    ) {\r\n        wht = _wht;\r\n        cycle = _cycle;\r\n    }\r\n\r\n    function poolLength() external view returns (uint256) {\r\n        return poolInfo.length;\r\n    }\r\n\r\n    function newAirdrop(uint256 _whtAmount, uint256 _newPerBlock, uint256 _startBlock) public onlyOwner {\r\n        require(block.number > endBlock && _startBlock >= endBlock, \"Not finished\");\r\n        massUpdatePools();\r\n        uint256 beforeAmount = IWHT(wht).balanceOf(address(this));\r\n        TransferHelper.safeTransferFrom(address(wht), msg.sender, address(this), _whtAmount);\r\n        uint256 afterAmount = IWHT(wht).balanceOf(address(this));\r\n        uint256 balance = afterAmount.sub(beforeAmount);\r\n        require(balance == _whtAmount, \"Error balance\");\r\n        require(balance > 0 && (cycle * _newPerBlock) <= balance, \"Balance not enough\");\r\n        whtPerBlock = _newPerBlock;\r\n        startBlock = _startBlock;\r\n        endBlock = _startBlock.add(cycle);\r\n        updatePoolLastRewardBlock(_startBlock);\r\n    }\r\n\r\n    function updatePoolLastRewardBlock(uint256 _lastRewardBlock) private {\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            PoolInfo storage pool = poolInfo[pid];\r\n            pool.lastRewardBlock = _lastRewardBlock;\r\n        }\r\n    }\r\n\r\n    function setCycle(uint256 _newCycle) public onlyOwner {\r\n        cycle = _newCycle;\r\n    }\r\n\r\n    // Add a new lp to the pool. Can only be called by the owner.\r\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\r\n    function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner {\r\n        require(address(_lpToken) != address(0), \"lpToken is the zero address\");\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\r\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\r\n        poolInfo.push(PoolInfo({\r\n        lpToken : _lpToken,\r\n        allocPoint : _allocPoint,\r\n        lastRewardBlock : lastRewardBlock,\r\n        accWhtPerShare : 0\r\n        }));\r\n    }\r\n\r\n    // Update the given pool's wht allocation point. Can only be called by the owner.\r\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner {\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\r\n        poolInfo[_pid].allocPoint = _allocPoint;\r\n    }\r\n\r\n    // Update reward variables for all pools. Be careful of gas spending!\r\n    function massUpdatePools() public {\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            updatePool(pid);\r\n        }\r\n    }\r\n\r\n    // Update reward variables of the given pool to be up-to-date.\r\n    function updatePool(uint256 _pid) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        uint256 number = block.number > endBlock ? endBlock : block.number;\r\n        if (number <= pool.lastRewardBlock) {\r\n            return;\r\n        }\r\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\r\n        if (lpSupply == 0) {\r\n            pool.lastRewardBlock = number;\r\n            return;\r\n        }\r\n        uint256 multiplier = number.sub(pool.lastRewardBlock);\r\n        uint256 whtReward = multiplier.mul(whtPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\r\n        pool.accWhtPerShare = pool.accWhtPerShare.add(whtReward.mul(1e12).div(lpSupply));\r\n        pool.lastRewardBlock = number;\r\n    }\r\n\r\n\r\n    function pending(uint256 _pid, address _user) external view returns (uint256) {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        uint256 accWhtPerShare = pool.accWhtPerShare;\r\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\r\n        uint256 number = block.number > endBlock ? endBlock : block.number;\r\n        if (number > pool.lastRewardBlock && lpSupply != 0) {\r\n            uint256 multiplier = number.sub(pool.lastRewardBlock);\r\n            uint256 whtReward = multiplier.mul(whtPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\r\n            accWhtPerShare = accWhtPerShare.add(whtReward.mul(1e12).div(lpSupply));\r\n        }\r\n        return user.amount.mul(accWhtPerShare).div(1e12).sub(user.rewardDebt);\r\n    }\r\n\r\n\r\n    // Deposit LP tokens dividends WHT;\r\n    function deposit(uint256 _pid, uint256 _amount) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        updatePool(_pid);\r\n        if (user.amount > 0) {\r\n            uint256 pendingAmount = user.amount.mul(pool.accWhtPerShare).div(1e12).sub(user.rewardDebt);\r\n            if (pendingAmount > 0) {\r\n                safeWhtTransfer(msg.sender, pendingAmount);\r\n            }\r\n        }\r\n        if (_amount > 0) {\r\n            pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\r\n            user.amount = user.amount.add(_amount);\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accWhtPerShare).div(1e12);\r\n        emit Deposit(msg.sender, _pid, _amount);\r\n    }\r\n\r\n    // Withdraw LP tokens.\r\n    function withdraw(uint256 _pid, uint256 _amount) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        require(user.amount >= _amount, \"withdraw: not good\");\r\n        updatePool(_pid);\r\n        uint256 pendingAmount = user.amount.mul(pool.accWhtPerShare).div(1e12).sub(user.rewardDebt);\r\n        if (pendingAmount > 0) {\r\n            safeWhtTransfer(msg.sender, pendingAmount);\r\n        }\r\n        if (_amount > 0) {\r\n            user.amount = user.amount.sub(_amount);\r\n            pool.lpToken.safeTransfer(address(msg.sender), _amount);\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accWhtPerShare).div(1e12);\r\n        emit Withdraw(msg.sender, _pid, _amount);\r\n    }\r\n\r\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\r\n    function emergencyWithdraw(uint256 _pid) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        uint256 amount = user.amount;\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n        pool.lpToken.safeTransfer(address(msg.sender), amount);\r\n        emit EmergencyWithdraw(msg.sender, _pid, amount);\r\n    }\r\n\r\n    // Safe wht transfer function, just in case if rounding error causes pool to not have enough whts.\r\n    function safeWhtTransfer(address _to, uint256 _amount) internal {\r\n        uint256 whtBal = IWHT(wht).balanceOf(address(this));\r\n        if (_amount > whtBal) {\r\n            wht.transfer(_to, whtBal);\r\n        } else {\r\n            wht.transfer(_to, _amount);\r\n        }\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/swap/mainnet/MdxToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.6;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract MdxToken is ERC20(\"MDX Token\", \"MDX\"){\r\n    address public minter;\r\n\r\n    // mint with max supply\r\n    function mint(address _to, uint256 _amount) public onlyMinter returns (bool) {\r\n        _mint(_to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function setMinter(address _newMinter) external {\r\n        require(minter == address(0), \"has set up\");\r\n        require(_newMinter != address(0), \"is zero address\");\r\n        minter = _newMinter;\r\n    }\r\n    // modifier for mint function\r\n    modifier onlyMinter() {\r\n        require(msg.sender == minter, \"caller is not the minter\");\r\n        _;\r\n    }\r\n}\r\n"
    },
    "contracts/swap/heco/MdxTokenHeco.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\r\n\r\nabstract contract DelegateERC20 is ERC20 {\r\n    using SafeMath for uint256;\r\n    // @notice A record of each accounts delegate\r\n    mapping (address => address) internal _delegates;\r\n\r\n    /// @notice A checkpoint for marking number of votes from a given block\r\n    struct Checkpoint {\r\n        uint32 fromBlock;\r\n        uint256 votes;\r\n    }\r\n\r\n    /// @notice A record of votes checkpoints for each account, by index\r\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\r\n\r\n    /// @notice The number of checkpoints for each account\r\n    mapping (address => uint32) public numCheckpoints;\r\n\r\n    /// @notice The EIP-712 typehash for the contract's domain\r\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n\r\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\r\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\r\n\r\n    /// @notice A record of states for signing / validating signatures\r\n    mapping (address => uint) public nonces;\r\n\r\n\r\n    // support delegates mint\r\n    function _mint(address account, uint256 amount) internal override virtual {\r\n        super._mint(account, amount);\r\n\r\n        // add delegates to the minter\r\n        _moveDelegates(address(0), _delegates[account], amount);\r\n    }\r\n\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal override virtual {\r\n        super._transfer(sender, recipient, amount);\r\n        _moveDelegates(_delegates[sender], _delegates[recipient], amount);\r\n    }\r\n\r\n\r\n    /**\r\n    * @notice Delegate votes from `msg.sender` to `delegatee`\r\n    * @param delegatee The address to delegate votes to\r\n    */\r\n    function delegate(address delegatee) external {\r\n        return _delegate(msg.sender, delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates votes from signatory to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     * @param nonce The contract state required to match the signature\r\n     * @param expiry The time at which to expire the signature\r\n     * @param v The recovery byte of the signature\r\n     * @param r Half of the ECDSA signature pair\r\n     * @param s Half of the ECDSA signature pair\r\n     */\r\n    function delegateBySig(\r\n        address delegatee,\r\n        uint nonce,\r\n        uint expiry,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n    external\r\n    {\r\n        bytes32 domainSeparator = keccak256(\r\n            abi.encode(\r\n                DOMAIN_TYPEHASH,\r\n                keccak256(bytes(name())),\r\n                getChainId(),\r\n                address(this)\r\n            )\r\n        );\r\n\r\n        bytes32 structHash = keccak256(\r\n            abi.encode(\r\n                DELEGATION_TYPEHASH,\r\n                delegatee,\r\n                nonce,\r\n                expiry\r\n            )\r\n        );\r\n\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                domainSeparator,\r\n                structHash\r\n            )\r\n        );\r\n\r\n        address signatory = ecrecover(digest, v, r, s);\r\n        require(signatory != address(0), \"MdxToken::delegateBySig: invalid signature\");\r\n        require(nonce == nonces[signatory]++, \"MdxToken::delegateBySig: invalid nonce\");\r\n        require(block.timestamp <= expiry, \"MdxToken::delegateBySig: signature expired\");\r\n        return _delegate(signatory, delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current votes balance for `account`\r\n     * @param account The address to get votes balance\r\n     * @return The number of current votes for `account`\r\n     */\r\n    function getCurrentVotes(address account)\r\n    external\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the prior number of votes for an account as of a block number\r\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\r\n     * @param account The address of the account to check\r\n     * @param blockNumber The block number to get the vote balance at\r\n     * @return The number of votes the account had as of the given block\r\n     */\r\n    function getPriorVotes(address account, uint blockNumber)\r\n    external\r\n    view\r\n    returns (uint256)\r\n    {\r\n        require(blockNumber < block.number, \"MdxToken::getPriorVotes: not yet determined\");\r\n\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        if (nCheckpoints == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // First check most recent balance\r\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\r\n            return checkpoints[account][nCheckpoints - 1].votes;\r\n        }\r\n\r\n        // Next check implicit zero balance\r\n        if (checkpoints[account][0].fromBlock > blockNumber) {\r\n            return 0;\r\n        }\r\n\r\n        uint32 lower = 0;\r\n        uint32 upper = nCheckpoints - 1;\r\n        while (upper > lower) {\r\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\r\n            Checkpoint memory cp = checkpoints[account][center];\r\n            if (cp.fromBlock == blockNumber) {\r\n                return cp.votes;\r\n            } else if (cp.fromBlock < blockNumber) {\r\n                lower = center;\r\n            } else {\r\n                upper = center - 1;\r\n            }\r\n        }\r\n        return checkpoints[account][lower].votes;\r\n    }\r\n\r\n    function _delegate(address delegator, address delegatee)\r\n    internal\r\n    {\r\n        address currentDelegate = _delegates[delegator];\r\n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying balances (not scaled);\r\n        _delegates[delegator] = delegatee;\r\n\r\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\r\n\r\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\r\n    }\r\n\r\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\r\n        if (srcRep != dstRep && amount > 0) {\r\n            if (srcRep != address(0)) {\r\n                // decrease old representative\r\n                uint32 srcRepNum = numCheckpoints[srcRep];\r\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\r\n                uint256 srcRepNew = srcRepOld.sub(amount);\r\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\r\n            }\r\n\r\n            if (dstRep != address(0)) {\r\n                // increase new representative\r\n                uint32 dstRepNum = numCheckpoints[dstRep];\r\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\r\n                uint256 dstRepNew = dstRepOld.add(amount);\r\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _writeCheckpoint(\r\n        address delegatee,\r\n        uint32 nCheckpoints,\r\n        uint256 oldVotes,\r\n        uint256 newVotes\r\n    )\r\n    internal\r\n    {\r\n        uint32 blockNumber = safe32(block.number, \"MdxToken::_writeCheckpoint: block number exceeds 32 bits\");\r\n\r\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\r\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\r\n        } else {\r\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\r\n            numCheckpoints[delegatee] = nCheckpoints + 1;\r\n        }\r\n\r\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\r\n    }\r\n\r\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\r\n        require(n < 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function getChainId() internal pure returns (uint) {\r\n        uint256 chainId;\r\n        assembly { chainId := chainid() }\r\n\r\n        return chainId;\r\n    }\r\n\r\n    /// @notice An event thats emitted when an account changes its delegate\r\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\r\n\r\n    /// @notice An event thats emitted when a delegate account's vote balance changes\r\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\r\n\r\n}\r\n\r\ncontract MdxToken is DelegateERC20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private constant preMineSupply = 200000000 * 1e18;\r\n    uint256 private constant maxSupply = 1000000000 * 1e18;     // the total supply\r\n\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    EnumerableSet.AddressSet private _minters;\r\n\r\n    constructor() ERC20(\"MDX Token\", \"MDX\"){\r\n        _mint(msg.sender, preMineSupply);\r\n    }\r\n\r\n    // mint with max supply\r\n    function mint(address _to, uint256 _amount) public onlyMinter returns (bool) {\r\n        if (_amount.add(totalSupply()) > maxSupply) {\r\n            return false;\r\n        }\r\n        _mint(_to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function addMinter(address _addMinter) public onlyOwner returns (bool) {\r\n        require(_addMinter != address(0), \"MdxToken: _addMinter is the zero address\");\r\n        return EnumerableSet.add(_minters, _addMinter);\r\n    }\r\n\r\n    function delMinter(address _delMinter) public onlyOwner returns (bool) {\r\n        require(_delMinter != address(0), \"MdxToken: _delMinter is the zero address\");\r\n        return EnumerableSet.remove(_minters, _delMinter);\r\n    }\r\n\r\n    function getMinterLength() public view returns (uint256) {\r\n        return EnumerableSet.length(_minters);\r\n    }\r\n\r\n    function isMinter(address account) public view returns (bool) {\r\n        return EnumerableSet.contains(_minters, account);\r\n    }\r\n\r\n    function getMinter(uint256 _index) public view onlyOwner returns (address){\r\n        require(_index <= getMinterLength() - 1, \"MdxToken: index out of bounds\");\r\n        return EnumerableSet.at(_minters, _index);\r\n    }\r\n\r\n    // modifier for mint function\r\n    modifier onlyMinter() {\r\n        require(isMinter(msg.sender), \"caller is not the minter\");\r\n        _;\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/swap/governance/GovernorAlpha.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity =0.7.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../heco/MdxTokenHeco.sol\";\r\n\r\ncontract GovernorAlpha {\r\n    /// @notice The name of this contract\r\n    string public constant name = \"MDX Governor Alpha\";\r\n\r\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\r\n    function quorumVotes() public view returns (uint) {return mdx.totalSupply() / 25;} // 400,000 = 4% of MDX\r\n\r\n    /// @notice The number of votes required in order for a voter to become a proposer\r\n    function proposalThreshold() public view returns (uint) {return mdx.totalSupply() / 100;} // 100,000 = 1% of MDX\r\n\r\n    /// @notice The maximum number of actions that can be included in a proposal\r\n    function proposalMaxOperations() public pure returns (uint) {return 10;} // 10 actions\r\n\r\n    /// @notice The delay before voting on a proposal may take place, once proposed\r\n    function votingDelay() public pure returns (uint) {return 1;} // 1 block\r\n\r\n    /// @notice The duration of voting on a proposal, in blocks\r\n    function votingPeriod() public pure returns (uint) {return 86400;} // ~3 days in blocks (assuming 3s blocks)\r\n\r\n    /// @notice The address of the MDX Protocol Timelock\r\n    TimelockInterface public timelock;\r\n\r\n    /// @notice The address of the MDX governance token\r\n    MdxToken public mdx;\r\n\r\n    /// @notice The address of the Governor Guardian\r\n    address public guardian;\r\n\r\n    /// @notice The total number of proposals\r\n    uint public proposalCount;\r\n\r\n    struct Proposal {\r\n        // @notice Unique id for looking up a proposal\r\n        uint id;\r\n\r\n        // @notice Creator of the proposal\r\n        address proposer;\r\n\r\n        // @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\r\n        uint eta;\r\n\r\n        // @notice the ordered list of target addresses for calls to be made\r\n        address[] targets;\r\n\r\n        // @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\r\n        uint[] values;\r\n\r\n        // @notice The ordered list of function signatures to be called\r\n        string[] signatures;\r\n\r\n        // @notice The ordered list of calldata to be passed to each call\r\n        bytes[] calldatas;\r\n\r\n        // @notice The block at which voting begins: holders must delegate their votes prior to this block\r\n        uint startBlock;\r\n\r\n        // @notice The block at which voting ends: votes must be cast prior to this block\r\n        uint endBlock;\r\n\r\n        // @notice Current number of votes in favor of this proposal\r\n        uint forVotes;\r\n\r\n        // @notice Current number of votes in opposition to this proposal\r\n        uint againstVotes;\r\n\r\n        // @notice Flag marking whether the proposal has been canceled\r\n        bool canceled;\r\n\r\n        // @notice Flag marking whether the proposal has been executed\r\n        bool executed;\r\n\r\n        // @notice Receipts of ballots for the entire set of voters\r\n        mapping(address => Receipt) receipts;\r\n    }\r\n\r\n    /// @notice Ballot receipt record for a voter\r\n    struct Receipt {\r\n        // @notice Whether or not a vote has been cast\r\n        bool hasVoted;\r\n\r\n        // @notice Whether or not the voter supports the proposal\r\n        bool support;\r\n\r\n        // @notice The number of votes the voter had, which were cast\r\n        uint256 votes;\r\n    }\r\n\r\n    /// @notice Possible states that a proposal may be in\r\n    enum ProposalState {\r\n        Pending,\r\n        Active,\r\n        Canceled,\r\n        Defeated,\r\n        Succeeded,\r\n        Queued,\r\n        Expired,\r\n        Executed\r\n    }\r\n\r\n    /// @notice The official record of all proposals ever proposed\r\n    mapping(uint => Proposal) public proposals;\r\n\r\n    /// @notice The latest proposal for each proposer\r\n    mapping(address => uint) public latestProposalIds;\r\n\r\n    /// @notice The EIP-712 typehash for the contract's domain\r\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n\r\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\r\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\r\n\r\n    /// @notice An event emitted when a new proposal is created\r\n    event ProposalCreated(uint id, address proposer, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint startBlock, uint endBlock, string description);\r\n\r\n    /// @notice An event emitted when a vote has been cast on a proposal\r\n    event VoteCast(address voter, uint proposalId, bool support, uint votes);\r\n\r\n    /// @notice An event emitted when a proposal has been canceled\r\n    event ProposalCanceled(uint id);\r\n\r\n    /// @notice An event emitted when a proposal has been queued in the Timelock\r\n    event ProposalQueued(uint id, uint eta);\r\n\r\n    /// @notice An event emitted when a proposal has been executed in the Timelock\r\n    event ProposalExecuted(uint id);\r\n\r\n    constructor(address timelock_, address mdx_, address guardian_) {\r\n        timelock = TimelockInterface(timelock_);\r\n        mdx = MdxToken(mdx_);\r\n        guardian = guardian_;\r\n    }\r\n\r\n    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\r\n        require(mdx.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\r\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\r\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\r\n        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\r\n\r\n        uint latestProposalId = latestProposalIds[msg.sender];\r\n        if (latestProposalId != 0) {\r\n            ProposalState proposersLatestProposalState = state(latestProposalId);\r\n            require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\r\n            require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\r\n        }\r\n\r\n        uint startBlock = add256(block.number, votingDelay());\r\n        uint endBlock = add256(startBlock, votingPeriod());\r\n\r\n        proposalCount++;\r\n        Proposal storage newProposal = proposals[proposalCount];\r\n        newProposal.id = proposalCount;\r\n        newProposal.proposer = msg.sender;\r\n        newProposal.eta = 0;\r\n        newProposal.targets = targets;\r\n        newProposal.values = values;\r\n        newProposal.signatures = signatures;\r\n        newProposal.calldatas = calldatas;\r\n        newProposal.startBlock = startBlock;\r\n        newProposal.endBlock = endBlock;\r\n        newProposal.forVotes = 0;\r\n        newProposal.againstVotes = 0;\r\n        newProposal.canceled = false;\r\n        newProposal.executed = false;\r\n        // Proposal memory newProposal = Proposal({\r\n        // id : proposalCount,\r\n        // proposer : msg.sender,\r\n        // eta : 0,\r\n        // targets : targets,\r\n        // values : values,\r\n        // signatures : signatures,\r\n        // calldatas : calldatas,\r\n        // startBlock : startBlock,\r\n        // endBlock : endBlock,\r\n        // forVotes : 0,\r\n        // againstVotes : 0,\r\n        // canceled : false,\r\n        // executed : false\r\n        // });\r\n\r\n        // proposals[newProposal.id] = newProposal;\r\n        latestProposalIds[newProposal.proposer] = newProposal.id;\r\n\r\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\r\n        return newProposal.id;\r\n    }\r\n\r\n    function queue(uint proposalId) public {\r\n        require(state(proposalId) == ProposalState.Succeeded, \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\");\r\n        Proposal storage proposal = proposals[proposalId];\r\n        uint eta = add256(block.timestamp, timelock.delay());\r\n        for (uint i = 0; i < proposal.targets.length; i++) {\r\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\r\n        }\r\n        proposal.eta = eta;\r\n        emit ProposalQueued(proposalId, eta);\r\n    }\r\n\r\n    function _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal {\r\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\");\r\n        timelock.queueTransaction(target, value, signature, data, eta);\r\n    }\r\n\r\n    function execute(uint proposalId) public payable {\r\n        require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\r\n        Proposal storage proposal = proposals[proposalId];\r\n        proposal.executed = true;\r\n        for (uint i = 0; i < proposal.targets.length; i++) {\r\n            timelock.executeTransaction{value : proposal.values[i]}(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\r\n        }\r\n        emit ProposalExecuted(proposalId);\r\n    }\r\n\r\n    function cancel(uint proposalId) public {\r\n        ProposalState pstate = state(proposalId);\r\n        require(pstate != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\r\n\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(msg.sender == guardian || mdx.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(), \"GovernorAlpha::cancel: proposer above threshold\");\r\n\r\n        proposal.canceled = true;\r\n        for (uint i = 0; i < proposal.targets.length; i++) {\r\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\r\n        }\r\n\r\n        emit ProposalCanceled(proposalId);\r\n    }\r\n\r\n    function getActions(uint proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) {\r\n        Proposal storage p = proposals[proposalId];\r\n        return (p.targets, p.values, p.signatures, p.calldatas);\r\n    }\r\n\r\n    function getReceipt(uint proposalId, address voter) public view returns (Receipt memory) {\r\n        return proposals[proposalId].receipts[voter];\r\n    }\r\n\r\n    function state(uint proposalId) public view returns (ProposalState) {\r\n        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\r\n        Proposal storage proposal = proposals[proposalId];\r\n        if (proposal.canceled) {\r\n            return ProposalState.Canceled;\r\n        } else if (block.number <= proposal.startBlock) {\r\n            return ProposalState.Pending;\r\n        } else if (block.number <= proposal.endBlock) {\r\n            return ProposalState.Active;\r\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {\r\n            return ProposalState.Defeated;\r\n        } else if (proposal.eta == 0) {\r\n            return ProposalState.Succeeded;\r\n        } else if (proposal.executed) {\r\n            return ProposalState.Executed;\r\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\r\n            return ProposalState.Expired;\r\n        } else {\r\n            return ProposalState.Queued;\r\n        }\r\n    }\r\n\r\n    function castVote(uint proposalId, bool support) public {\r\n        return _castVote(msg.sender, proposalId, support);\r\n    }\r\n\r\n    function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public {\r\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\r\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\r\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n        address signatory = ecrecover(digest, v, r, s);\r\n        require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\r\n        return _castVote(signatory, proposalId, support);\r\n    }\r\n\r\n    function _castVote(address voter, uint proposalId, bool support) internal {\r\n        require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\r\n        Proposal storage proposal = proposals[proposalId];\r\n        Receipt storage receipt = proposal.receipts[voter];\r\n        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\r\n        uint256 votes = mdx.getPriorVotes(voter, proposal.startBlock);\r\n\r\n        if (support) {\r\n            proposal.forVotes = add256(proposal.forVotes, votes);\r\n        } else {\r\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\r\n        }\r\n\r\n        receipt.hasVoted = true;\r\n        receipt.support = support;\r\n        receipt.votes = votes;\r\n\r\n        emit VoteCast(voter, proposalId, support, votes);\r\n    }\r\n\r\n    function __acceptAdmin() public {\r\n        require(msg.sender == guardian, \"GovernorAlpha::__acceptAdmin: sender must be gov guardian\");\r\n        timelock.acceptAdmin();\r\n    }\r\n\r\n    function __abdicate() public {\r\n        require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\r\n        guardian = address(0);\r\n    }\r\n\r\n    function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\r\n        require(msg.sender == guardian, \"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\");\r\n        timelock.queueTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\r\n    }\r\n\r\n    function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\r\n        require(msg.sender == guardian, \"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\");\r\n        timelock.executeTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\r\n    }\r\n\r\n    function add256(uint256 a, uint256 b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, \"addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub256(uint256 a, uint256 b) internal pure returns (uint) {\r\n        require(b <= a, \"subtraction underflow\");\r\n        return a - b;\r\n    }\r\n\r\n    function getChainId() internal pure returns (uint) {\r\n        uint chainId;\r\n        assembly {chainId := chainid()}\r\n        return chainId;\r\n    }\r\n}\r\n\r\ninterface TimelockInterface {\r\n    function delay() external view returns (uint);\r\n\r\n    function GRACE_PERIOD() external view returns (uint);\r\n\r\n    function acceptAdmin() external;\r\n\r\n    function queuedTransactions(bytes32 hash) external view returns (bool);\r\n\r\n    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\r\n\r\n    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\r\n\r\n    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\r\n}\r\n"
    },
    "contracts/common/Token.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract Token is ERC20 {\r\n  constructor(string memory name_, string memory symbol_, uint totalSupply_, address holder_) ERC20(name_, symbol_) {\r\n    // _setupDecimals(8);\r\n    _mint(holder_, totalSupply_);\r\n  }\r\n}\r\n"
    },
    "contracts/common/Timelock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity =0.7.6;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\n\r\ncontract Timelock {\r\n    using SafeMath for uint;\r\n\r\n    event NewAdmin(address indexed newAdmin);\r\n    event NewPendingAdmin(address indexed newPendingAdmin);\r\n    event NewDelay(uint indexed newDelay);\r\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\r\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\r\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\r\n\r\n    uint public constant GRACE_PERIOD = 14 days;\r\n    uint public constant MINIMUM_DELAY = 2 days;\r\n    uint public constant MAXIMUM_DELAY = 30 days;\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    uint public delay;\r\n\r\n    mapping(bytes32 => bool) public queuedTransactions;\r\n\r\n\r\n    constructor(address admin_, uint delay_) {\r\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\r\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\r\n\r\n        admin = admin_;\r\n        delay = delay_;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function setDelay(uint delay_) public {\r\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\r\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\r\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\r\n        delay = delay_;\r\n\r\n        emit NewDelay(delay);\r\n    }\r\n\r\n    function acceptAdmin() public {\r\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\r\n        admin = msg.sender;\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(admin);\r\n    }\r\n\r\n    function setPendingAdmin(address pendingAdmin_) public {\r\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\r\n        pendingAdmin = pendingAdmin_;\r\n\r\n        emit NewPendingAdmin(pendingAdmin);\r\n    }\r\n\r\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\r\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\r\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        queuedTransactions[txHash] = true;\r\n\r\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\r\n        return txHash;\r\n    }\r\n\r\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\r\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        queuedTransactions[txHash] = false;\r\n\r\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\r\n    }\r\n\r\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\r\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\r\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\r\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\r\n\r\n        queuedTransactions[txHash] = false;\r\n\r\n        bytes memory callData;\r\n\r\n        if (bytes(signature).length == 0) {\r\n            callData = data;\r\n        } else {\r\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\r\n        }\r\n\r\n        // solium-disable-next-line security/no-call-value\r\n        (bool success, bytes memory returnData) = target.call{value : value}(callData);\r\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\r\n\r\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\r\n\r\n        return returnData;\r\n    }\r\n\r\n    function getBlockTimestamp() internal view returns (uint) {\r\n        // solium-disable-next-line security/no-block-members\r\n        return block.timestamp;\r\n    }\r\n}\r\n"
    },
    "contracts/compound/Comptroller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\nimport \"./CToken.sol\";\r\nimport \"./ErrorReporter.sol\";\r\nimport \"./PriceOracle.sol\";\r\nimport \"../common/ComptrollerInterface.sol\";\r\nimport \"./ComptrollerStorage.sol\";\r\nimport \"./Unitroller.sol\";\r\nimport \"./Governance/LendHub.sol\";\r\n\r\n/**\r\n * @title Compound's Comptroller Contract\r\n * @author Compound\r\n */\r\ncontract Comptroller is ComptrollerV4Storage, ComptrollerInterface, ComptrollerErrorReporter, ExponentialNoError {\r\n    /// @notice Emitted when an admin supports a market\r\n    event MarketListed(CToken cToken);\r\n\r\n    /// @notice Emitted when an account enters a market\r\n    event MarketEntered(CToken cToken, address account);\r\n\r\n    /// @notice Emitted when an account exits a market\r\n    event MarketExited(CToken cToken, address account);\r\n\r\n    /// @notice Emitted when close factor is changed by admin\r\n    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\r\n\r\n    /// @notice Emitted when a collateral factor is changed by admin\r\n    event NewCollateralFactor(CToken cToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\r\n\r\n    /// @notice Emitted when liquidation incentive is changed by admin\r\n    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\r\n\r\n    /// @notice Emitted when price oracle is changed\r\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\r\n\r\n    /// @notice Emitted when pause guardian is changed\r\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\r\n\r\n    /// @notice Emitted when an action is paused globally\r\n    event ActionPausedAll(string action, bool pauseState);\r\n\r\n    /// @notice Emitted when an action is paused on a market\r\n    event ActionPaused(CToken cToken, string action, bool pauseState);\r\n\r\n    /// @notice Emitted when market comped status is changed\r\n    event MarketComped(CToken cToken, bool isComped);\r\n\r\n    /// @notice Emitted when LHB rate is changed\r\n    event NewCompRate(uint oldCompRate, uint newCompRate);\r\n\r\n    /// @notice Emitted when a new LHB speed is calculated for a market\r\n    event CompSpeedUpdated(CToken indexed cToken, uint newSpeed);\r\n\r\n    /// @notice Emitted when LHB is distributed to a supplier\r\n    event DistributedSupplierComp(CToken indexed cToken, address indexed supplier, uint compDelta, uint compSupplyIndex);\r\n\r\n    /// @notice Emitted when LHB is distributed to a borrower\r\n    event DistributedBorrowerComp(CToken indexed cToken, address indexed borrower, uint compDelta, uint compBorrowIndex);\r\n\r\n    /// @notice Emitted when borrow cap for a cToken is changed\r\n    event NewBorrowCap(CToken indexed cToken, uint newBorrowCap);\r\n\r\n    /// @notice Emitted when borrow cap guardian is changed\r\n    event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\r\n\r\n    /// @notice Emitted when LHB is granted by admin\r\n    event CompGranted(address recipient, uint amount);\r\n\r\n    /// @notice The threshold above which the flywheel transfers LHB, in wei\r\n    uint public constant compClaimThreshold = 0.001e18;\r\n\r\n    /// @notice The initial LHB index for a market\r\n    uint224 public constant compInitialIndex = 1e36;\r\n\r\n    // closeFactorMantissa must be strictly greater than this value\r\n    uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\r\n\r\n    // closeFactorMantissa must not exceed this value\r\n    uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\r\n\r\n    // No collateralFactorMantissa may exceed this value\r\n    uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\r\n\r\n    constructor() {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    /*** Assets You Are In ***/\r\n\r\n    /**\r\n     * @notice Returns the assets an account has entered\r\n     * @param account The address of the account to pull assets for\r\n     * @return A dynamic list with the assets the account has entered\r\n     */\r\n    function getAssetsIn(address account) external view returns (CToken[] memory) {\r\n        CToken[] memory assetsIn = accountAssets[account];\r\n\r\n        return assetsIn;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns whether the given account is entered in the given asset\r\n     * @param account The address of the account to check\r\n     * @param cToken The cToken to check\r\n     * @return True if the account is in the asset, otherwise false.\r\n     */\r\n    function checkMembership(address account, CToken cToken) external view returns (bool) {\r\n        return markets[address(cToken)].accountMembership[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Add assets to be included in account liquidity calculation\r\n     * @param cTokens The list of addresses of the cToken markets to be enabled\r\n     * @return Success indicator for whether each corresponding market was entered\r\n     */\r\n    function enterMarkets(address[] memory cTokens) override public returns (uint[] memory) {\r\n        uint len = cTokens.length;\r\n\r\n        uint[] memory results = new uint[](len);\r\n        for (uint i = 0; i < len; i++) {\r\n            CToken cToken = CToken(cTokens[i]);\r\n\r\n            results[i] = uint(addToMarketInternal(cToken, msg.sender));\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\r\n     * @param cToken The market to enter\r\n     * @param borrower The address of the account to modify\r\n     * @return Success indicator for whether the market was entered\r\n     */\r\n    function addToMarketInternal(CToken cToken, address borrower) internal returns (Error) {\r\n        Market storage marketToJoin = markets[address(cToken)];\r\n\r\n        if (!marketToJoin.isListed) {\r\n            // market is not listed, cannot join\r\n            return Error.MARKET_NOT_LISTED;\r\n        }\r\n\r\n        if (marketToJoin.accountMembership[borrower] == true) {\r\n            // already joined\r\n            return Error.NO_ERROR;\r\n        }\r\n\r\n        // survived the gauntlet, add to list\r\n        // NOTE: we store these somewhat redundantly as a significant optimization\r\n        //  this avoids having to iterate through the list for the most common use cases\r\n        //  that is, only when we need to perform liquidity checks\r\n        //  and not whenever we want to check if an account is in a particular market\r\n        marketToJoin.accountMembership[borrower] = true;\r\n        accountAssets[borrower].push(cToken);\r\n\r\n        emit MarketEntered(cToken, borrower);\r\n\r\n        return Error.NO_ERROR;\r\n    }\r\n\r\n    /**\r\n     * @notice Removes asset from sender's account liquidity calculation\r\n     * @dev Sender must not have an outstanding borrow balance in the asset,\r\n     *  or be providing necessary collateral for an outstanding borrow.\r\n     * @param cTokenAddress The address of the asset to be removed\r\n     * @return Whether or not the account successfully exited the market\r\n     */\r\n    function exitMarket(address cTokenAddress) override external returns (uint) {\r\n        CToken cToken = CToken(cTokenAddress);\r\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\r\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\r\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\r\n\r\n        /* Fail if the sender has a borrow balance */\r\n        if (amountOwed != 0) {\r\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\r\n        }\r\n\r\n        /* Fail if the sender is not permitted to redeem all of their tokens */\r\n        uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\r\n        }\r\n\r\n        Market storage marketToExit = markets[address(cToken)];\r\n\r\n        /* Return true if the sender is not already ‘in’ the market */\r\n        if (!marketToExit.accountMembership[msg.sender]) {\r\n            return uint(Error.NO_ERROR);\r\n        }\r\n\r\n        /* Set cToken account membership to false */\r\n        delete marketToExit.accountMembership[msg.sender];\r\n\r\n        /* Delete cToken from the account’s list of assets */\r\n        // load into memory for faster iteration\r\n        CToken[] memory userAssetList = accountAssets[msg.sender];\r\n        uint len = userAssetList.length;\r\n        uint assetIndex = len;\r\n        for (uint i = 0; i < len; i++) {\r\n            if (userAssetList[i] == cToken) {\r\n                assetIndex = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // We *must* have found the asset in the list or our redundant data structure is broken\r\n        assert(assetIndex < len);\r\n\r\n        // copy last item in list to location of item to be removed, reduce length by 1\r\n        CToken[] storage storedList = accountAssets[msg.sender];\r\n        storedList[assetIndex] = storedList[storedList.length - 1];\r\n        // storedList.length--;\r\n        storedList.pop();\r\n\r\n        emit MarketExited(cToken, msg.sender);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /*** Policy Hooks ***/\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to mint tokens in the given market\r\n     * @param cToken The market to verify the mint against\r\n     * @param minter The account which would get the minted tokens\r\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\r\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function mintAllowed(address cToken, address minter, uint mintAmount) override external returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!mintGuardianPaused[cToken], \"mint is paused\");\r\n\r\n        // Shh - currently unused\r\n        minter;\r\n        mintAmount;\r\n\r\n        if (!markets[cToken].isListed) {\r\n            console.log('ctoken %s is NOT listed', cToken);\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateCompSupplyIndex(cToken);\r\n        distributeSupplierComp(cToken, minter, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates mint and reverts on rejection. May emit logs.\r\n     * @param cToken Asset being minted\r\n     * @param minter The address minting the tokens\r\n     * @param actualMintAmount The amount of the underlying asset being minted\r\n     * @param mintTokens The number of tokens being minted\r\n     */\r\n    function mintVerify(address cToken, address minter, uint actualMintAmount, uint mintTokens) override external {\r\n        // Shh - currently unused\r\n        cToken;\r\n        minter;\r\n        actualMintAmount;\r\n        mintTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\r\n     * @param cToken The market to verify the redeem against\r\n     * @param redeemer The account which would redeem the tokens\r\n     * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\r\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) override external returns (uint) {\r\n        uint allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);\r\n        if (allowed != uint(Error.NO_ERROR)) {\r\n            return allowed;\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateCompSupplyIndex(cToken);\r\n        distributeSupplierComp(cToken, redeemer, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function redeemAllowedInternal(address cToken, address redeemer, uint redeemTokens) internal view returns (uint) {\r\n        if (!markets[cToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\r\n        if (!markets[cToken].accountMembership[redeemer]) {\r\n            return uint(Error.NO_ERROR);\r\n        }\r\n\r\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\r\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, CToken(cToken), redeemTokens, 0);\r\n        if (err != Error.NO_ERROR) {\r\n            return uint(err);\r\n        }\r\n        if (shortfall > 0) {\r\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\r\n        }\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates redeem and reverts on rejection. May emit logs.\r\n     * @param cToken Asset being redeemed\r\n     * @param redeemer The address redeeming the tokens\r\n     * @param redeemAmount The amount of the underlying asset being redeemed\r\n     * @param redeemTokens The number of tokens being redeemed\r\n     */\r\n    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) override external pure {\r\n        // Shh - currently unused\r\n        cToken;\r\n        redeemer;\r\n\r\n        // Require tokens is zero or amount is also zero\r\n        if (redeemTokens == 0 && redeemAmount > 0) {\r\n            revert(\"redeemTokens zero\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\r\n     * @param cToken The market to verify the borrow against\r\n     * @param borrower The account which would borrow the asset\r\n     * @param borrowAmount The amount of underlying the account would borrow\r\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) override external returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!borrowGuardianPaused[cToken], \"borrow is paused\");\r\n\r\n        if (!markets[cToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        if (!markets[cToken].accountMembership[borrower]) {\r\n            // only cTokens may call borrowAllowed if borrower not in market\r\n            require(msg.sender == cToken, \"sender must be cToken\");\r\n\r\n            // attempt to add borrower to the market\r\n            Error ierr = addToMarketInternal(CToken(msg.sender), borrower);\r\n            if (ierr != Error.NO_ERROR) {\r\n                return uint(ierr);\r\n            }\r\n\r\n            // it should be impossible to break the important invariant\r\n            assert(markets[cToken].accountMembership[borrower]);\r\n        }\r\n\r\n        if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {\r\n            return uint(Error.PRICE_ERROR);\r\n        }\r\n\r\n\r\n        uint borrowCap = borrowCaps[cToken];\r\n        // Borrow cap of 0 corresponds to unlimited borrowing\r\n        if (borrowCap != 0) {\r\n            uint totalBorrows = CToken(cToken).totalBorrows();\r\n            uint nextTotalBorrows = add_(totalBorrows, borrowAmount);\r\n            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\r\n        }\r\n\r\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, CToken(cToken), 0, borrowAmount);\r\n        if (err != Error.NO_ERROR) {\r\n            return uint(err);\r\n        }\r\n        if (shortfall > 0) {\r\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        Exp memory borrowIndex = Exp({mantissa: CToken(cToken).borrowIndex()});\r\n        updateCompBorrowIndex(cToken, borrowIndex);\r\n        distributeBorrowerComp(cToken, borrower, borrowIndex, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates borrow and reverts on rejection. May emit logs.\r\n     * @param cToken Asset whose underlying is being borrowed\r\n     * @param borrower The address borrowing the underlying\r\n     * @param borrowAmount The amount of the underlying asset requested to borrow\r\n     */\r\n    function borrowVerify(address cToken, address borrower, uint borrowAmount) override external {\r\n        // Shh - currently unused\r\n        cToken;\r\n        borrower;\r\n        borrowAmount;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\r\n     * @param cToken The market to verify the repay against\r\n     * @param payer The account which would repay the asset\r\n     * @param borrower The account which would borrowed the asset\r\n     * @param repayAmount The amount of the underlying asset the account would repay\r\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function repayBorrowAllowed(\r\n        address cToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount) override external returns (uint) {\r\n        // Shh - currently unused\r\n        payer;\r\n        borrower;\r\n        repayAmount;\r\n\r\n        if (!markets[cToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        Exp memory borrowIndex = Exp({mantissa: CToken(cToken).borrowIndex()});\r\n        updateCompBorrowIndex(cToken, borrowIndex);\r\n        distributeBorrowerComp(cToken, borrower, borrowIndex, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates repayBorrow and reverts on rejection. May emit logs.\r\n     * @param cToken Asset being repaid\r\n     * @param payer The address repaying the borrow\r\n     * @param borrower The address of the borrower\r\n     * @param actualRepayAmount The amount of underlying being repaid\r\n     */\r\n    function repayBorrowVerify(\r\n        address cToken,\r\n        address payer,\r\n        address borrower,\r\n        uint actualRepayAmount,\r\n        uint borrowerIndex) override external {\r\n        // Shh - currently unused\r\n        cToken;\r\n        payer;\r\n        borrower;\r\n        actualRepayAmount;\r\n        borrowerIndex;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the liquidation should be allowed to occur\r\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param repayAmount The amount of underlying being repaid\r\n     */\r\n    function liquidateBorrowAllowed(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount) override external view returns (uint) {\r\n        // Shh - currently unused\r\n        liquidator;\r\n\r\n        if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        /* The borrower must have shortfall in order to be liquidatable */\r\n        (Error err, , uint shortfall) = getAccountLiquidityInternal(borrower);\r\n        if (err != Error.NO_ERROR) {\r\n            return uint(err);\r\n        }\r\n        if (shortfall == 0) {\r\n            return uint(Error.INSUFFICIENT_SHORTFALL);\r\n        }\r\n\r\n        /* The liquidator may not repay more than what is allowed by the closeFactor */\r\n        uint borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);\r\n        uint maxClose = mul_ScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);\r\n        if (repayAmount > maxClose) {\r\n            return uint(Error.TOO_MUCH_REPAY);\r\n        }\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\r\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param actualRepayAmount The amount of underlying being repaid\r\n     */\r\n    function liquidateBorrowVerify(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint actualRepayAmount,\r\n        uint seizeTokens) override external {\r\n        // Shh - currently unused\r\n        cTokenBorrowed;\r\n        cTokenCollateral;\r\n        liquidator;\r\n        borrower;\r\n        actualRepayAmount;\r\n        seizeTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the seizing of assets should be allowed to occur\r\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param seizeTokens The number of collateral tokens to seize\r\n     */\r\n    function seizeAllowed(\r\n        address cTokenCollateral,\r\n        address cTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) override external returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!seizeGuardianPaused, \"seize is paused\");\r\n\r\n        // Shh - currently unused\r\n        seizeTokens;\r\n\r\n        if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        if (CToken(cTokenCollateral).comptroller() != CToken(cTokenBorrowed).comptroller()) {\r\n            return uint(Error.COMPTROLLER_MISMATCH);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateCompSupplyIndex(cTokenCollateral);\r\n        distributeSupplierComp(cTokenCollateral, borrower, false);\r\n        distributeSupplierComp(cTokenCollateral, liquidator, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates seize and reverts on rejection. May emit logs.\r\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param seizeTokens The number of collateral tokens to seize\r\n     */\r\n    function seizeVerify(\r\n        address cTokenCollateral,\r\n        address cTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) override external {\r\n        // Shh - currently unused\r\n        cTokenCollateral;\r\n        cTokenBorrowed;\r\n        liquidator;\r\n        borrower;\r\n        seizeTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\r\n     * @param cToken The market to verify the transfer against\r\n     * @param src The account which sources the tokens\r\n     * @param dst The account which receives the tokens\r\n     * @param transferTokens The number of cTokens to transfer\r\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function transferAllowed(address cToken, address src, address dst, uint transferTokens) override external returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!transferGuardianPaused, \"transfer is paused\");\r\n\r\n        // Currently the only consideration is whether or not\r\n        //  the src is allowed to redeem this many tokens\r\n        uint allowed = redeemAllowedInternal(cToken, src, transferTokens);\r\n        if (allowed != uint(Error.NO_ERROR)) {\r\n            return allowed;\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateCompSupplyIndex(cToken);\r\n        distributeSupplierComp(cToken, src, false);\r\n        distributeSupplierComp(cToken, dst, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates transfer and reverts on rejection. May emit logs.\r\n     * @param cToken Asset being transferred\r\n     * @param src The account which sources the tokens\r\n     * @param dst The account which receives the tokens\r\n     * @param transferTokens The number of cTokens to transfer\r\n     */\r\n    function transferVerify(address cToken, address src, address dst, uint transferTokens) override external {\r\n        // Shh - currently unused\r\n        cToken;\r\n        src;\r\n        dst;\r\n        transferTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /*** Liquidity/Liquidation Calculations ***/\r\n\r\n    /**\r\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\r\n     *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\r\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\r\n     */\r\n    struct AccountLiquidityLocalVars {\r\n        uint sumCollateral;\r\n        uint sumBorrowPlusEffects;\r\n        uint cTokenBalance;\r\n        uint borrowBalance;\r\n        uint exchangeRateMantissa;\r\n        uint oraclePriceMantissa;\r\n        Exp collateralFactor;\r\n        Exp exchangeRate;\r\n        Exp oraclePrice;\r\n        Exp tokensToDenom;\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the current account liquidity wrt collateral requirements\r\n     * @return (possible error code (semi-opaque),\r\n                account liquidity in excess of collateral requirements,\r\n     *          account shortfall below collateral requirements)\r\n     */\r\n    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\r\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\r\n\r\n        return (uint(err), liquidity, shortfall);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the current account liquidity wrt collateral requirements\r\n     * @return (possible error code,\r\n                account liquidity in excess of collateral requirements,\r\n     *          account shortfall below collateral requirements)\r\n     */\r\n    function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\r\n        return getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\r\n     * @param cTokenModify The market to hypothetically redeem/borrow in\r\n     * @param account The account to determine liquidity for\r\n     * @param redeemTokens The number of tokens to hypothetically redeem\r\n     * @param borrowAmount The amount of underlying to hypothetically borrow\r\n     * @return (possible error code (semi-opaque),\r\n                hypothetical account liquidity in excess of collateral requirements,\r\n     *          hypothetical account shortfall below collateral requirements)\r\n     */\r\n    function getHypotheticalAccountLiquidity(\r\n        address account,\r\n        address cTokenModify,\r\n        uint redeemTokens,\r\n        uint borrowAmount) public view returns (uint, uint, uint) {\r\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account,\r\n            CToken(cTokenModify), redeemTokens, borrowAmount);\r\n        return (uint(err), liquidity, shortfall);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\r\n     * @param cTokenModify The market to hypothetically redeem/borrow in\r\n     * @param account The account to determine liquidity for\r\n     * @param redeemTokens The number of tokens to hypothetically redeem\r\n     * @param borrowAmount The amount of underlying to hypothetically borrow\r\n     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\r\n     *  without calculating accumulated interest.\r\n     * @return (possible error code,\r\n                hypothetical account liquidity in excess of collateral requirements,\r\n     *          hypothetical account shortfall below collateral requirements)\r\n     */\r\n    function getHypotheticalAccountLiquidityInternal(\r\n        address account,\r\n        CToken cTokenModify,\r\n        uint redeemTokens,\r\n        uint borrowAmount) internal view returns (Error, uint, uint) {\r\n\r\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\r\n        uint oErr;\r\n\r\n        // For each asset the account is in\r\n        CToken[] memory assets = accountAssets[account];\r\n        for (uint i = 0; i < assets.length; i++) {\r\n            CToken asset = assets[i];\r\n\r\n            // Read the balances and exchange rate from the cToken\r\n            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\r\n            if (oErr != 0) { // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\r\n                return (Error.SNAPSHOT_ERROR, 0, 0);\r\n            }\r\n            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\r\n            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\r\n\r\n            // Get the normalized price of the asset\r\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\r\n            if (vars.oraclePriceMantissa == 0) {\r\n                return (Error.PRICE_ERROR, 0, 0);\r\n            }\r\n            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\r\n\r\n            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\r\n            vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\r\n\r\n            // sumCollateral += tokensToDenom * cTokenBalance\r\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.cTokenBalance, vars.sumCollateral);\r\n\r\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\r\n            vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\r\n\r\n            // Calculate effects of interacting with cTokenModify\r\n            if (asset == cTokenModify) {\r\n                // redeem effect\r\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\r\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);\r\n\r\n                // borrow effect\r\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\r\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);\r\n            }\r\n        }\r\n\r\n        // These are safe, as the underflow condition is checked first\r\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\r\n            return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\r\n        } else {\r\n            return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\r\n     * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\r\n     * @param cTokenBorrowed The address of the borrowed cToken\r\n     * @param cTokenCollateral The address of the collateral cToken\r\n     * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\r\n     * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\r\n     */\r\n    function liquidateCalculateSeizeTokens(address cTokenBorrowed,\r\n                                            address cTokenCollateral,\r\n                                            uint actualRepayAmount) override external view returns (uint, uint) {\r\n        /* Read oracle prices for borrowed and collateral markets */\r\n        uint priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));\r\n        uint priceCollateralMantissa = oracle.getUnderlyingPrice(CToken(cTokenCollateral));\r\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\r\n            return (uint(Error.PRICE_ERROR), 0);\r\n        }\r\n\r\n        /*\r\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\r\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\r\n         *  seizeTokens = seizeAmount / exchangeRate\r\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\r\n         */\r\n        uint exchangeRateMantissa = CToken(cTokenCollateral).exchangeRateStored(); // Note: reverts on error\r\n        uint seizeTokens;\r\n        Exp memory numerator;\r\n        Exp memory denominator;\r\n        Exp memory ratio;\r\n\r\n        numerator = mul_(Exp({mantissa: liquidationIncentiveMantissa}), Exp({mantissa: priceBorrowedMantissa}));\r\n        denominator = mul_(Exp({mantissa: priceCollateralMantissa}), Exp({mantissa: exchangeRateMantissa}));\r\n        ratio = div_(numerator, denominator);\r\n\r\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\r\n\r\n        return (uint(Error.NO_ERROR), seizeTokens);\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    /**\r\n      * @notice Sets a new price oracle for the comptroller\r\n      * @dev Admin function to set a new price oracle\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\r\n        }\r\n\r\n        // Track the old oracle for the comptroller\r\n        PriceOracle oldOracle = oracle;\r\n\r\n        // Set comptroller's oracle to newOracle\r\n        oracle = newOracle;\r\n\r\n        // Emit NewPriceOracle(oldOracle, newOracle)\r\n        emit NewPriceOracle(oldOracle, newOracle);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets the closeFactor used when liquidating borrows\r\n      * @dev Admin function to set closeFactor\r\n      * @param newCloseFactorMantissa New close factor, scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure\r\n      */\r\n    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\r\n        // Check caller is admin\r\n        require(msg.sender == admin, \"only admin can set close factor\");\r\n\r\n        uint oldCloseFactorMantissa = closeFactorMantissa;\r\n        closeFactorMantissa = newCloseFactorMantissa;\r\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets the collateralFactor for a market\r\n      * @dev Admin function to set per-market collateralFactor\r\n      * @param cToken The market to set the factor on\r\n      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setCollateralFactor(CToken cToken, uint newCollateralFactorMantissa) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\r\n        }\r\n\r\n        // Verify market is listed\r\n        Market storage market = markets[address(cToken)];\r\n        if (!market.isListed) {\r\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\r\n        }\r\n\r\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\r\n\r\n        // Check collateral factor <= 0.9\r\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\r\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\r\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\r\n        }\r\n\r\n        // If collateral factor != 0, fail if price == 0\r\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\r\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\r\n        }\r\n\r\n        // Set market's collateral factor to new collateral factor, remember old value\r\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\r\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\r\n\r\n        // Emit event with asset, old collateral factor, and new collateral factor\r\n        emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets liquidationIncentive\r\n      * @dev Admin function to set liquidationIncentive\r\n      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\r\n        }\r\n\r\n        // Save current value for use in log\r\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\r\n\r\n        // Set liquidation incentive to new incentive\r\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\r\n\r\n        // Emit event with old incentive, new incentive\r\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Add the market to the markets mapping and set it as listed\r\n      * @dev Admin function to set isListed and add support for the market\r\n      * @param cToken The address of the market (token) to list\r\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\r\n      */\r\n    function _supportMarket(address cToken) external override returns (uint) {\r\n        // if (msg.sender != admin) {\r\n        //     console.log('msg.sender %s is not admin %s', msg.sender, admin);\r\n        //     return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\r\n        // }\r\n\r\n        console.log('list ctoken %s to market ....', cToken);\r\n        if (markets[address(cToken)].isListed) {\r\n            console.log('token isListed');\r\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\r\n        }\r\n\r\n        CToken(cToken).isCToken(); // Sanity check to make sure its really a CToken\r\n\r\n        console.log('ctoken is CToken verified');\r\n\r\n        // markets[address(cToken)] = Market({isListed: true, isComped: false, collateralFactorMantissa: 0});\r\n        Market storage m = markets[address(cToken)];\r\n        m.isListed = true;\r\n        m.isComped = false;\r\n        m.collateralFactorMantissa = 0;\r\n\r\n        // console.log('before _addMarketInternal');\r\n        _addMarketInternal(address(cToken));\r\n        console.log('ctoken listed 1:', address(cToken));\r\n\r\n        emit MarketListed(CToken(cToken));\r\n\r\n        console.log('ctoken listed success');\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _addMarketInternal(address cToken) internal {\r\n        for (uint i = 0; i < allMarkets.length; i ++) {\r\n            // if (allMarkets[i] == CToken(cToken)) {\r\n            //     console.log('ctoken %s exist in market at %d', cToken, i);\r\n            // }\r\n            require(allMarkets[i] != CToken(cToken), \"market already added\");\r\n        }\r\n        allMarkets.push(CToken(cToken));\r\n    }\r\n\r\n\r\n    /**\r\n      * @notice Set the given borrow caps for the given cToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\r\n      * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\r\n      * @param cTokens The addresses of the markets (tokens) to change the borrow caps for\r\n      * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\r\n      */\r\n    function _setMarketBorrowCaps(CToken[] calldata cTokens, uint[] calldata newBorrowCaps) external {\r\n        require(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set borrow caps\");\r\n\r\n        uint numMarkets = cTokens.length;\r\n        uint numBorrowCaps = newBorrowCaps.length;\r\n\r\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\r\n\r\n        for(uint i = 0; i < numMarkets; i++) {\r\n            borrowCaps[address(cTokens[i])] = newBorrowCaps[i];\r\n            emit NewBorrowCap(cTokens[i], newBorrowCaps[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Admin function to change the Borrow Cap Guardian\r\n     * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian\r\n     */\r\n    function _setBorrowCapGuardian(address newBorrowCapGuardian) external {\r\n        require(msg.sender == admin, \"only admin can set borrow cap guardian\");\r\n\r\n        // Save current value for inclusion in log\r\n        address oldBorrowCapGuardian = borrowCapGuardian;\r\n\r\n        // Store borrowCapGuardian with value newBorrowCapGuardian\r\n        borrowCapGuardian = newBorrowCapGuardian;\r\n\r\n        // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\r\n        emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\r\n    }\r\n\r\n    /**\r\n     * @notice Admin function to change the Pause Guardian\r\n     * @param newPauseGuardian The address of the new Pause Guardian\r\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\r\n     */\r\n    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\r\n        }\r\n\r\n        // Save current value for inclusion in log\r\n        address oldPauseGuardian = pauseGuardian;\r\n\r\n        // Store pauseGuardian with value newPauseGuardian\r\n        pauseGuardian = newPauseGuardian;\r\n\r\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\r\n        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _setMintPaused(CToken cToken, bool state) public returns (bool) {\r\n        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\r\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\r\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\r\n\r\n        mintGuardianPaused[address(cToken)] = state;\r\n        emit ActionPaused(cToken, \"Mint\", state);\r\n        return state;\r\n    }\r\n\r\n    function _setBorrowPaused(CToken cToken, bool state) public returns (bool) {\r\n        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\r\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\r\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\r\n\r\n        borrowGuardianPaused[address(cToken)] = state;\r\n        emit ActionPaused(cToken, \"Borrow\", state);\r\n        return state;\r\n    }\r\n\r\n    function _setTransferPaused(bool state) public returns (bool) {\r\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\r\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\r\n\r\n        transferGuardianPaused = state;\r\n        emit ActionPausedAll(\"Transfer\", state);\r\n        return state;\r\n    }\r\n\r\n    function _setSeizePaused(bool state) public returns (bool) {\r\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\r\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\r\n\r\n        seizeGuardianPaused = state;\r\n        emit ActionPausedAll(\"Seize\", state);\r\n        return state;\r\n    }\r\n\r\n    function _become(Unitroller unitroller) public {\r\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\r\n        require(unitroller._acceptImplementation() == 0, \"change not authorized\");\r\n    }\r\n\r\n    /**\r\n     * @notice Checks caller is admin, or this contract is becoming the new implementation\r\n     */\r\n    function adminOrInitializing() internal view returns (bool) {\r\n        return msg.sender == admin || msg.sender == comptrollerImplementation;\r\n    }\r\n\r\n    /*** LHB Distribution ***/\r\n\r\n    /**\r\n     * @notice Recalculate and update LHB speeds for all LHB markets\r\n     */\r\n    function refreshCompSpeeds() public {\r\n        require(msg.sender == tx.origin, \"only externally owned accounts may refresh speeds\");\r\n        refreshCompSpeedsInternal();\r\n    }\r\n\r\n    function refreshCompSpeedsInternal() internal {\r\n        CToken[] memory allMarkets_ = allMarkets;\r\n\r\n        for (uint i = 0; i < allMarkets_.length; i++) {\r\n            CToken cToken = allMarkets_[i];\r\n            Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});\r\n            updateCompSupplyIndex(address(cToken));\r\n            updateCompBorrowIndex(address(cToken), borrowIndex);\r\n        }\r\n\r\n        Exp memory totalUtility = Exp({mantissa: 0});\r\n        Exp[] memory utilities = new Exp[](allMarkets_.length);\r\n        for (uint i = 0; i < allMarkets_.length; i++) {\r\n            CToken cToken = allMarkets_[i];\r\n            if (markets[address(cToken)].isComped) {\r\n                Exp memory assetPrice = Exp({mantissa: oracle.getUnderlyingPrice(cToken)});\r\n                Exp memory utility = mul_(assetPrice, cToken.totalBorrows());\r\n                utilities[i] = utility;\r\n                totalUtility = add_(totalUtility, utility);\r\n            }\r\n        }\r\n\r\n        for (uint i = 0; i < allMarkets_.length; i++) {\r\n            CToken cToken = allMarkets[i];\r\n            uint newSpeed = totalUtility.mantissa > 0 ? mul_(compRate, div_(utilities[i], totalUtility)) : 0;\r\n            compSpeeds[address(cToken)] = newSpeed;\r\n            emit CompSpeedUpdated(cToken, newSpeed);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue LHB to the market by updating the supply index\r\n     * @param cToken The market whose supply index to update\r\n     */\r\n    function updateCompSupplyIndex(address cToken) internal {\r\n        CompMarketState storage supplyState = compSupplyState[cToken];\r\n        uint supplySpeed = compSpeeds[cToken];\r\n        uint blockNumber = getBlockNumber();\r\n        uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));\r\n        if (deltaBlocks > 0 && supplySpeed > 0) {\r\n            uint supplyTokens = CToken(cToken).totalSupply();\r\n            uint compAccrued = mul_(deltaBlocks, supplySpeed);\r\n            Double memory ratio = supplyTokens > 0 ? fraction(compAccrued, supplyTokens) : Double({mantissa: 0});\r\n            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\r\n            compSupplyState[cToken] = CompMarketState({\r\n                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\r\n                block: safe32(blockNumber, \"block number exceeds 32 bits\")\r\n                });\r\n        } else if (deltaBlocks > 0) {\r\n            supplyState.block = safe32(blockNumber, \"block number exceeds 32 bits\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue LHB to the market by updating the borrow index\r\n     * @param cToken The market whose borrow index to update\r\n     */\r\n    function updateCompBorrowIndex(address cToken, Exp memory marketBorrowIndex) internal {\r\n        CompMarketState storage borrowState = compBorrowState[cToken];\r\n        uint borrowSpeed = compSpeeds[cToken];\r\n        uint blockNumber = getBlockNumber();\r\n        uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));\r\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\r\n            uint borrowAmount = div_(CToken(cToken).totalBorrows(), marketBorrowIndex);\r\n            uint compAccrued = mul_(deltaBlocks, borrowSpeed);\r\n            Double memory ratio = borrowAmount > 0 ? fraction(compAccrued, borrowAmount) : Double({mantissa: 0});\r\n            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\r\n            compBorrowState[cToken] = CompMarketState({\r\n                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\r\n                block: safe32(blockNumber, \"block number exceeds 32 bits\")\r\n                });\r\n        } else if (deltaBlocks > 0) {\r\n            borrowState.block = safe32(blockNumber, \"block number exceeds 32 bits\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate LHB accrued by a supplier and possibly transfer it to them\r\n     * @param cToken The market in which the supplier is interacting\r\n     * @param supplier The address of the supplier to distribute LHB to\r\n     */\r\n    function distributeSupplierComp(address cToken, address supplier, bool distributeAll) internal {\r\n        CompMarketState storage supplyState = compSupplyState[cToken];\r\n        Double memory supplyIndex = Double({mantissa: supplyState.index});\r\n        Double memory supplierIndex = Double({mantissa: compSupplierIndex[cToken][supplier]});\r\n        compSupplierIndex[cToken][supplier] = supplyIndex.mantissa;\r\n\r\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\r\n            supplierIndex.mantissa = compInitialIndex;\r\n        }\r\n\r\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\r\n        uint supplierTokens = CToken(cToken).balanceOf(supplier);\r\n        uint supplierDelta = mul_(supplierTokens, deltaIndex);\r\n        uint supplierAccrued = add_(compAccrued[supplier], supplierDelta);\r\n        compAccrued[supplier] = transferComp(supplier, supplierAccrued, distributeAll ? 0 : compClaimThreshold);\r\n        emit DistributedSupplierComp(CToken(cToken), supplier, supplierDelta, supplyIndex.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate LHB accrued by a borrower and possibly transfer it to them\r\n     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.\r\n     * @param cToken The market in which the borrower is interacting\r\n     * @param borrower The address of the borrower to distribute LHB to\r\n     */\r\n    function distributeBorrowerComp(address cToken, address borrower, Exp memory marketBorrowIndex, bool distributeAll) internal {\r\n        CompMarketState storage borrowState = compBorrowState[cToken];\r\n        Double memory borrowIndex = Double({mantissa: borrowState.index});\r\n        Double memory borrowerIndex = Double({mantissa: compBorrowerIndex[cToken][borrower]});\r\n        compBorrowerIndex[cToken][borrower] = borrowIndex.mantissa;\r\n\r\n        if (borrowerIndex.mantissa > 0) {\r\n            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\r\n            uint borrowerAmount = div_(CToken(cToken).borrowBalanceStored(borrower), marketBorrowIndex);\r\n            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\r\n            uint borrowerAccrued = add_(compAccrued[borrower], borrowerDelta);\r\n            compAccrued[borrower] = transferComp(borrower, borrowerAccrued, distributeAll ? 0 : compClaimThreshold);\r\n            emit DistributedBorrowerComp(CToken(cToken), borrower, borrowerDelta, borrowIndex.mantissa);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer LHB to the user, if they are above the threshold\r\n     * @dev Note: If there is not enough LHB, we do not perform the transfer all.\r\n     * @param user The address of the user to transfer LHB to\r\n     * @param userAccrued The amount of LHB to (possibly) transfer\r\n     * @return The amount of LHB which was NOT transferred to the user\r\n     */\r\n    function transferComp(address user, uint userAccrued, uint threshold) internal returns (uint) {\r\n        if (userAccrued >= threshold && userAccrued > 0) {\r\n            LendHub lhb = LendHub(getCompAddress());\r\n            uint compRemaining = lhb.balanceOf(address(this));\r\n            if (userAccrued <= compRemaining) {\r\n                lhb.transfer(user, userAccrued);\r\n                return 0;\r\n            }\r\n        }\r\n        return userAccrued;\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all the LHB accrued by holder in all markets\r\n     * @param holder The address to claim LHB for\r\n     */\r\n    function claimComp(address holder) public {\r\n        return claimComp(holder, allMarkets);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all the LHB accrued by holder in the specified markets\r\n     * @param holder The address to claim LHB for\r\n     * @param cTokens The list of markets to claim LHB in\r\n     */\r\n    function claimComp(address holder, CToken[] memory cTokens) public {\r\n        address[] memory holders = new address[](1);\r\n        holders[0] = holder;\r\n        claimComp(holders, cTokens, true, true);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all LHB accrued by the holders\r\n     * @param holders The addresses to claim LHB for\r\n     * @param cTokens The list of markets to claim LHB in\r\n     * @param borrowers Whether or not to claim LHB earned by borrowing\r\n     * @param suppliers Whether or not to claim LHB earned by supplying\r\n     */\r\n    function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {\r\n        for (uint i = 0; i < cTokens.length; i++) {\r\n            CToken cToken = cTokens[i];\r\n            require(markets[address(cToken)].isListed, \"market must be listed\");\r\n            if (borrowers == true) {\r\n                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});\r\n                updateCompBorrowIndex(address(cToken), borrowIndex);\r\n                for (uint j = 0; j < holders.length; j++) {\r\n                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);\r\n                }\r\n            }\r\n            if (suppliers == true) {\r\n                updateCompSupplyIndex(address(cToken));\r\n                for (uint j = 0; j < holders.length; j++) {\r\n                    distributeSupplierComp(address(cToken), holders[j], true);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer LHB to the user\r\n     * @dev Note: If there is not enough LHB, we do not perform the transfer all.\r\n     * @param user The address of the user to transfer LHB to\r\n     * @param amount The amount of LHB to (possibly) transfer\r\n     * @return The amount of LHB which was NOT transferred to the user\r\n     */\r\n    function grantCompInternal(address user, uint amount) internal returns (uint) {\r\n        LendHub lhb = LendHub(getCompAddress());\r\n        uint compRemaining = lhb.balanceOf(address(this));\r\n        if (amount <= compRemaining) {\r\n            lhb.transfer(user, amount);\r\n            return 0;\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    /*** LHB Distribution Admin ***/\r\n\r\n    /**\r\n     * @notice Transfer LHB to the recipient\r\n     * @dev Note: If there is not enough LHB, we do not perform the transfer all.\r\n     * @param recipient The address of the recipient to transfer LHB to\r\n     * @param amount The amount of LHB to (possibly) transfer\r\n     */\r\n    function _grantComp(address recipient, uint amount) public {\r\n        require(adminOrInitializing(), \"only admin can grant LHB\");\r\n        uint amountLeft = grantCompInternal(recipient, amount);\r\n        require(amountLeft == 0, \"insufficient LHB for grant\");\r\n        emit CompGranted(recipient, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the amount of LHB distributed per block\r\n     * @param compRate_ The amount of LHB wei per block to distribute\r\n     */\r\n    function _setCompRate(uint compRate_) public {\r\n        require(adminOrInitializing(), \"only admin can change LHB rate\");\r\n\r\n        uint oldRate = compRate;\r\n        compRate = compRate_;\r\n        emit NewCompRate(oldRate, compRate_);\r\n\r\n        refreshCompSpeedsInternal();\r\n    }\r\n\r\n    /**\r\n     * @notice Add markets to compMarkets, allowing them to earn LHB in the flywheel\r\n     * @param cTokens The addresses of the markets to add\r\n     */\r\n    function _addCompMarkets(address[] memory cTokens) public {\r\n        require(adminOrInitializing(), \"only admin can add LHB market\");\r\n\r\n        for (uint i = 0; i < cTokens.length; i++) {\r\n            _addCompMarketInternal(cTokens[i]);\r\n        }\r\n\r\n        refreshCompSpeedsInternal();\r\n    }\r\n\r\n    function _addCompMarketInternal(address cToken) internal {\r\n        Market storage market = markets[cToken];\r\n        require(market.isListed == true, \"LHB market is not listed\");\r\n        require(market.isComped == false, \"LHB market already added\");\r\n\r\n        market.isComped = true;\r\n        emit MarketComped(CToken(cToken), true);\r\n\r\n        if (compSupplyState[cToken].index == 0 && compSupplyState[cToken].block == 0) {\r\n            compSupplyState[cToken] = CompMarketState({\r\n                index: compInitialIndex,\r\n                block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\r\n                });\r\n        }\r\n\r\n        if (compBorrowState[cToken].index == 0 && compBorrowState[cToken].block == 0) {\r\n            compBorrowState[cToken] = CompMarketState({\r\n                index: compInitialIndex,\r\n                block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\r\n                });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Remove a market from compMarkets, preventing it from earning LHB in the flywheel\r\n     * @param cToken The address of the market to drop\r\n     */\r\n    function _dropCompMarket(address cToken) public {\r\n        require(msg.sender == admin, \"only admin can drop LHB market\");\r\n\r\n        Market storage market = markets[cToken];\r\n        require(market.isComped == true, \"market is not a LHB market\");\r\n\r\n        market.isComped = false;\r\n        emit MarketComped(CToken(cToken), false);\r\n\r\n        refreshCompSpeedsInternal();\r\n    }\r\n\r\n    /**\r\n     * @notice Return all of the markets\r\n     * @dev The automatic getter may be used to access an individual market.\r\n     * @return The list of market addresses\r\n     */\r\n    function getAllMarkets() public view returns (CToken[] memory) {\r\n        return allMarkets;\r\n    }\r\n\r\n    function getBlockNumber() public view returns (uint) {\r\n        return block.number;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the address of the LHB token\r\n     * @return The address of LHB\r\n     */\r\n    function getCompAddress() public pure returns (address) {\r\n        return 0x8F67854497218043E1f72908FFE38D0Ed7F24721;\r\n    }\r\n    \r\n    /**\r\n     * @notice Return the cToken address of the token, if cToken not exist, create it\r\n     * @param token The address of the token to be query\r\n     * @return The address of cToken\r\n     */\r\n    function getCTokenAddress(address token) override public pure returns (address) {\r\n        // todo\r\n        token;\r\n        return 0x8F67854497218043E1f72908FFE38D0Ed7F24721;\r\n    }\r\n}\r\n"
    },
    "contracts/compound/ComptrollerStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\nimport \"./CToken.sol\";\r\nimport \"./PriceOracle.sol\";\r\n\r\ncontract UnitrollerAdminStorage {\r\n    /**\r\n    * @notice Administrator for this contract\r\n    */\r\n    address public admin;\r\n\r\n    /**\r\n    * @notice Pending administrator for this contract\r\n    */\r\n    address public pendingAdmin;\r\n\r\n    /**\r\n    * @notice Active brains of Unitroller\r\n    */\r\n    address public comptrollerImplementation;\r\n\r\n    /**\r\n    * @notice Pending brains of Unitroller\r\n    */\r\n    address public pendingComptrollerImplementation;\r\n}\r\n\r\ncontract ComptrollerV1Storage is UnitrollerAdminStorage {\r\n\r\n    /**\r\n     * @notice Oracle which gives the price of any given asset\r\n     */\r\n    PriceOracle public oracle;\r\n\r\n    /**\r\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\r\n     */\r\n    uint public closeFactorMantissa;\r\n\r\n    /**\r\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\r\n     */\r\n    uint public liquidationIncentiveMantissa;\r\n\r\n    /**\r\n     * @notice Max number of assets a single account can participate in (borrow or use as collateral)\r\n     */\r\n    uint public maxAssets;\r\n\r\n    /**\r\n     * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\r\n     */\r\n    mapping(address => CToken[]) public accountAssets;\r\n\r\n}\r\n\r\ncontract ComptrollerV2Storage is ComptrollerV1Storage {\r\n    struct Market {\r\n        // @notice Whether or not this market is listed\r\n        bool isListed;\r\n\r\n        /*\r\n         * @notice Multiplier representing the most one can borrow against their collateral in this market.\r\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\r\n         *  Must be between 0 and 1, and stored as a mantissa.\r\n         */\r\n        uint collateralFactorMantissa;\r\n\r\n        // @notice Per-market mapping of \"accounts in this asset\"\r\n        mapping(address => bool) accountMembership;\r\n\r\n        // @notice Whether or not this market receives LHB\r\n        bool isComped;\r\n    }\r\n\r\n    /**\r\n     * @notice Official mapping of cTokens -> Market metadata\r\n     * @dev Used e.g. to determine if a market is supported\r\n     */\r\n    mapping(address => Market) public markets;\r\n\r\n\r\n    /**\r\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\r\n     *  Actions which allow users to remove their own assets cannot be paused.\r\n     *  Liquidation / seizing / transfer can only be paused globally, not by market.\r\n     */\r\n    address public pauseGuardian;\r\n    bool public _mintGuardianPaused;\r\n    bool public _borrowGuardianPaused;\r\n    bool public transferGuardianPaused;\r\n    bool public seizeGuardianPaused;\r\n    mapping(address => bool) public mintGuardianPaused;\r\n    mapping(address => bool) public borrowGuardianPaused;\r\n}\r\n\r\ncontract ComptrollerV3Storage is ComptrollerV2Storage {\r\n    struct CompMarketState {\r\n        // @notice The market's last updated compBorrowIndex or compSupplyIndex\r\n        uint224 index;\r\n\r\n        // @notice The block number the index was last updated at\r\n        uint32 block;\r\n    }\r\n\r\n    /// @notice A list of all markets\r\n    CToken[] public allMarkets;\r\n\r\n    /// @notice The rate at which the flywheel distributes LHB, per block\r\n    uint public compRate;\r\n\r\n    /// @notice The portion of compRate that each market currently receives\r\n    mapping(address => uint) public compSpeeds;\r\n\r\n    /// @notice The LHB market supply state for each market\r\n    mapping(address => CompMarketState) public compSupplyState;\r\n\r\n    /// @notice The LHB market borrow state for each market\r\n    mapping(address => CompMarketState) public compBorrowState;\r\n\r\n    /// @notice The LHB borrow index for each market for each supplier as of the last time they accrued LHB\r\n    mapping(address => mapping(address => uint)) public compSupplierIndex;\r\n\r\n    /// @notice The LHB borrow index for each market for each borrower as of the last time they accrued LHB\r\n    mapping(address => mapping(address => uint)) public compBorrowerIndex;\r\n\r\n    /// @notice The LHB accrued but not yet transferred to each user\r\n    mapping(address => uint) public compAccrued;\r\n}\r\n\r\ncontract ComptrollerV4Storage is ComptrollerV3Storage {\r\n    // @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\r\n    address public borrowCapGuardian;\r\n\r\n    // @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\r\n    mapping(address => uint) public borrowCaps;\r\n}"
    },
    "contracts/compound/Unitroller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.7.6;\r\n\r\nimport \"./ErrorReporter.sol\";\r\nimport \"./ComptrollerStorage.sol\";\r\n/**\r\n * @title ComptrollerCore\r\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\r\n * CTokens should reference this contract as their comptroller.\r\n */\r\ncontract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\r\n\r\n    /**\r\n      * @notice Emitted when pendingComptrollerImplementation is changed\r\n      */\r\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\r\n\r\n    /**\r\n      * @notice Emitted when pendingComptrollerImplementation is accepted, which means comptroller implementation is updated\r\n      */\r\n    event NewImplementation(address oldImplementation, address newImplementation);\r\n\r\n    /**\r\n      * @notice Emitted when pendingAdmin is changed\r\n      */\r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n    /**\r\n      * @notice Emitted when pendingAdmin is accepted, which means admin is updated\r\n      */\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n    constructor() {\r\n        // Set admin to caller\r\n        admin = msg.sender;\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\r\n\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\r\n        }\r\n\r\n        address oldPendingImplementation = pendingComptrollerImplementation;\r\n\r\n        pendingComptrollerImplementation = newPendingImplementation;\r\n\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n    * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation\r\n    * @dev Admin function for new implementation to accept it's role as implementation\r\n    * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n    */\r\n    function _acceptImplementation() public returns (uint) {\r\n        // Check caller is pendingImplementation and pendingImplementation ≠ address(0)\r\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\r\n        }\r\n\r\n        // Save current values for inclusion in log\r\n        address oldImplementation = comptrollerImplementation;\r\n        address oldPendingImplementation = pendingComptrollerImplementation;\r\n\r\n        comptrollerImplementation = pendingComptrollerImplementation;\r\n\r\n        pendingComptrollerImplementation = address(0);\r\n\r\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n\r\n    /**\r\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @param newPendingAdmin New pending admin.\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\r\n        // Check caller = admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\r\n        }\r\n\r\n        // Save current value, if any, for inclusion in log\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store pendingAdmin with value newPendingAdmin\r\n        pendingAdmin = newPendingAdmin;\r\n\r\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\r\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\r\n      * @dev Admin function for pending admin to accept role and update admin\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _acceptAdmin() public returns (uint) {\r\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\r\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\r\n        }\r\n\r\n        // Save current values for inclusion in log\r\n        address oldAdmin = admin;\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store admin with value pendingAdmin\r\n        admin = pendingAdmin;\r\n\r\n        // Clear the pending value\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(oldAdmin, admin);\r\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @dev Delegates execution to an implementation contract.\r\n     * It returns to the external caller whatever the implementation returns\r\n     * or forwards reverts.\r\n     */\r\n    // function () payable external {\r\n    fallback() external payable {\r\n        // delegate all other functions to current implementation\r\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\r\n\r\n        assembly {\r\n              let free_mem_ptr := mload(0x40)\r\n              returndatacopy(free_mem_ptr, 0, returndatasize())\r\n\r\n              switch success\r\n              case 0 { revert(free_mem_ptr, returndatasize()) }\r\n              default { return(free_mem_ptr, returndatasize()) }\r\n        }\r\n    }\r\n    receive() external payable {\r\n        // delegate all other functions to current implementation\r\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\r\n\r\n        assembly {\r\n              let free_mem_ptr := mload(0x40)\r\n              returndatacopy(free_mem_ptr, 0, returndatasize())\r\n\r\n              switch success\r\n              case 0 { revert(free_mem_ptr, returndatasize()) }\r\n              default { return(free_mem_ptr, returndatasize()) }\r\n        }\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}