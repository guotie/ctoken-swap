{
  "language": "Solidity",
  "sources": {
    "contracts/common/ComptrollerInterface.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\ncontract ComptrollerInterface {\r\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\r\n    bool public constant isComptroller = true;\r\n\r\n    /*** Assets You Are In ***/\r\n\r\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\r\n    function exitMarket(address cToken) external returns (uint);\r\n\r\n    /*** Policy Hooks ***/\r\n\r\n    function mintAllowed(address cToken, address minter, uint mintAmount) external returns (uint);\r\n    function mintVerify(address cToken, address minter, uint mintAmount, uint mintTokens) external;\r\n\r\n    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) external returns (uint);\r\n    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\r\n\r\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) external returns (uint);\r\n    function borrowVerify(address cToken, address borrower, uint borrowAmount) external;\r\n\r\n    // 杠杆\r\n    function borrowMarginAllowed(address cToken, address borrower, uint borrowAmount) external returns (uint);\r\n\r\n    function repayBorrowAllowed(\r\n        address cToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount) external returns (uint);\r\n    function repayBorrowVerify(\r\n        address cToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount,\r\n        uint borrowerIndex) external;\r\n\r\n    function liquidateBorrowAllowed(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount) external returns (uint);\r\n    function liquidateBorrowVerify(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount,\r\n        uint seizeTokens) external;\r\n\r\n    function seizeAllowed(\r\n        address cTokenCollateral,\r\n        address cTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external returns (uint);\r\n    function seizeVerify(\r\n        address cTokenCollateral,\r\n        address cTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external;\r\n\r\n    function transferAllowed(address cToken, address src, address dst, uint transferTokens) external returns (uint);\r\n    function transferVerify(address cToken, address src, address dst, uint transferTokens) external;\r\n\r\n    /*** Liquidity/Liquidation Calculations ***/\r\n\r\n    function liquidateCalculateSeizeTokens(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        uint repayAmount) external view returns (uint, uint);\r\n\r\n\r\n    /**\r\n     * 根据 token 地址查找 cToken 地址\r\n     * 如果是ETH/HT/BNB, 应该先变成对应的 wrapped ETH/HT/BNB\r\n     */\r\n    function getCTokenAddress(address token) external view returns (address);\r\n    function _supportMarket(address cToken) external returns (uint);\r\n}\r\n"
    },
    "contracts/compound/CToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\nimport \"../common/ComptrollerInterface.sol\";\r\nimport \"../common/CTokenInterfaces.sol\";\r\nimport \"../common/InterestRateModel.sol\";\r\n\r\nimport \"./ErrorReporter.sol\";\r\nimport \"./Exponential.sol\";\r\nimport \"./EIP20Interface.sol\";\r\nimport \"./EIP20NonStandardInterface.sol\";\r\n\r\n// for debug\r\nimport \"hardhat/console.sol\";\r\n\r\n/**\r\n * @title LendHub's CToken Contract\r\n * @notice Abstract base for CTokens\r\n * @author LendHub\r\n */\r\ncontract CToken is CTokenInterface, Exponential, TokenErrorReporter {\r\n    /**\r\n     * @notice Initialize the money market\r\n     * @param comptroller_ The address of the Comptroller\r\n     * @param interestRateModel_ The address of the interest rate model\r\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\r\n     * @param name_ EIP-20 name of this token\r\n     * @param symbol_ EIP-20 symbol of this token\r\n     * @param decimals_ EIP-20 decimal precision of this token\r\n     */\r\n    function initialize(ComptrollerInterface comptroller_,\r\n                        InterestRateModel interestRateModel_,\r\n                        uint initialExchangeRateMantissa_,\r\n                        string memory name_,\r\n                        string memory symbol_,\r\n                        uint8 decimals_) public {\r\n        require(msg.sender == admin, \"only admin may initialize the market\");\r\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\r\n\r\n        // Set initial exchange rate\r\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\r\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\r\n\r\n        // Set the comptroller\r\n        uint err = _setComptroller(comptroller_);\r\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\r\n\r\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\r\n        accrualBlockNumber = getBlockNumber();\r\n        borrowIndex = mantissaOne;\r\n\r\n        // Set the interest rate model (depends on block number / borrow index)\r\n        err = _setInterestRateModelFresh(interestRateModel_);\r\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\r\n\r\n        name = name_;\r\n        symbol = symbol_;\r\n        decimals = decimals_;\r\n\r\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\r\n     * @dev Called by both `transfer` and `transferFrom` internally\r\n     * @param spender The address of the account performing the transfer\r\n     * @param src The address of the source account\r\n     * @param dst The address of the destination account\r\n     * @param tokens The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\r\n        // console.log(\"transfer ctoken:\", spender, src, dst);\r\n        /* Fail if transfer not allowed */\r\n        uint allowed = 0; // comptroller.transferAllowed(address(this), src, dst, tokens);\r\n        if (allowed != 0) {\r\n            // console.log(\"not allow transfer\");\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        /* Do not allow self-transfers */\r\n        if (src == dst) {\r\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\r\n        }\r\n\r\n        /* Get the allowance, infinite for the account owner */\r\n        uint startingAllowance = 0;\r\n        if (spender == src) {\r\n            startingAllowance = uint(-1);\r\n        } else {\r\n            startingAllowance = transferAllowances[src][spender];\r\n        }\r\n\r\n\r\n        /* Do the calculations, checking for {under,over}flow */\r\n        MathError mathErr;\r\n        uint allowanceNew;\r\n        uint srcTokensNew;\r\n        uint dstTokensNew;\r\n\r\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\r\n        }\r\n\r\n        console.log(startingAllowance, tokens, accountTokens[src]);\r\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\r\n        }\r\n\r\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        accountTokens[src] = srcTokensNew;\r\n        accountTokens[dst] = dstTokensNew;\r\n\r\n        /* Eat some of the allowance (if necessary) */\r\n        if (startingAllowance != uint(-1)) {\r\n            transferAllowances[src][spender] = allowanceNew;\r\n        }\r\n\r\n        /* We emit a Transfer event */\r\n        emit Transfer(src, dst, tokens);\r\n\r\n        comptroller.transferVerify(address(this), src, dst, tokens);\r\n\r\n        console.log(\"transfer ctoken success: %d\", tokens);\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n     * @param dst The address of the destination account\r\n     * @param amount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {\r\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `src` to `dst`\r\n     * @param src The address of the source account\r\n     * @param dst The address of the destination account\r\n     * @param amount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {\r\n        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Approve `spender` to transfer up to `amount` from `src`\r\n     * @dev This will overwrite the approval amount for `spender`\r\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\r\n     * @param spender The address of the account which may transfer tokens\r\n     * @param amount The number of tokens that are approved (-1 means infinite)\r\n     * @return Whether or not the approval succeeded\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool) {\r\n        address src = msg.sender;\r\n        transferAllowances[src][spender] = amount;\r\n        emit Approval(src, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the current allowance from `owner` for `spender`\r\n     * @param owner The address of the account which owns the tokens to be spent\r\n     * @param spender The address of the account which may transfer tokens\r\n     * @return The number of tokens allowed to be spent (-1 means infinite)\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256) {\r\n        return transferAllowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the token balance of the `owner`\r\n     * @param owner The address of the account to query\r\n     * @return The number of tokens owned by `owner`\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256) {\r\n        return accountTokens[owner];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the underlying balance of the `owner`\r\n     * @dev This also accrues interest in a transaction\r\n     * @param owner The address of the account to query\r\n     * @return The amount of underlying owned by `owner`\r\n     */\r\n    function balanceOfUnderlying(address owner) external returns (uint) {\r\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\r\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\r\n        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\r\n        return balance;\r\n    }\r\n\r\n    /**\r\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\r\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\r\n     * @param account Address of the account to snapshot\r\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\r\n     */\r\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\r\n        uint cTokenBalance = accountTokens[account];\r\n        uint borrowBalance;\r\n        uint exchangeRateMantissa;\r\n\r\n        MathError mErr;\r\n\r\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\r\n        if (mErr != MathError.NO_ERROR) {\r\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\r\n        }\r\n\r\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\r\n        if (mErr != MathError.NO_ERROR) {\r\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\r\n        }\r\n\r\n        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to simply retrieve block number\r\n     *  This exists mainly for inheriting test contracts to stub this result.\r\n     */\r\n    function getBlockNumber() internal view returns (uint) {\r\n        return block.number;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current per-block borrow interest rate for this cToken\r\n     * @return The borrow interest rate per block, scaled by 1e18\r\n     */\r\n    function borrowRatePerBlock() external view returns (uint) {\r\n        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current per-block supply interest rate for this cToken\r\n     * @return The supply interest rate per block, scaled by 1e18\r\n     */\r\n    function supplyRatePerBlock() external view returns (uint) {\r\n        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current total borrows plus accrued interest\r\n     * @return The total borrows with interest\r\n     */\r\n    function totalBorrowsCurrent() external nonReentrant returns (uint) {\r\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\r\n        return totalBorrows;\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\r\n     * @param account The address whose balance should be calculated after updating borrowIndex\r\n     * @return The calculated balance\r\n     */\r\n    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {\r\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\r\n        return borrowBalanceStored(account);\r\n    }\r\n\r\n    /**\r\n     * @notice Return the borrow balance of account based on stored data\r\n     * @param account The address whose balance should be calculated\r\n     * @return The calculated balance\r\n     */\r\n    function borrowBalanceStored(address account) public view returns (uint) {\r\n        (MathError err, uint result) = borrowBalanceStoredInternal(account);\r\n        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the borrow balance of account based on stored data\r\n     * @param account The address whose balance should be calculated\r\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\r\n     */\r\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\r\n        /* Note: we do not assert that the market is up to date */\r\n        MathError mathErr;\r\n        uint principalTimesIndex;\r\n        uint result;\r\n\r\n        /* Get borrowBalance and borrowIndex */\r\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\r\n\r\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\r\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\r\n         */\r\n        if (borrowSnapshot.principal == 0) {\r\n            return (MathError.NO_ERROR, 0);\r\n        }\r\n\r\n        /* Calculate new borrow balance using the interest index:\r\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\r\n         */\r\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (mathErr, 0);\r\n        }\r\n\r\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (mathErr, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, result);\r\n    }\r\n\r\n    // marginType: 0: LP margin; 1: swap margin\r\n    function borrowMarginBalanceStoredInternal(uint posId, uint marginType) internal view returns (MathError, uint) {\r\n        /* Note: we do not assert that the market is up to date */\r\n        MathError mathErr;\r\n        uint principalTimesIndex;\r\n        uint result;\r\n\r\n        /* Get borrowBalance and borrowIndex */\r\n        BorrowSnapshot storage borrowSnapshot = lpMarginBorrows[posId];\r\n        \r\n        if (marginType != 0) {\r\n        //     borrowSnapshot = lpMarginBorrows[posId];\r\n        // } else {\r\n            borrowSnapshot = swapMarginBorrows[posId];\r\n        }\r\n\r\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\r\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\r\n         */\r\n        if (borrowSnapshot.principal == 0) {\r\n            return (MathError.NO_ERROR, 0);\r\n        }\r\n\r\n        /* Calculate new borrow balance using the interest index:\r\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\r\n         */\r\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (mathErr, 0);\r\n        }\r\n\r\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (mathErr, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, result);\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue interest then return the up-to-date exchange rate\r\n     * @return Calculated exchange rate scaled by 1e18\r\n     */\r\n    function exchangeRateCurrent() public nonReentrant returns (uint) {\r\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\r\n        return exchangeRateStored();\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the exchange rate from the underlying to the CToken\r\n     * @dev This function does not accrue interest before calculating the exchange rate\r\n     * @return Calculated exchange rate scaled by 1e18\r\n     */\r\n    function exchangeRateStored() public view returns (uint) {\r\n        (MathError err, uint result) = exchangeRateStoredInternal();\r\n        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the exchange rate from the underlying to the CToken\r\n     * @dev This function does not accrue interest before calculating the exchange rate\r\n     * @return (error code, calculated exchange rate scaled by 1e18)\r\n     */\r\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\r\n        // console.log('exchangeRateStoredInternal address: %s', address(this));\r\n\r\n        uint _totalSupply = totalSupply;\r\n        if (_totalSupply == 0) {\r\n            /*\r\n             * If there are no tokens minted:\r\n             *  exchangeRate = initialExchangeRate\r\n             */\r\n            //  console.log('initialExchangeRateMantissa: %d', initialExchangeRateMantissa);\r\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\r\n        } else {\r\n            /*\r\n             * Otherwise:\r\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\r\n             */\r\n            uint totalCash = getCashPrior();\r\n            uint cashPlusBorrowsMinusReserves;\r\n            Exp memory exchangeRate;\r\n            MathError mathErr;\r\n\r\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\r\n            if (mathErr != MathError.NO_ERROR) {\r\n                return (mathErr, 0);\r\n            }\r\n\r\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\r\n            if (mathErr != MathError.NO_ERROR) {\r\n                return (mathErr, 0);\r\n            }\r\n\r\n            // console.log(\"exchangeRateStoredInternal: totalCash: %d\", totalCash);\r\n            // console.log(\"exchangeRateStoredInternal: totalBorrows: %d\", totalBorrows);\r\n            // console.log(\"exchangeRateStoredInternal: totalReserves: %d\", totalReserves);\r\n            // console.log(\"exchangeRateStoredInternal: totalSupply: %d\", totalSupply);\r\n            // console.log(\"exchangeRateStoredInternal: exchangeRate: %d\", exchangeRate.mantissa);\r\n            // console.log(totalCash, totalBorrows, totalReserves, _totalSupply);\r\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get cash balance of this cToken in the underlying asset\r\n     * @return The quantity of underlying asset owned by this contract\r\n     */\r\n    function getCash() external view returns (uint) {\r\n        return getCashPrior();\r\n    }\r\n\r\n    /**\r\n     * @notice Applies accrued interest to total borrows and reserves\r\n     * @dev This calculates interest accrued from the last checkpointed block\r\n     *   up to the current block and writes new checkpoint to storage.\r\n     *   更新利息 每个块只计算一次利息\r\n     */\r\n    function accrueInterest() public returns (uint) {\r\n        /* Remember the initial block number */\r\n        uint currentBlockNumber = getBlockNumber();\r\n        uint accrualBlockNumberPrior = accrualBlockNumber;\r\n\r\n        /* Short-circuit accumulating 0 interest */\r\n        if (accrualBlockNumberPrior == currentBlockNumber) {\r\n            return uint(Error.NO_ERROR);\r\n        }\r\n\r\n        /* Read the previous values out of storage */\r\n        uint cashPrior = getCashPrior();  // token 的数量\r\n        uint borrowsPrior = totalBorrows;\r\n        uint reservesPrior = totalReserves;\r\n        uint borrowIndexPrior = borrowIndex;\r\n\r\n        /* Calculate the current borrow interest rate */\r\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\r\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\r\n\r\n        /* Calculate the number of blocks elapsed since the last accrual */\r\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\r\n        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\r\n\r\n        /*\r\n         * Calculate the interest accumulated into borrows and reserves and the new index:\r\n         *  simpleInterestFactor = borrowRate * blockDelta\r\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\r\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\r\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\r\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\r\n         */\r\n\r\n        Exp memory simpleInterestFactor;\r\n        uint interestAccumulated;\r\n        uint totalBorrowsNew;\r\n        uint totalReservesNew;\r\n        uint borrowIndexNew;\r\n\r\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa: borrowRateMantissa}), blockDelta);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(mathErr));\r\n        }\r\n\r\n        // 增加的利息收入\r\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(mathErr));\r\n        }\r\n\r\n        // 更新借款 借款 = 借款 + 利息\r\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(mathErr));\r\n        }\r\n\r\n        // 增加准备金 \r\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(mathErr));\r\n        }\r\n\r\n        // 更新贷款利息\r\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(mathErr));\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /* We write the previously calculated values into storage */\r\n        accrualBlockNumber = currentBlockNumber;\r\n        borrowIndex = borrowIndexNew;\r\n        totalBorrows = totalBorrowsNew;\r\n        totalReserves = totalReservesNew;\r\n\r\n        /* We emit an AccrueInterest event */\r\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\r\n     */\r\n    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\r\n            return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);\r\n        }\r\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\r\n        return mintFresh(msg.sender, mintAmount);\r\n    }\r\n\r\n    struct MintLocalVars {\r\n        Error err;\r\n        MathError mathErr;\r\n        uint exchangeRateMantissa;\r\n        uint mintTokens;\r\n        uint totalSupplyNew;\r\n        uint accountTokensNew;\r\n        uint actualMintAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice User supplies assets into the market and receives cTokens in exchange\r\n     * @dev Assumes interest has already been accrued up to the current block\r\n     * @param minter The address of the account which is supplying the assets\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\r\n     */\r\n    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\r\n        /* Fail if mint not allowed */\r\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\r\n        if (allowed != 0) {\r\n            // console.log(\"token not allowed\");\r\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\r\n        }\r\n\r\n        /* Verify market's block number equals current block number */\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\r\n        }\r\n\r\n        MintLocalVars memory vars;\r\n\r\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /*\r\n         *  We call `doTransferIn` for the minter and the mintAmount.\r\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\r\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\r\n         *  side-effects occurred. The function returns the amount actually transferred,\r\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\r\n         *  of cash.\r\n         */\r\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\r\n\r\n        /*\r\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\r\n         *  mintTokens = actualMintAmount / exchangeRate\r\n         */\r\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\r\n        // console.log(\"mintAmount: %d exchangeRate: %d mintTokens: %d\", vars.actualMintAmount, vars.exchangeRateMantissa, vars.mintTokens);\r\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\r\n\r\n        /*\r\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\r\n         *  totalSupplyNew = totalSupply + mintTokens\r\n         *  accountTokensNew = accountTokens[minter] + mintTokens\r\n         */\r\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\r\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\r\n\r\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\r\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\r\n\r\n        /* We write previously calculated values into storage */\r\n        totalSupply = vars.totalSupplyNew;\r\n        accountTokens[minter] = vars.accountTokensNew;\r\n\r\n        /* We emit a Mint event, and a Transfer event */\r\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\r\n        emit Transfer(address(this), minter, vars.mintTokens);\r\n\r\n        /* We call the defense hook */\r\n        comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\r\n\r\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems cTokens in exchange for the underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemTokens The number of cTokens to redeem into underlying\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {\r\n        console.log(\"redeemInternal:\", redeemTokens);\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            console.log(\"accrueInterest failed:\", error);\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\r\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\r\n        return redeemFresh(msg.sender, redeemTokens, 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemAmount The amount of underlying to receive from redeeming cTokens\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\r\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\r\n        return redeemFresh(msg.sender, 0, redeemAmount);\r\n    }\r\n\r\n    struct RedeemLocalVars {\r\n        Error err;\r\n        MathError mathErr;\r\n        uint exchangeRateMantissa;\r\n        uint redeemTokens;\r\n        uint redeemAmount;\r\n        uint totalSupplyNew;\r\n        uint accountTokensNew;\r\n    }\r\n\r\n    /**\r\n     * @notice User redeems cTokens in exchange for the underlying asset\r\n     * @dev Assumes interest has already been accrued up to the current block\r\n     * @param redeemer The address of the account which is redeeming the tokens\r\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\r\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\r\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\r\n\r\n        RedeemLocalVars memory vars;\r\n\r\n        /* exchangeRate = invoke Exchange Rate Stored() */\r\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            // console.log('redeemFresh: exchangeRateStoredInternal failed');\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        /* If redeemTokensIn > 0: */\r\n        if (redeemTokensIn > 0) {\r\n            /*\r\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\r\n             *  redeemTokens = redeemTokensIn\r\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\r\n             */\r\n            vars.redeemTokens = redeemTokensIn;\r\n\r\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\r\n            if (vars.mathErr != MathError.NO_ERROR) {\r\n                // console.log('redeemFresh: mulScalarTruncate failed');\r\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\r\n            }\r\n        } else {\r\n            /*\r\n             * We get the current exchange rate and calculate the amount to be redeemed:\r\n             *  redeemTokens = redeemAmountIn / exchangeRate\r\n             *  redeemAmount = redeemAmountIn\r\n             */\r\n\r\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\r\n            if (vars.mathErr != MathError.NO_ERROR) {\r\n                console.log('redeemFresh: divScalarByExpTruncate failed');\r\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\r\n            }\r\n\r\n            vars.redeemAmount = redeemAmountIn;\r\n        }\r\n\r\n        /* Fail if redeem not allowed */\r\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\r\n        if (allowed != 0) {\r\n            console.log('redeemFresh: redeem not allowed:', allowed, address(this));\r\n            // return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        /* Verify market's block number equals current block number */\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            console.log('redeemFresh: MARKET_NOT_FRESH');\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\r\n        }\r\n\r\n        /*\r\n         * We calculate the new total supply and redeemer balance, checking for underflow:\r\n         *  totalSupplyNew = totalSupply - redeemTokens\r\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\r\n         */\r\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            console.log('redeemFresh: subUInt failed: totalSupply=%d redeemTokens=%d', totalSupply, vars.redeemTokens);\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            console.log('redeemFresh: subUInt failed: accountTokens[redeemer]=%d redeemTokens=%d', accountTokens[redeemer], vars.redeemTokens);\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        /* Fail gracefully if protocol has insufficient cash */\r\n        if (getCashPrior() < vars.redeemAmount) {\r\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /*\r\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\r\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\r\n         *  On success, the cToken has redeemAmount less of cash.\r\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\r\n         */\r\n        console.log(\"prepare to doTransferOut ....\", vars.redeemAmount);\r\n        doTransferOut(redeemer, vars.redeemAmount);\r\n\r\n        /* We write previously calculated values into storage */\r\n        totalSupply = vars.totalSupplyNew;\r\n        accountTokens[redeemer] = vars.accountTokensNew;\r\n\r\n        /* We emit a Transfer event, and a Redeem event */\r\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\r\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\r\n\r\n        /* We call the defense hook */\r\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sender borrows assets from the protocol to their own address\r\n      * @param borrowAmount The amount of the underlying asset to borrow\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\r\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\r\n        return borrowFresh(msg.sender, borrowAmount);\r\n    }\r\n\r\n    struct BorrowLocalVars {\r\n        MathError mathErr;\r\n        uint accountBorrows;\r\n        uint accountBorrowsNew;\r\n        uint totalBorrowsNew;\r\n    }\r\n\r\n    /**\r\n      * @notice Users borrow assets from the protocol to their own address\r\n      * @param borrowAmount The amount of the underlying asset to borrow\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\r\n        /* Fail if borrow not allowed */\r\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        /* Verify market's block number equals current block number */\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\r\n        }\r\n\r\n        /* Fail gracefully if protocol has insufficient underlying cash */\r\n        if (getCashPrior() < borrowAmount) {\r\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\r\n        }\r\n\r\n        BorrowLocalVars memory vars;\r\n\r\n        /*\r\n         * We calculate the new borrower and total borrow balances, failing on overflow:\r\n         *  accountBorrowsNew = accountBorrows + borrowAmount\r\n         *  totalBorrowsNew = totalBorrows + borrowAmount\r\n         */\r\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /*\r\n         * We invoke doTransferOut for the borrower and the borrowAmount.\r\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\r\n         *  On success, the cToken borrowAmount less of cash.\r\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\r\n         */\r\n        doTransferOut(borrower, borrowAmount);\r\n\r\n        /* We write the previously calculated values into storage */\r\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\r\n        accountBorrows[borrower].interestIndex = borrowIndex;\r\n        totalBorrows = vars.totalBorrowsNew;\r\n\r\n        /* We emit a Borrow event */\r\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\r\n\r\n        /* We call the defense hook */\r\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sender borrows assets from the protocol to their own address\r\n      * @param borrowAmount The amount of the underlying asset to borrow\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function borrowMarginInternal(address borrower, uint posId, uint borrowAmount, uint marginType) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\r\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\r\n        return borrowMarginFresh(msg.sender, borrower, posId, borrowAmount, marginType);\r\n    }\r\n\r\n    /**\r\n      * @notice 杠杆借贷 真实的币转给 borrower, 记账记在 realBorrower\r\n      * @param borrowAmount The amount of the underlying asset to borrow\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function borrowMarginFresh(address payable borrower, address realBorrower, uint posId, uint borrowAmount, uint marginType) internal returns (uint) {\r\n        /* Fail if borrow not allowed */\r\n        // todo 这里不需要要验证用户是否有流动性问题, 只需要做基本的检查即可 还有 comp 的分发！！！\r\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        /* Verify market's block number equals current block number */\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\r\n        }\r\n\r\n        /* Fail gracefully if protocol has insufficient underlying cash */\r\n        if (getCashPrior() < borrowAmount) {\r\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\r\n        }\r\n\r\n        BorrowLocalVars memory vars;\r\n\r\n        /*\r\n         * We calculate the new borrower and total borrow balances, failing on overflow:\r\n         *  accountBorrowsNew = accountBorrows + borrowAmount\r\n         *  totalBorrowsNew = totalBorrows + borrowAmount\r\n         */\r\n        (vars.mathErr, vars.accountBorrows) = borrowMarginBalanceStoredInternal(posId, marginType);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /*\r\n         * We invoke doTransferOut for the borrower and the borrowAmount.\r\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\r\n         *  On success, the cToken borrowAmount less of cash.\r\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\r\n         */\r\n        doTransferOut(borrower, borrowAmount);\r\n\r\n        /* We write the previously calculated values into storage */\r\n        accountBorrows[realBorrower].principal = vars.accountBorrowsNew;\r\n        accountBorrows[realBorrower].interestIndex = borrowIndex;\r\n        totalBorrows = vars.totalBorrowsNew;\r\n\r\n        /* We emit a Borrow event */\r\n        emit Borrow(realBorrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\r\n\r\n        /* We call the defense hook */\r\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender repays their own borrow\r\n     * @param repayAmount The amount to repay\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\r\n     */\r\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\r\n            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\r\n        }\r\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\r\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender repays a borrow belonging to borrower\r\n     * @param borrower the account with the debt being payed off\r\n     * @param repayAmount The amount to repay\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\r\n     */\r\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\r\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\r\n        }\r\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\r\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\r\n    }\r\n\r\n    struct RepayBorrowLocalVars {\r\n        Error err;\r\n        MathError mathErr;\r\n        uint repayAmount;\r\n        uint borrowerIndex;\r\n        uint accountBorrows;\r\n        uint accountBorrowsNew;\r\n        uint totalBorrowsNew;\r\n        uint actualRepayAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Borrows are repaid by another user (possibly the borrower).\r\n     * @param payer the account paying off the borrow\r\n     * @param borrower the account with the debt being payed off\r\n     * @param repayAmount the amount of undelrying tokens being returned\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\r\n     */\r\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\r\n        /* Fail if repayBorrow not allowed */\r\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\r\n        if (allowed != 0) {\r\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);\r\n        }\r\n\r\n        /* Verify market's block number equals current block number */\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\r\n        }\r\n\r\n        RepayBorrowLocalVars memory vars;\r\n\r\n        /* We remember the original borrowerIndex for verification purposes */\r\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\r\n\r\n        /* We fetch the amount the borrower owes, with accumulated interest */\r\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);\r\n        }\r\n\r\n        /* If repayAmount == -1, repayAmount = accountBorrows */\r\n        if (repayAmount == uint(-1)) {\r\n            vars.repayAmount = vars.accountBorrows;\r\n        } else {\r\n            vars.repayAmount = repayAmount;\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /*\r\n         * We call doTransferIn for the payer and the repayAmount\r\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\r\n         *  On success, the cToken holds an additional repayAmount of cash.\r\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\r\n         *   it returns the amount actually transferred, in case of a fee.\r\n         */\r\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\r\n\r\n        /*\r\n         * We calculate the new borrower and total borrow balances, failing on underflow:\r\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\r\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\r\n         */\r\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\r\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\r\n\r\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\r\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\r\n\r\n        /* We write the previously calculated values into storage */\r\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\r\n        accountBorrows[borrower].interestIndex = borrowIndex;\r\n        totalBorrows = vars.totalBorrowsNew;\r\n\r\n        /* We emit a RepayBorrow event */\r\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\r\n\r\n        /* We call the defense hook */\r\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\r\n\r\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Borrows are repaid by another user (possibly the borrower).\r\n     * @param payer the account paying off the borrow\r\n     * @param borrower the account with the debt being payed off\r\n     * @param repayAmount the amount of undelrying tokens being returned\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\r\n     */\r\n    function repayBorrowMarginFresh(uint posId, address payer, address borrower, uint repayAmount, uint marginType) internal returns (uint, uint) {\r\n        /* Fail if repayBorrow not allowed */\r\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\r\n        if (allowed != 0) {\r\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);\r\n        }\r\n\r\n        /* Verify market's block number equals current block number */\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\r\n        }\r\n\r\n        RepayBorrowLocalVars memory vars;\r\n\r\n        /* We remember the original borrowerIndex for verification purposes */\r\n        if (marginType == 0) {\r\n            vars.borrowerIndex = lpMarginBorrows[posId].interestIndex;\r\n        } else {\r\n            vars.borrowerIndex = swapMarginBorrows[posId].interestIndex;\r\n        }\r\n\r\n        /* We fetch the amount the borrower owes, with accumulated interest */\r\n        (vars.mathErr, vars.accountBorrows) = borrowMarginBalanceStoredInternal(posId, marginType);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);\r\n        }\r\n\r\n        /* If repayAmount == -1, repayAmount = accountBorrows */\r\n        if (repayAmount == uint(-1)) {\r\n            vars.repayAmount = vars.accountBorrows;\r\n        } else {\r\n            vars.repayAmount = repayAmount;\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /*\r\n         * We call doTransferIn for the payer and the repayAmount\r\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\r\n         *  On success, the cToken holds an additional repayAmount of cash.\r\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\r\n         *   it returns the amount actually transferred, in case of a fee.\r\n         */\r\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\r\n\r\n        /*\r\n         * We calculate the new borrower and total borrow balances, failing on underflow:\r\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\r\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\r\n         */\r\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\r\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\r\n\r\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\r\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\r\n\r\n        /* We write the previously calculated values into storage */\r\n        if (marginType == 0) {\r\n            lpMarginBorrows[posId].principal = vars.accountBorrowsNew;\r\n            lpMarginBorrows[posId].interestIndex = borrowIndex;\r\n        } else {\r\n            swapMarginBorrows[posId].principal = vars.accountBorrowsNew;\r\n            swapMarginBorrows[posId].interestIndex = borrowIndex;\r\n        }\r\n        totalBorrows = vars.totalBorrowsNew;\r\n\r\n        /* We emit a RepayBorrow event */\r\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\r\n\r\n        /* We call the defense hook */\r\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\r\n\r\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice The sender liquidates the borrowers collateral.\r\n     *  The collateral seized is transferred to the liquidator.\r\n     * @param borrower The borrower of this cToken to be liquidated\r\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\r\n     * @param repayAmount The amount of the underlying borrowed asset to repay\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\r\n     */\r\n    function liquidateBorrowInternal(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal nonReentrant returns (uint, uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\r\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\r\n        }\r\n\r\n        error = cTokenCollateral.accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\r\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\r\n        }\r\n\r\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\r\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\r\n    }\r\n\r\n    /**\r\n     * @notice The liquidator liquidates the borrowers collateral.\r\n     *  The collateral seized is transferred to the liquidator.\r\n     * @param borrower The borrower of this cToken to be liquidated\r\n     * @param liquidator The address repaying the borrow and seizing collateral\r\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\r\n     * @param repayAmount The amount of the underlying borrowed asset to repay\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\r\n     */\r\n    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal returns (uint, uint) {\r\n        /* Fail if liquidate not allowed */\r\n        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);\r\n        if (allowed != 0) {\r\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\r\n        }\r\n\r\n        /* Verify market's block number equals current block number */\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);\r\n        }\r\n\r\n        /* Verify cTokenCollateral market's block number equals current block number */\r\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\r\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);\r\n        }\r\n\r\n        /* Fail if borrower = liquidator */\r\n        if (borrower == liquidator) {\r\n            return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\r\n        }\r\n\r\n        /* Fail if repayAmount = 0 */\r\n        if (repayAmount == 0) {\r\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\r\n        }\r\n\r\n        /* Fail if repayAmount = -1 */\r\n        if (repayAmount == uint(-1)) {\r\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\r\n        }\r\n\r\n\r\n        /* Fail if repayBorrow fails */\r\n        (uint repayBorrowError, uint actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\r\n        if (repayBorrowError != uint(Error.NO_ERROR)) {\r\n            return (fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /* We calculate the number of collateral tokens that will be seized */\r\n        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), actualRepayAmount);\r\n        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\r\n\r\n        /* Revert if borrower collateral token balance < seizeTokens */\r\n        require(cTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\r\n\r\n        // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\r\n        uint seizeError;\r\n        if (address(cTokenCollateral) == address(this)) {\r\n            seizeError = seizeInternal(address(this), liquidator, borrower, seizeTokens);\r\n        } else {\r\n            seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);\r\n        }\r\n\r\n        /* Revert if seize tokens fails (since we cannot be sure of side effects) */\r\n        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\r\n\r\n        /* We emit a LiquidateBorrow event */\r\n        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(cTokenCollateral), seizeTokens);\r\n\r\n        /* We call the defense hook */\r\n        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, actualRepayAmount, seizeTokens);\r\n\r\n        return (uint(Error.NO_ERROR), actualRepayAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers collateral tokens (this market) to the liquidator.\r\n     * @dev Will fail unless called by another cToken during the process of liquidation.\r\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\r\n     * @param liquidator The account receiving seized collateral\r\n     * @param borrower The account having collateral seized\r\n     * @param seizeTokens The number of cTokens to seize\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\r\n        return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers collateral tokens (this market) to the liquidator.\r\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\r\n     *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\r\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\r\n     * @param liquidator The account receiving seized collateral\r\n     * @param borrower The account having collateral seized\r\n     * @param seizeTokens The number of cTokens to seize\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\r\n        /* Fail if seize not allowed */\r\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        /* Fail if borrower = liquidator */\r\n        if (borrower == liquidator) {\r\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\r\n        }\r\n\r\n        MathError mathErr;\r\n        uint borrowerTokensNew;\r\n        uint liquidatorTokensNew;\r\n\r\n        /*\r\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\r\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\r\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\r\n         */\r\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\r\n        }\r\n\r\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /* We write the previously calculated values into storage */\r\n        accountTokens[borrower] = borrowerTokensNew;\r\n        accountTokens[liquidator] = liquidatorTokensNew;\r\n\r\n        /* Emit a Transfer event */\r\n        emit Transfer(borrower, liquidator, seizeTokens);\r\n\r\n        /* We call the defense hook */\r\n        comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    /**\r\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @param newPendingAdmin New pending admin.\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\r\n        // Check caller = admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\r\n        }\r\n\r\n        // Save current value, if any, for inclusion in log\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store pendingAdmin with value newPendingAdmin\r\n        pendingAdmin = newPendingAdmin;\r\n\r\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\r\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\r\n      * @dev Admin function for pending admin to accept role and update admin\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _acceptAdmin() external returns (uint) {\r\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\r\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\r\n        }\r\n\r\n        // Save current values for inclusion in log\r\n        address oldAdmin = admin;\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store admin with value pendingAdmin\r\n        admin = pendingAdmin;\r\n\r\n        // Clear the pending value\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(oldAdmin, admin);\r\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets a new comptroller for the market\r\n      * @dev Admin function to set a new comptroller\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\r\n        }\r\n\r\n        ComptrollerInterface oldComptroller = comptroller;\r\n        // Ensure invoke comptroller.isComptroller() returns true\r\n        require(newComptroller.isComptroller(), \"marker method returned false\");\r\n\r\n        // Set market's comptroller to newComptroller\r\n        comptroller = newComptroller;\r\n\r\n        // Emit NewComptroller(oldComptroller, newComptroller)\r\n        emit NewComptroller(oldComptroller, newComptroller);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\r\n      * @dev Admin function to accrue interest and set a new reserve factor\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\r\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\r\n        return _setReserveFactorFresh(newReserveFactorMantissa);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\r\n      * @dev Admin function to set a new reserve factor\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\r\n        }\r\n\r\n        // Verify market's block number equals current block number\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\r\n        }\r\n\r\n        // Check newReserveFactor ≤ maxReserveFactor\r\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\r\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\r\n        }\r\n\r\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\r\n        reserveFactorMantissa = newReserveFactorMantissa;\r\n\r\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Accrues interest and reduces reserves by transferring from msg.sender\r\n     * @param addAmount Amount of addition to reserves\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\r\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\r\n        }\r\n\r\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\r\n        (error, ) = _addReservesFresh(addAmount);\r\n        return error;\r\n    }\r\n\r\n    /**\r\n     * @notice Add reserves by transferring from caller\r\n     * @dev Requires fresh interest accrual\r\n     * @param addAmount Amount of addition to reserves\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\r\n     */\r\n    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\r\n        // totalReserves + actualAddAmount\r\n        uint totalReservesNew;\r\n        uint actualAddAmount;\r\n\r\n        // We fail gracefully unless market's block number equals current block number\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /*\r\n         * We call doTransferIn for the caller and the addAmount\r\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\r\n         *  On success, the cToken holds an additional addAmount of cash.\r\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\r\n         *  it returns the amount actually transferred, in case of a fee.\r\n         */\r\n\r\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\r\n\r\n        totalReservesNew = totalReserves + actualAddAmount;\r\n\r\n        /* Revert on overflow */\r\n        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\r\n\r\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\r\n        totalReserves = totalReservesNew;\r\n\r\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\r\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\r\n\r\n        /* Return (NO_ERROR, actualAddAmount) */\r\n        return (uint(Error.NO_ERROR), actualAddAmount);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Accrues interest and reduces reserves by transferring to admin\r\n     * @param reduceAmount Amount of reduction to reserves\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\r\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\r\n        return _reduceReservesFresh(reduceAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Reduces reserves by transferring to admin\r\n     * @dev Requires fresh interest accrual\r\n     * @param reduceAmount Amount of reduction to reserves\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\r\n        // totalReserves - reduceAmount\r\n        uint totalReservesNew;\r\n\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\r\n        }\r\n\r\n        // We fail gracefully unless market's block number equals current block number\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\r\n        }\r\n\r\n        // Fail gracefully if protocol has insufficient underlying cash\r\n        if (getCashPrior() < reduceAmount) {\r\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\r\n        }\r\n\r\n        // Check reduceAmount ≤ reserves[n] (totalReserves)\r\n        if (reduceAmount > totalReserves) {\r\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        totalReservesNew = totalReserves - reduceAmount;\r\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\r\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\r\n\r\n        // Store reserves[n+1] = reserves[n] - reduceAmount\r\n        totalReserves = totalReservesNew;\r\n\r\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\r\n        doTransferOut(admin, reduceAmount);\r\n\r\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\r\n     * @dev Admin function to accrue interest and update the interest rate model\r\n     * @param newInterestRateModel the new interest rate model to use\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\r\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\r\n        return _setInterestRateModelFresh(newInterestRateModel);\r\n    }\r\n\r\n    /**\r\n     * @notice updates the interest rate model (*requires fresh interest accrual)\r\n     * @dev Admin function to update the interest rate model\r\n     * @param newInterestRateModel the new interest rate model to use\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\r\n\r\n        // Used to store old model for use in the event that is emitted on success\r\n        InterestRateModel oldInterestRateModel;\r\n\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\r\n        }\r\n\r\n        // We fail gracefully unless market's block number equals current block number\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\r\n        }\r\n\r\n        // Track the market's current interest rate model\r\n        oldInterestRateModel = interestRateModel;\r\n\r\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\r\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\r\n\r\n        // Set the interest rate model to newInterestRateModel\r\n        interestRateModel = newInterestRateModel;\r\n\r\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\r\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /*** Safe Token ***/\r\n\r\n    /**\r\n     * @notice Gets balance of this contract in terms of the underlying\r\n     * @dev This excludes the value of the current message, if any\r\n     * @return The quantity of underlying owned by this contract\r\n     */\r\n    function getCashPrior() internal view returns (uint);\r\n\r\n    /**\r\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\r\n     *  This may revert due to insufficient balance or insufficient allowance.\r\n     */\r\n    function doTransferIn(address from, uint amount) internal returns (uint);\r\n\r\n    /**\r\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\r\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\r\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\r\n     */\r\n    function doTransferOut(address payable to, uint amount) internal;\r\n\r\n\r\n    /*** Reentrancy Guard ***/\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     */\r\n    modifier nonReentrant() {\r\n        require(_notEntered, \"re-entered\");\r\n        _notEntered = false;\r\n        _;\r\n        _notEntered = true; // get a gas-refund post-Istanbul\r\n    }\r\n}\r\n"
    },
    "contracts/common/CTokenInterfaces.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\nimport \"./ComptrollerInterface.sol\";\r\nimport \"./InterestRateModel.sol\";\r\n\r\ncontract CTokenStorage {\r\n    /**\r\n     * @dev Guard variable for re-entrancy checks\r\n     */\r\n    bool internal _notEntered;\r\n\r\n    /**\r\n     * @notice EIP-20 token name for this token\r\n     */\r\n    string public name;\r\n\r\n    /**\r\n     * @notice EIP-20 token symbol for this token\r\n     */\r\n    string public symbol;\r\n\r\n    /**\r\n     * @notice EIP-20 token decimals for this token\r\n     */\r\n    uint8 public decimals;\r\n\r\n    /*\r\n     * @notice Maximum borrow rate that can ever be applied (.0005% / block)\r\n     */\r\n\r\n    uint internal constant borrowRateMaxMantissa = 0.0005e16;\r\n\r\n    /*\r\n     * @notice Maximum fraction of interest that can be set aside for reserves\r\n     */\r\n    uint internal constant reserveFactorMaxMantissa = 1e18;\r\n\r\n    /**\r\n     * @notice Administrator for this contract\r\n     */\r\n    address payable public admin;\r\n\r\n    /**\r\n     * @notice Pending administrator for this contract\r\n     */\r\n    address payable public pendingAdmin;\r\n\r\n    /**\r\n     * @notice Contract which oversees inter-cToken operations\r\n     */\r\n    ComptrollerInterface public comptroller;\r\n\r\n    /**\r\n     * @notice Model which tells what the current interest rate should be\r\n     */\r\n    InterestRateModel public interestRateModel;\r\n\r\n    /*\r\n     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\r\n     */\r\n    uint internal initialExchangeRateMantissa;\r\n\r\n    /**\r\n     * @notice Fraction of interest currently set aside for reserves\r\n     */\r\n    uint public reserveFactorMantissa;\r\n\r\n    /**\r\n     * @notice Block number that interest was last accrued at\r\n     */\r\n    uint public accrualBlockNumber;\r\n\r\n    /**\r\n     * @notice Accumulator of the total earned interest rate since the opening of the market\r\n     */\r\n    uint public borrowIndex;\r\n\r\n    /**\r\n     * @notice Total amount of outstanding borrows of the underlying in this market\r\n     */\r\n    uint public totalBorrows;\r\n\r\n    /**\r\n     * @notice Total amount of reserves of the underlying held in this market\r\n     */\r\n    uint public totalReserves;\r\n\r\n    /**\r\n     * @notice Total number of tokens in circulation\r\n     */\r\n    uint public totalSupply;\r\n\r\n    /*\r\n     * @notice Official record of token balances for each account\r\n     */\r\n    mapping (address => uint) internal accountTokens;\r\n\r\n    /*\r\n     * @notice Approved token transfer amounts on behalf of others\r\n     */\r\n    mapping (address => mapping (address => uint)) internal transferAllowances;\r\n\r\n    /**\r\n     * @notice Container for borrow balance information\r\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\r\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\r\n     */\r\n    struct BorrowSnapshot {\r\n        uint principal;\r\n        uint interestIndex;\r\n    }\r\n\r\n    /*\r\n     * @notice Mapping of account addresses to outstanding borrow balances\r\n     */\r\n    mapping(address => BorrowSnapshot) internal accountBorrows;\r\n\r\n    /*\r\n     * @notice 流动性杠杆账户 借出的token 由 marginLP 合约代持\r\n     * key 是 position id\r\n     */\r\n    mapping(uint => BorrowSnapshot) internal lpMarginBorrows;\r\n    /*\r\n     * @notice swap杠杆账户 借出的token 由 marginSwap 合约代持\r\n     */\r\n    mapping(uint => BorrowSnapshot) internal swapMarginBorrows;\r\n}\r\n\r\ncontract CTokenInterface is CTokenStorage {\r\n    /**\r\n     * @notice Indicator that this is a CToken contract (for inspection)\r\n     */\r\n    bool public constant isCToken = true;\r\n\r\n\r\n    /*** Market Events ***/\r\n\r\n    /**\r\n     * @notice Event emitted when interest is accrued\r\n     */\r\n    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\r\n\r\n    /**\r\n     * @notice Event emitted when tokens are minted\r\n     */\r\n    event Mint(address minter, uint mintAmount, uint mintTokens);\r\n\r\n    /**\r\n     * @notice Event emitted when tokens are redeemed\r\n     */\r\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\r\n\r\n    /**\r\n     * @notice Event emitted when underlying is borrowed\r\n     */\r\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\r\n\r\n    /**\r\n     * @notice Event emitted when a borrow is repaid\r\n     */\r\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\r\n\r\n    /**\r\n     * @notice Event emitted when a borrow is liquidated\r\n     */\r\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);\r\n\r\n\r\n    /*** Admin Events ***/\r\n\r\n    /**\r\n     * @notice Event emitted when pendingAdmin is changed\r\n     */\r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n    /**\r\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\r\n     */\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n    /**\r\n     * @notice Event emitted when comptroller is changed\r\n     */\r\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\r\n\r\n    /**\r\n     * @notice Event emitted when interestRateModel is changed\r\n     */\r\n    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\r\n\r\n    /**\r\n     * @notice Event emitted when the reserve factor is changed\r\n     */\r\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\r\n\r\n    /**\r\n     * @notice Event emitted when the reserves are added\r\n     */\r\n    event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);\r\n\r\n    /**\r\n     * @notice Event emitted when the reserves are reduced\r\n     */\r\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\r\n\r\n    /**\r\n     * @notice EIP20 Transfer event\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint amount);\r\n\r\n    /**\r\n     * @notice EIP20 Approval event\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint amount);\r\n\r\n    /**\r\n     * @notice Failure event\r\n     */\r\n    // event Failure(uint error, uint info, uint detail);\r\n\r\n\r\n    /*** User Interface ***/\r\n\r\n    function transfer(address dst, uint amount) external returns (bool);\r\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function balanceOfUnderlying(address owner) external returns (uint);\r\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\r\n    function borrowRatePerBlock() external view returns (uint);\r\n    function supplyRatePerBlock() external view returns (uint);\r\n    function totalBorrowsCurrent() external returns (uint);\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function borrowBalanceStored(address account) public view returns (uint);\r\n    function exchangeRateCurrent() public returns (uint);\r\n    function exchangeRateStored() public view returns (uint);\r\n    function getCash() external view returns (uint);\r\n    function accrueInterest() public returns (uint);\r\n    function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint);\r\n\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\r\n    function _acceptAdmin() external returns (uint);\r\n    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint);\r\n    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);\r\n    function _reduceReserves(uint reduceAmount) external returns (uint);\r\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\r\n}\r\n\r\ncontract CErc20Storage {\r\n    /**\r\n     * @notice Underlying asset for this CToken\r\n     */\r\n    address public underlying;\r\n}\r\n\r\ncontract CErc20Interface is CErc20Storage {\r\n\r\n    /*** User Interface ***/\r\n\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function borrowLPMargin(address borrower, uint borrowAmount) external returns (uint);\r\n    function borrowSwapMargin(address borrower, uint borrowAmount) external returns (uint);\r\n    function repayBorrow(uint repayAmount) external returns (uint);\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\r\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) external returns (uint);\r\n\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    function _addReserves(uint addAmount) external returns (uint);\r\n}\r\n\r\ncontract CDelegationStorage {\r\n    /**\r\n     * @notice Implementation address for this contract\r\n     */\r\n    address public implementation;\r\n}\r\n\r\ncontract CDelegatorInterface is CDelegationStorage {\r\n    /**\r\n     * @notice Emitted when implementation is changed\r\n     */\r\n    event NewImplementation(address oldImplementation, address newImplementation);\r\n\r\n    /**\r\n     * @notice Called by the admin to update the implementation of the delegator\r\n     * @param implementation_ The address of the new implementation for delegation\r\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\r\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\r\n     */\r\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\r\n}\r\n\r\ncontract CDelegateInterface is CDelegationStorage {\r\n    /**\r\n     * @notice Called by the delegator on a delegate to initialize it for duty\r\n     * @dev Should revert if any issues arise which make it unfit for delegation\r\n     * @param data The encoded bytes data for any initialization\r\n     */\r\n    function _becomeImplementation(bytes memory data) public;\r\n\r\n    /**\r\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\r\n     */\r\n    function _resignImplementation() public;\r\n}\r\n"
    },
    "contracts/common/InterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\n/**\r\n  * @title LendHub's InterestRateModel Interface\r\n  * @author LendHub\r\n  */\r\ncontract InterestRateModel {\r\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\r\n    bool public constant isInterestRateModel = true;\r\n\r\n    /**\r\n      * @notice Calculates the current borrow interest rate per block\r\n      * @param cash The total amount of cash the market has\r\n      * @param borrows The total amount of borrows the market has outstanding\r\n      * @param reserves The total amount of reserves the market has\r\n      * @return The borrow rate per block (as a percentage, and scaled by 1e18)\r\n      */\r\n    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint);\r\n\r\n    /**\r\n      * @notice Calculates the current supply interest rate per block\r\n      * @param cash The total amount of cash the market has\r\n      * @param borrows The total amount of borrows the market has outstanding\r\n      * @param reserves The total amount of reserves the market has\r\n      * @param reserveFactorMantissa The current reserve factor the market has\r\n      * @return The supply rate per block (as a percentage, and scaled by 1e18)\r\n      */\r\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) external view returns (uint);\r\n\r\n}\r\n"
    },
    "contracts/compound/ErrorReporter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\ncontract ComptrollerErrorReporter {\r\n    enum Error {\r\n        NO_ERROR,\r\n        UNAUTHORIZED,\r\n        COMPTROLLER_MISMATCH,\r\n        INSUFFICIENT_SHORTFALL,\r\n        INSUFFICIENT_LIQUIDITY,\r\n        INVALID_CLOSE_FACTOR,\r\n        INVALID_COLLATERAL_FACTOR,\r\n        INVALID_LIQUIDATION_INCENTIVE,\r\n        MARKET_NOT_ENTERED, // no longer possible\r\n        MARKET_NOT_LISTED,\r\n        MARKET_ALREADY_LISTED,\r\n        MATH_ERROR,\r\n        NONZERO_BORROW_BALANCE,\r\n        PRICE_ERROR,\r\n        REJECTION,\r\n        SNAPSHOT_ERROR,\r\n        TOO_MANY_ASSETS,\r\n        TOO_MUCH_REPAY\r\n    }\r\n\r\n    enum FailureInfo {\r\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\r\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\r\n        EXIT_MARKET_BALANCE_OWED,\r\n        EXIT_MARKET_REJECTION,\r\n        SET_CLOSE_FACTOR_OWNER_CHECK,\r\n        SET_CLOSE_FACTOR_VALIDATION,\r\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\r\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\r\n        SET_COLLATERAL_FACTOR_VALIDATION,\r\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\r\n        SET_IMPLEMENTATION_OWNER_CHECK,\r\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\r\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\r\n        SET_MAX_ASSETS_OWNER_CHECK,\r\n        SET_PENDING_ADMIN_OWNER_CHECK,\r\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\r\n        SET_PRICE_ORACLE_OWNER_CHECK,\r\n        SUPPORT_MARKET_EXISTS,\r\n        SUPPORT_MARKET_OWNER_CHECK,\r\n        SET_PAUSE_GUARDIAN_OWNER_CHECK\r\n    }\r\n\r\n    /**\r\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\r\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\r\n      **/\r\n    event Failure(uint error, uint info, uint detail);\r\n\r\n    /**\r\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\r\n      */\r\n    function fail(Error err, FailureInfo info) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), 0);\r\n\r\n        return uint(err);\r\n    }\r\n\r\n    /**\r\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\r\n      */\r\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), opaqueError);\r\n\r\n        return uint(err);\r\n    }\r\n}\r\n\r\ncontract TokenErrorReporter {\r\n    enum Error {\r\n        NO_ERROR,\r\n        UNAUTHORIZED,\r\n        BAD_INPUT,\r\n        COMPTROLLER_REJECTION,\r\n        COMPTROLLER_CALCULATION_ERROR,\r\n        INTEREST_RATE_MODEL_ERROR,\r\n        INVALID_ACCOUNT_PAIR,\r\n        INVALID_CLOSE_AMOUNT_REQUESTED,\r\n        INVALID_COLLATERAL_FACTOR,\r\n        MATH_ERROR,\r\n        MARKET_NOT_FRESH,\r\n        MARKET_NOT_LISTED,\r\n        TOKEN_INSUFFICIENT_ALLOWANCE,\r\n        TOKEN_INSUFFICIENT_BALANCE,\r\n        TOKEN_INSUFFICIENT_CASH,\r\n        TOKEN_TRANSFER_IN_FAILED,\r\n        TOKEN_TRANSFER_OUT_FAILED\r\n    }\r\n\r\n    /*\r\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\r\n     *       This is because FailureInfo grows significantly faster, and\r\n     *       the order of Error has some meaning, while the order of FailureInfo\r\n     *       is entirely arbitrary.\r\n     */\r\n    enum FailureInfo {\r\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\r\n        ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\r\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        BORROW_ACCRUE_INTEREST_FAILED,\r\n        BORROW_CASH_NOT_AVAILABLE,\r\n        BORROW_FRESHNESS_CHECK,\r\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\r\n        BORROW_MARKET_NOT_LISTED,\r\n        BORROW_COMPTROLLER_REJECTION,\r\n        LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\r\n        LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\r\n        LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\r\n        LIQUIDATE_COMPTROLLER_REJECTION,\r\n        LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\r\n        LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\r\n        LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\r\n        LIQUIDATE_FRESHNESS_CHECK,\r\n        LIQUIDATE_LIQUIDATOR_IS_BORROWER,\r\n        LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\r\n        LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\r\n        LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\r\n        LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\r\n        LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\r\n        LIQUIDATE_SEIZE_TOO_MUCH,\r\n        MINT_ACCRUE_INTEREST_FAILED,\r\n        MINT_COMPTROLLER_REJECTION,\r\n        MINT_EXCHANGE_CALCULATION_FAILED,\r\n        MINT_EXCHANGE_RATE_READ_FAILED,\r\n        MINT_FRESHNESS_CHECK,\r\n        MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\r\n        MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\r\n        MINT_TRANSFER_IN_FAILED,\r\n        MINT_TRANSFER_IN_NOT_POSSIBLE,\r\n        REDEEM_ACCRUE_INTEREST_FAILED,\r\n        REDEEM_COMPTROLLER_REJECTION,\r\n        REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\r\n        REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\r\n        REDEEM_EXCHANGE_RATE_READ_FAILED,\r\n        REDEEM_FRESHNESS_CHECK,\r\n        REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\r\n        REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\r\n        REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\r\n        REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\r\n        REDUCE_RESERVES_ADMIN_CHECK,\r\n        REDUCE_RESERVES_CASH_NOT_AVAILABLE,\r\n        REDUCE_RESERVES_FRESH_CHECK,\r\n        REDUCE_RESERVES_VALIDATION,\r\n        REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\r\n        REPAY_BORROW_ACCRUE_INTEREST_FAILED,\r\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_COMPTROLLER_REJECTION,\r\n        REPAY_BORROW_FRESHNESS_CHECK,\r\n        REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\r\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\r\n        SET_COLLATERAL_FACTOR_VALIDATION,\r\n        SET_COMPTROLLER_OWNER_CHECK,\r\n        SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\r\n        SET_INTEREST_RATE_MODEL_FRESH_CHECK,\r\n        SET_INTEREST_RATE_MODEL_OWNER_CHECK,\r\n        SET_MAX_ASSETS_OWNER_CHECK,\r\n        SET_ORACLE_MARKET_NOT_LISTED,\r\n        SET_PENDING_ADMIN_OWNER_CHECK,\r\n        SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\r\n        SET_RESERVE_FACTOR_ADMIN_CHECK,\r\n        SET_RESERVE_FACTOR_FRESH_CHECK,\r\n        SET_RESERVE_FACTOR_BOUNDS_CHECK,\r\n        TRANSFER_COMPTROLLER_REJECTION,\r\n        TRANSFER_NOT_ALLOWED,\r\n        TRANSFER_NOT_ENOUGH,\r\n        TRANSFER_TOO_MUCH,\r\n        ADD_RESERVES_ACCRUE_INTEREST_FAILED,\r\n        ADD_RESERVES_FRESH_CHECK,\r\n        ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE\r\n    }\r\n\r\n    /**\r\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\r\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\r\n      **/\r\n    event Failure(uint error, uint info, uint detail);\r\n\r\n    /**\r\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\r\n      */\r\n    function fail(Error err, FailureInfo info) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), 0);\r\n\r\n        return uint(err);\r\n    }\r\n\r\n    /**\r\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\r\n      */\r\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), opaqueError);\r\n\r\n        return uint(err);\r\n    }\r\n}"
    },
    "contracts/compound/Exponential.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\nimport \"./CarefulMath.sol\";\r\nimport \"./ExponentialNoError.sol\";\r\n\r\n/**\r\n * @title Exponential module for storing fixed-precision decimals\r\n * @author LendHub\r\n * @dev Legacy contract for compatibility reasons with existing contracts that still use MathError\r\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\r\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\r\n *         `Exp({mantissa: 5100000000000000000})`.\r\n */\r\ncontract Exponential is CarefulMath, ExponentialNoError {\r\n    /**\r\n     * @dev Creates an exponential from numerator and denominator values.\r\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\r\n     *            or if `denom` is zero.\r\n     */\r\n    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\r\n        if (err1 != MathError.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two exponentials, returning a new exponential.\r\n     */\r\n    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two exponentials, returning a new exponential.\r\n     */\r\n    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\r\n     */\r\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\r\n     */\r\n    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, truncate(product));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\r\n     */\r\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return addUInt(truncate(product), addend);\r\n    }\r\n\r\n    /**\r\n     * @dev Divide an Exp by a scalar, returning a new Exp.\r\n     */\r\n    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\r\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\r\n    }\r\n\r\n    /**\r\n     * @dev Divide a scalar by an Exp, returning a new Exp.\r\n     */\r\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\r\n        /*\r\n          We are doing this as:\r\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\r\n\r\n          How it works:\r\n          Exp = a / b;\r\n          Scalar = s;\r\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\r\n        */\r\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n        return getExp(numerator, divisor.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\r\n     */\r\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\r\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, truncate(fraction));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two exponentials, returning a new exponential.\r\n     */\r\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n\r\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        // We add half the scale before dividing so that we get rounding instead of truncation.\r\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\r\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\r\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\r\n        if (err1 != MathError.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\r\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\r\n        assert(err2 == MathError.NO_ERROR);\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\r\n     */\r\n    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\r\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies three exponentials, returning a new exponential.\r\n     */\r\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\r\n        (MathError err, Exp memory ab) = mulExp(a, b);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, ab);\r\n        }\r\n        return mulExp(ab, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two exponentials, returning a new exponential.\r\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\r\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\r\n     */\r\n    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\r\n        return getExp(a.mantissa, b.mantissa);\r\n    }\r\n}\r\n"
    },
    "contracts/compound/EIP20Interface.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\n/**\r\n * @title ERC 20 Token Standard Interface\r\n *  https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface EIP20Interface {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n      * @notice Get the total number of tokens in circulation\r\n      * @return The supply of tokens\r\n      */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Gets the balance of the specified address\r\n     * @param owner The address from which the balance will be retrieved\r\n     * @return balance The balance\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n      * @param dst The address of the destination account\r\n      * @param amount The number of tokens to transfer\r\n      * @return success Whether or not the transfer succeeded\r\n      */\r\n    function transfer(address dst, uint256 amount) external returns (bool success);\r\n\r\n    /**\r\n      * @notice Transfer `amount` tokens from `src` to `dst`\r\n      * @param src The address of the source account\r\n      * @param dst The address of the destination account\r\n      * @param amount The number of tokens to transfer\r\n      * @return success Whether or not the transfer succeeded\r\n      */\r\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\r\n\r\n    /**\r\n      * @notice Approve `spender` to transfer up to `amount` from `src`\r\n      * @dev This will overwrite the approval amount for `spender`\r\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\r\n      * @param spender The address of the account which may transfer tokens\r\n      * @param amount The number of tokens that are approved (-1 means infinite)\r\n      * @return success Whether or not the approval succeeded\r\n      */\r\n    function approve(address spender, uint256 amount) external returns (bool success);\r\n\r\n    /**\r\n      * @notice Get the current allowance from `owner` for `spender`\r\n      * @param owner The address of the account which owns the tokens to be spent\r\n      * @param spender The address of the account which may transfer tokens\r\n      * @return remaining The number of tokens allowed to be spent (-1 means infinite)\r\n      */\r\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n}\r\n"
    },
    "contracts/compound/EIP20NonStandardInterface.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\n/**\r\n * @title EIP20NonStandardInterface\r\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\r\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n */\r\ninterface EIP20NonStandardInterface {\r\n\r\n    /**\r\n     * @notice Get the total number of tokens in circulation\r\n     * @return The supply of tokens\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Gets the balance of the specified address\r\n     * @param owner The address from which the balance will be retrieved\r\n     * @return balance The balance\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    ///\r\n    /// !!!!!!!!!!!!!!\r\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\r\n    /// !!!!!!!!!!!!!!\r\n    ///\r\n\r\n    /**\r\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n      * @param dst The address of the destination account\r\n      * @param amount The number of tokens to transfer\r\n      */\r\n    function transfer(address dst, uint256 amount) external;\r\n\r\n    ///\r\n    /// !!!!!!!!!!!!!!\r\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\r\n    /// !!!!!!!!!!!!!!\r\n    ///\r\n\r\n    /**\r\n      * @notice Transfer `amount` tokens from `src` to `dst`\r\n      * @param src The address of the source account\r\n      * @param dst The address of the destination account\r\n      * @param amount The number of tokens to transfer\r\n      */\r\n    function transferFrom(address src, address dst, uint256 amount) external;\r\n\r\n    /**\r\n      * @notice Approve `spender` to transfer up to `amount` from `src`\r\n      * @dev This will overwrite the approval amount for `spender`\r\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\r\n      * @param spender The address of the account which may transfer tokens\r\n      * @param amount The number of tokens that are approved\r\n      * @return success Whether or not the approval succeeded\r\n      */\r\n    function approve(address spender, uint256 amount) external returns (bool success);\r\n\r\n    /**\r\n      * @notice Get the current allowance from `owner` for `spender`\r\n      * @param owner The address of the account which owns the tokens to be spent\r\n      * @param spender The address of the account which may transfer tokens\r\n      * @return remaining The number of tokens allowed to be spent\r\n      */\r\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n}\r\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/compound/CarefulMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\n/**\r\n  * @title Careful Math\r\n  * @author LendHub\r\n  * @notice Derived from OpenZeppelin's SafeMath library\r\n  *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n  */\r\ncontract CarefulMath {\r\n\r\n    /**\r\n     * @dev Possible error codes that we can return\r\n     */\r\n    enum MathError {\r\n        NO_ERROR,\r\n        DIVISION_BY_ZERO,\r\n        INTEGER_OVERFLOW,\r\n        INTEGER_UNDERFLOW\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, returns an error on overflow.\r\n    */\r\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (a == 0) {\r\n            return (MathError.NO_ERROR, 0);\r\n        }\r\n\r\n        uint c = a * b;\r\n\r\n        if (c / a != b) {\r\n            return (MathError.INTEGER_OVERFLOW, 0);\r\n        } else {\r\n            return (MathError.NO_ERROR, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (b == 0) {\r\n            return (MathError.DIVISION_BY_ZERO, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, a / b);\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (b <= a) {\r\n            return (MathError.NO_ERROR, a - b);\r\n        } else {\r\n            return (MathError.INTEGER_UNDERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, returns an error on overflow.\r\n    */\r\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        uint c = a + b;\r\n\r\n        if (c >= a) {\r\n            return (MathError.NO_ERROR, c);\r\n        } else {\r\n            return (MathError.INTEGER_OVERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev add a and b and then subtract c\r\n    */\r\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\r\n        (MathError err0, uint sum) = addUInt(a, b);\r\n\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, 0);\r\n        }\r\n\r\n        return subUInt(sum, c);\r\n    }\r\n}"
    },
    "contracts/compound/ExponentialNoError.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\n/**\r\n * @title Exponential module for storing fixed-precision decimals\r\n * @author LendHub\r\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\r\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\r\n *         `Exp({mantissa: 5100000000000000000})`.\r\n */\r\ncontract ExponentialNoError {\r\n    uint constant expScale = 1e18;\r\n    uint constant doubleScale = 1e36;\r\n    uint constant halfExpScale = expScale/2;\r\n    uint constant mantissaOne = expScale;\r\n\r\n    struct Exp {\r\n        uint mantissa;\r\n    }\r\n\r\n    struct Double {\r\n        uint mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Truncates the given exp to a whole number value.\r\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\r\n     */\r\n    function truncate(Exp memory exp) pure internal returns (uint) {\r\n        // Note: We are not using careful math here as we're performing a division that cannot fail\r\n        return exp.mantissa / expScale;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\r\n     */\r\n    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\r\n        Exp memory product = mul_(a, scalar);\r\n        return truncate(product);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\r\n     */\r\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\r\n        Exp memory product = mul_(a, scalar);\r\n        return add_(truncate(product), addend);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if first Exp is less than second Exp.\r\n     */\r\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa < right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if left Exp <= right Exp.\r\n     */\r\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa <= right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if left Exp > right Exp.\r\n     */\r\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa > right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev returns true if Exp is exactly zero\r\n     */\r\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\r\n        return value.mantissa == 0;\r\n    }\r\n\r\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\r\n        require(n < 2**224, errorMessage);\r\n        return uint224(n);\r\n    }\r\n\r\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\r\n        require(n < 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function add_(uint a, uint b) pure internal returns (uint) {\r\n        return add_(a, b, \"addition overflow\");\r\n    }\r\n\r\n    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function sub_(uint a, uint b) pure internal returns (uint) {\r\n        return sub_(a, b, \"subtraction underflow\");\r\n    }\r\n\r\n    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\r\n    }\r\n\r\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: mul_(a.mantissa, b)});\r\n    }\r\n\r\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\r\n        return mul_(a, b.mantissa) / expScale;\r\n    }\r\n\r\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\r\n    }\r\n\r\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: mul_(a.mantissa, b)});\r\n    }\r\n\r\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\r\n        return mul_(a, b.mantissa) / doubleScale;\r\n    }\r\n\r\n    function mul_(uint a, uint b) pure internal returns (uint) {\r\n        return mul_(a, b, \"multiplication overflow\");\r\n    }\r\n\r\n    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        if (a == 0 || b == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        require(c / a == b, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\r\n    }\r\n\r\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: div_(a.mantissa, b)});\r\n    }\r\n\r\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\r\n        return div_(mul_(a, expScale), b.mantissa);\r\n    }\r\n\r\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\r\n    }\r\n\r\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(a.mantissa, b)});\r\n    }\r\n\r\n    function div_(uint a, Double memory b) pure internal returns (uint) {\r\n        return div_(mul_(a, doubleScale), b.mantissa);\r\n    }\r\n\r\n    function div_(uint a, uint b) pure internal returns (uint) {\r\n        return div_(a, b, \"divide by zero\");\r\n    }\r\n\r\n    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\r\n    }\r\n}\r\n"
    },
    "contracts/swap/heco/Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity ^0.5.16;\r\n\r\nimport \"../library/SafeMath.sol\";\r\n\r\nimport \"../interface/IERC20.sol\";\r\nimport \"../interface/IDeBankFactory.sol\";\r\nimport \"../interface/IDeBankPair.sol\";\r\nimport \"../interface/IDeBankRouter.sol\";\r\n// todo\r\nimport \"../../compound/CToken.sol\";\r\n\r\nimport \"./PairStorage.sol\";\r\n\r\n// import \"hardhat/console.sol\";\r\n\r\ninterface IUnitroller {\r\n    function compAccrued(address addr) external view returns (uint);\r\n    function claimComp(address holder, CToken[] calldata cTokens) external;\r\n}\r\n\r\ninterface IHswapV2Callee {\r\n    function hswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\r\n}\r\n\r\nlibrary UQ112x112 {\r\n    uint224 constant private _Q112 = 2 ** 112;\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 y) internal pure returns (uint224 z) {\r\n        z = uint224(y) * _Q112;\r\n        // never overflows\r\n    }\r\n\r\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\r\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\r\n        z = x / uint224(y);\r\n    }\r\n}\r\n\r\n// stable & uniwap pair\r\ncontract DeBankPair is IDeBankPair, PairStorage {\r\n    using SafeMath  for uint;\r\n    using UQ112x112 for uint224;\r\n\r\n    constructor() public {\r\n        uint chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes('1')),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n        factory = msg.sender;\r\n    }\r\n    \r\n    // 更新上一块的手续费分成\r\n    // 更新本块的手续费总和\r\n    function _updateBlockFee(uint fee) private {\r\n        // console.log(\"_updateBlockFee: current block=%d fee=%d block.number=%d\", currentBlock, fee, block.number);\r\n        if (currentBlock == block.number) {\r\n            blockFee = blockFee.add(fee);\r\n            return;\r\n        }\r\n\r\n        // 计算之前块的手续费分成\r\n        if (blockFee > 0) {\r\n            if (currentBlock == block.number - 1) {\r\n                // 计算上一个块的奖励\r\n                IDeBankRouter router = IDeBankRouter(IDeBankFactory(factory).router());\r\n                uint denominator = router.allPairFeeLastBlock();    // 上一个块所有交易对的手续费\r\n                uint reward = router.reward(currentBlock);\r\n                if (totalSupply > 0) {\r\n                    uint share = reward.mul(blockFee).div(denominator);\r\n                    accPerShare = accPerShare.add(share.div(totalSupply));   // 需要有一个乘数, 否则归 0\r\n                }\r\n                // rewards += ;\r\n            } else {\r\n                // 中间有若干个块没有交易的情况 将 本交易对之前的块手续费算在 上一个的所有交易对手续费之和 里\r\n                // 距离上一次交易的块越远, 收益越低\r\n                // uint multor = 1 + (block.number - currentBlock) / 100;\r\n                blockFee = fee + blockFee.mul(currentBlock).div(block.number); // / multor;\r\n                currentBlock = block.number;\r\n                return;\r\n            }\r\n        }\r\n        // 重新累计这个块的手续费\r\n        currentBlock = block.number;\r\n        blockFee = fee;\r\n    }\r\n    \r\n    function _updateRewardShare() internal {\r\n        _updateBlockFee(0);\r\n\r\n        // if (totalSupply > 0) {\r\n        //   accPerShare = rewards / totalSupply;\r\n        // }\r\n    }\r\n\r\n    // 更新 mintAccPerShare\r\n    function _updateCtokenMintPerShare() internal {\r\n        if (ctokenRewordBlock == block.number) {\r\n            return;\r\n        }\r\n        // console.log(\"before _lhbTotalBlance\");\r\n        uint curr = _lhbTotalBlance();\r\n        // console.log(\"curr=%d\", curr, ctokenMintRewards);\r\n        if (curr > ctokenMintRewards) {\r\n            uint per = curr.sub(ctokenMintRewards);\r\n            if (totalSupply > 0) {\r\n                mintAccPerShare = mintAccPerShare.add(per.div(totalSupply));\r\n            }\r\n        }\r\n        ctokenMintRewards = curr;\r\n        ctokenRewordBlock = block.number;\r\n        // console.log(\"_updateCtokenMintPerShare done\");\r\n    }\r\n\r\n    function _mint(address to, uint value) internal {\r\n        // if (to == address(0)) {\r\n        //     return;\r\n        // }\r\n        \r\n        _updateRewardShare();\r\n        // console.log(\"update reward share done\");\r\n        // ctoken 挖矿, 负债, 在 totalSupply 增加之前更新\r\n        _updateCtokenMintPerShare();\r\n        // console.log(\"update ctoken mint share done\");\r\n\r\n        LPReward storage lpReward = mintRewardOf[to];\r\n        uint amt = lpReward.amount;\r\n        uint perShare = accPerShare.add(mintAccPerShare);\r\n        if (amt == 0) {\r\n            lpReward.amount = value;\r\n            lpReward.rewardDebt = value.mul(perShare);\r\n        } else {\r\n            lpReward.pendingReward += amt.mul(perShare);\r\n            lpReward.amount += value;\r\n            lpReward.rewardDebt = amt.mul(perShare);\r\n        }\r\n        // console.log(\"_mint %s LPReward.amount:\", to, lpReward.amount);\r\n\r\n        // 记录 owner 只有 owner 可以提取流动性\r\n        totalSupply = totalSupply.add(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        // mintOf[to] = mintOf[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    // 挖矿收益转账给用户\r\n    function _transferMintReword(address rewardToken, address to, uint reward) private {\r\n        uint total = _lhbBalance();\r\n        if (total < reward) {\r\n            _claimPairComp();\r\n            total = _lhbBalance();\r\n            if (total < reward) {\r\n                // should not reach here\r\n                mintRewardDebt = mintRewardDebt.add(reward).sub(total); // 记录不够的数量\r\n                reward = total;\r\n                // return;\r\n            }\r\n        }\r\n\r\n        if (reward > 0) {\r\n            _safeTransfer(rewardToken, to, reward);\r\n        }\r\n    }\r\n\r\n    /// @dev 计算用户的挖矿收益, 已有的挖矿收益转给用户, 重新设置用户的负债\r\n    /// @param from 用户地址\r\n    /// @param value 用户 LP 数量增加或减少的数量\r\n    /// @param inc 增加: true; 减少: false\r\n    function _updateUserMintReward(address from, uint value, bool inc) internal {\r\n        // 记录 owner 只有 owner 可以提取流动性\r\n        LPReward storage lpReward = mintRewardOf[from];\r\n        uint perShare = accPerShare + mintAccPerShare;\r\n        // require(lpReward.amount >= value, \"Not enough\");\r\n        // perShare * lpReward.amount + lpReward.pendingReward - lpReward.rewardDebt;\r\n        uint amt = lpReward.amount;\r\n        if (amt > 0) {\r\n            uint reward = perShare.mul(amt).add(lpReward.pendingReward).sub(lpReward.rewardDebt);\r\n            if (reward > 0) {\r\n                // todo transfer\r\n                // console.log(\"reward: from=%s amt=%d reward=%d\", from, amt, reward);\r\n                address rewardToken = IDeBankRouter(IDeBankFactory(factory).router()).rewardToken();\r\n                if (rewardToken != address(0)) {\r\n                    _transferMintReword(rewardToken, from, reward);\r\n                }\r\n            }\r\n        }\r\n        // console.log(\"_updateUserMintReward: from=%s amt=%d value=%d\", from, amt, value);\r\n        uint newVal = inc ? amt.add(value) : amt.sub(value);\r\n        lpReward.amount = newVal;\r\n        lpReward.pendingReward = 0;\r\n        lpReward.rewardDebt = perShare.mul(newVal);\r\n    }\r\n\r\n    function _burn(address from, uint value) internal {\r\n        // console.log(\"balanceOf[from]=%d value=%d totalSupply=%d\", balanceOf[from], value, totalSupply);\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        _updateUserMintReward(from, value, false);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint value) private {\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    // 获取 LP 抵押合约地址\r\n    function _getLPDepositAddr() private view returns (address) {\r\n        return IDeBankRouter(IDeBankFactory(factory).router()).lpDepositAddr();\r\n    }\r\n\r\n    function _transfer(address from, address to, uint value) private {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        // 更改挖矿权\r\n        address addr = _getLPDepositAddr();\r\n        if (from != addr && to != addr) {\r\n            _updateRewardShare();\r\n            // ctoken 挖矿, 负债, 在 totalSupply 减少之前更新\r\n            _updateCtokenMintPerShare();\r\n            _updateUserMintReward(from, value, false);\r\n            _updateUserMintReward(to, value, true);\r\n\r\n            // mintOf[from] = mintOf[from].sub(value);\r\n            // mintOf[to] = mintOf[to].add(value);\r\n        }\r\n        // 计算已有的挖矿收益 重新计算 reward debt\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    // function ownerAmountOf(address owner) external view returns (uint) {\r\n    //     LPReward memory reward = ownerOf[owner];\r\n    //     return reward.amount;\r\n    // }\r\n\r\n    function approve(address spender, uint value) external returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint value) external returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool) {\r\n        if (allowance[from][msg.sender] != uint(- 1)) {\r\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline,\r\n                    uint8 v, bytes32 r, bytes32 s) external {\r\n      // solhint-disable-next-line\r\n        require(deadline >= block.timestamp, 'Swap: EXPIRED');\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\r\n            )\r\n        );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'Swap: INVALID_SIGNATURE');\r\n        _approve(owner, spender, value);\r\n    }\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(_SELECTOR, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Swap: TRANSFER_FAILED');\r\n    }\r\n\r\n    ////////////////////////////\r\n    \r\n    // called once by the factory at time of deployment\r\n    function initialize(address _token0, address _token1, address _ctoken0, address _ctoken1) external {\r\n        require(msg.sender == factory, 'DeBankSwap: FORBIDDEN');\r\n        // sufficient check\r\n        token0 = _token0;\r\n        token1 = _token1;\r\n        cToken0 = _ctoken0;\r\n        cToken1 = _ctoken1;\r\n\r\n        lpFeeRate = IDeBankFactory(factory).lpFeeRate();\r\n    }\r\n\r\n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\r\n        _reserve0 = reserve0;\r\n        _reserve1 = reserve1;\r\n        _blockTimestampLast = blockTimestampLast;\r\n    }\r\n\r\n    // update reserves and, on the first call per block, price accumulators\r\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\r\n        require(balance0 <= uint112(- 1) && balance1 <= uint112(- 1), 'DeBankSwap: OVERFLOW');\r\n        // solhint-disable-next-line\r\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\r\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast;\r\n        // overflow is desired\r\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\r\n            // * never overflows, and + overflow is desired\r\n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\r\n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\r\n        }\r\n        reserve0 = uint112(balance0);\r\n        reserve1 = uint112(balance1);\r\n        blockTimestampLast = blockTimestamp;\r\n        emit Sync(reserve0, reserve1);\r\n    }\r\n\r\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\r\n    // 设置了 feeTo 时, 才收取手续费\r\n    // mdex 这里的 lpFeeRate 设置的是 0, 因此, 所有的手续费都被mdex平台收走\r\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\r\n        address feeTo = IDeBankFactory(factory).feeTo();\r\n        // console.log(\"feeTo:\", feeTo);\r\n        feeOn = feeTo != address(0);\r\n        uint _kLast = kLast;\r\n        // gas savings\r\n        if (feeOn) {\r\n            if (_kLast != 0) {\r\n                uint rootK = SafeMath.sqrt(uint(_reserve0).mul(_reserve1));\r\n                uint rootKLast = SafeMath.sqrt(_kLast);\r\n                if (rootK > rootKLast) {\r\n                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));\r\n                    uint denominator = rootK.mul(lpFeeRate).add(rootKLast);\r\n                    uint liquidity = numerator / denominator;\r\n                    if (liquidity > 0) _mint(feeTo, liquidity);\r\n                }\r\n            }\r\n        } else if (_kLast != 0) {\r\n            kLast = 0;\r\n        }\r\n    }\r\n\r\n\r\n    function _lhbBalance() internal view returns (uint) {\r\n        address lhb = IDeBankRouter(IDeBankFactory(factory).router()).rewardToken();        // 从 factory/router 中获取\r\n\r\n        return IERC20(lhb).balanceOf(address(this));\r\n    }\r\n\r\n    // pair 的两个 ctoken 得到的 ctoken 存币挖矿收益\r\n    function _lhbTotalBlance() internal view returns (uint) {\r\n        address lhb = IDeBankRouter(IDeBankFactory(factory).router()).rewardToken();        // 从 factory/router 中获取\r\n        if (lhb == address(0)) {\r\n            return 0;\r\n        }\r\n        address unitroller = IDeBankRouter(IDeBankFactory(factory).router()).compAddr();    // 从 factory/router 中获取\r\n\r\n        // 有部分币存在 compAccrued 中，没有转出来\r\n        return IERC20(lhb).balanceOf(address(this)) + IUnitroller(unitroller).compAccrued(address(this));\r\n    }\r\n\r\n\r\n    // ETH/HT/BNB 不能直接 mint\r\n    // 2021/5/25: 存入的是 ctoken 而不是 token; 如果要存入 token, 在外围合约中实现(先转换为ctoken, 再调用此方法)\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function mint(address to) external lock returns (uint liquidity) {\r\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves();\r\n        // gas savings\r\n        uint balance0 = IERC20(cToken0).balanceOf(address(this));\r\n        uint balance1 = IERC20(cToken1).balanceOf(address(this));\r\n        uint amount0 = balance0.sub(_reserve0);\r\n        uint amount1 = balance1.sub(_reserve1);\r\n\r\n        // console.log(cToken0, cToken1);\r\n        // console.log(balance0, balance1, _reserve0, _reserve1);\r\n\r\n        bool feeOn = _mintFee(_reserve0, _reserve1);\r\n        uint _totalSupply = totalSupply;\r\n        // gas savings, must be defined here since totalSupply can update in _mintFee\r\n        if (_totalSupply == 0) {\r\n            liquidity = SafeMath.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\r\n            _mint(address(0), MINIMUM_LIQUIDITY);\r\n            // permanently lock the first MINIMUM_LIQUIDITY tokens\r\n        } else {\r\n            liquidity = SafeMath.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\r\n        }\r\n\r\n\r\n        require(liquidity > 0, 'DeBankSwap: INSUFFICIENT_LIQUIDITY_MINTED');\r\n        _mint(to, liquidity);\r\n\r\n        _update(balance0, balance1, _reserve0, _reserve1);\r\n        if (feeOn) kLast = uint(reserve0).mul(reserve1);\r\n\r\n        // ctokenMintDebt[to] = liquidity.mul(mintAccPerShare); // .div(totalSupply);\r\n\r\n        // reserve0 and reserve1 are up-to-date\r\n        emit Mint(msg.sender, amount0, amount1);\r\n    }\r\n\r\n    // 领取交易对两个 ctoken 的存币挖矿收益\r\n    function _claimPairComp() private {\r\n        address unitroller = IDeBankRouter(IDeBankFactory(factory).router()).compAddr();    // 从 factory/router 中获取\r\n        CToken[] memory cTokens = new CToken[](2); // memory cTokens\r\n\r\n        cTokens[0] = CToken(cToken0);\r\n        cTokens[1] = CToken(cToken1);\r\n        IUnitroller(unitroller).claimComp(address(this), cTokens);\r\n    }\r\n\r\n    // 用户移除流动性时， 将 ctoken 存币挖矿收益转给用户\r\n    // function _transferCtokenMint(address from, address to, uint liquidity) internal {\r\n    //     address lhb = IDeBankRouter(IDeBankFactory(factory).router()).rewardToken();        // 从 factory/router 中获取\r\n\r\n    //     // unitroller.claimComp(address(this), cTokens);\r\n    //     uint amt = liquidity.mul(mintAccPerShare).sub(ctokenMintDebt[to]);\r\n    //     if (amt > _lhbBalance()) {\r\n    //         // 不够发的情况, 把所有的存币收益提取出来\r\n    //         _claimPairComp();\r\n    //     }\r\n\r\n    //     IERC20(lhb).transfer(to, amt);\r\n    //     // update curr\r\n        \r\n    //     // 更新 pair 的挖矿奖励\r\n    //     ctokenMintRewards = ctokenMintRewards.sub(amt); // _lhbTotalBlance();\r\n\r\n    //     // 这种情况属于清算了用户的LP, 因此需要移除用户的挖矿权\r\n    //     if (from == _getLPDepositAddr()) {\r\n    //         mintOf[to] = mintOf[to].sub(liquidity);\r\n    //     } else {\r\n    //         mintOf[from] = \r\n    //     }\r\n    // }\r\n\r\n    // function lpDepositBurn(address owner) external lock returns (uint amount0, uint amount1) {\r\n    //     // LP 抵押需要使用专门的方法\r\n    //     address lpDepositAddr;\r\n    //     require(msg.sender == lpDepositAddr, \"LP burn\");\r\n\r\n    // }\r\n\r\n    // 操作的是 ctoken 2021/05/25\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function burn(address to) external lock returns (uint amount0, uint amount1) {\r\n        // LP 抵押需要使用专门的方法\r\n        // address lpDepositAddr;\r\n        // require(msg.sender != lpDepositAddr, \"burn\");\r\n        // console.log(\"burn start\");\r\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves();\r\n        // gas savings\r\n        address _token0 = cToken0;\r\n        // gas savings\r\n        address _token1 = cToken1;\r\n        // gas savings\r\n        uint balance0 = IERC20(_token0).balanceOf(address(this));\r\n        uint balance1 = IERC20(_token1).balanceOf(address(this));\r\n        uint liquidity = balanceOf[address(this)];\r\n        // 只有 ctoken0 ctoken1 和 owner 可以 burn\r\n        // if (to != _token0 && to != _token1 && to != IDeBankFactory(factory).router()) {\r\n        //     require(ownerOf[to].amount >= liquidity, \"only owner can burn\");\r\n        // }\r\n\r\n        bool feeOn = _mintFee(_reserve0, _reserve1);\r\n        uint _totalSupply = totalSupply;\r\n        // gas savings, must be defined here since totalSupply can update in _mintFee\r\n        amount0 = liquidity.mul(balance0) / _totalSupply;\r\n        // using balances ensures pro-rata distribution\r\n        amount1 = liquidity.mul(balance1) / _totalSupply;\r\n        // using balances ensures pro-rata distribution\r\n        require(amount0 > 0 && amount1 > 0, 'DeBankSwap: INSUFFICIENT_LIQUIDITY_BURNED');\r\n\r\n        // console.log(\"after _mintFee:\", amount0, amount1);\r\n\r\n        _updateRewardShare();\r\n        // ctoken 挖矿, 负债, 在 totalSupply 减少之前更新\r\n        _updateCtokenMintPerShare();\r\n\r\n        // console.log(\"before _burn\");\r\n\r\n        _burn(address(this), liquidity);\r\n        _safeTransfer(_token0, to, amount0);\r\n        _safeTransfer(_token1, to, amount1);\r\n\r\n        // ctoken transfer 之后， 挖矿的收益在 comptroller 中已经更新\r\n        // 这里把 LP 这段时间的挖矿收益转给用户\r\n        // 2021-07-14 burn 之前需要把流动性转给 pair, transfer 时已经更改了挖矿所有权, _burn 中销毁了 pair 的挖矿所有权\r\n        // _updateUserMintReward(to, liquidity, false);\r\n        // _transferCtokenMint(msg.sender, to, liquidity);\r\n\r\n        balance0 = IERC20(_token0).balanceOf(address(this));\r\n        balance1 = IERC20(_token1).balanceOf(address(this));\r\n\r\n        _update(balance0, balance1, _reserve0, _reserve1);\r\n        if (feeOn) kLast = uint(reserve0).mul(reserve1);\r\n        // reserve0 and reserve1 are up-to-date\r\n        emit Burn(msg.sender, amount0, amount1, to);\r\n    }\r\n\r\n    // 只允许 router 调用, fee 已经在外部扣除\r\n    function swapNoFee(uint amount0Out, uint amount1Out, address to, uint fee) external lock {\r\n        require(msg.sender == IDeBankFactory(factory).router(), \"DeBankSwap: router only\");\r\n        if (fee > 0) {\r\n            _updateBlockFee(fee);\r\n        }\r\n\r\n        require(amount0Out > 0 || amount1Out > 0, 'DeBankSwap: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves();\r\n        // gas savings\r\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'DeBankSwap: INSUFFICIENT_LIQUIDITY');\r\n\r\n        uint balance0;\r\n        uint balance1;\r\n        {// scope for _token{0,1}, avoids stack too deep errors\r\n            address _token0 = cToken0;\r\n            address _token1 = cToken1;\r\n            require(to != _token0 && to != _token1, 'DeBankSwap: INVALID_TO');\r\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out);\r\n            // optimistically transfer tokens\r\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out);\r\n            // optimistically transfer tokens\r\n            // if (data.length > 0) IHswapV2Callee(to).hswapV2Call(msg.sender, amount0Out, amount1Out, data);\r\n            balance0 = IERC20(_token0).balanceOf(address(this));\r\n            balance1 = IERC20(_token1).balanceOf(address(this));\r\n        }\r\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\r\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\r\n\r\n        require(amount0In > 0 || amount1In > 0, 'DeBankSwap: INSUFFICIENT_INPUT_AMOUNT');\r\n        // 因为手续费已经在外部收走, 这里只需要 x'*y'>=x*y\r\n        require(balance0.mul(balance1) >= uint(_reserve0).mul(_reserve1), 'DeBankSwap: K2');\r\n\r\n        _update(balance0, balance1, _reserve0, _reserve1);\r\n\r\n        // 更新挖矿收益\r\n        // _updateCtokenMintPerShare();\r\n\r\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {\r\n        require(amount0Out > 0 || amount1Out > 0, 'DeBankSwap: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves();\r\n        // gas savings\r\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'DeBankSwap: INSUFFICIENT_LIQUIDITY');\r\n\r\n        uint balance0;\r\n        uint balance1;\r\n        {// scope for _token{0,1}, avoids stack too deep errors\r\n            address _token0 = cToken0;\r\n            address _token1 = cToken1;\r\n            require(to != _token0 && to != _token1, 'DeBankSwap: INVALID_TO');\r\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out);\r\n            // optimistically transfer tokens\r\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out);\r\n            // optimistically transfer tokens\r\n            if (data.length > 0) IHswapV2Callee(to).hswapV2Call(msg.sender, amount0Out, amount1Out, data);\r\n            balance0 = IERC20(_token0).balanceOf(address(this));\r\n            balance1 = IERC20(_token1).balanceOf(address(this));\r\n        }\r\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\r\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\r\n        require(amount0In > 0 || amount1In > 0, 'DeBankSwap: INSUFFICIENT_INPUT_AMOUNT');\r\n        {// scope for reserve{0,1}Adjusted, avoids stack too deep errors\r\n            uint balance0Adjusted = balance0.mul(10000).sub(amount0In.mul(feeRate));\r\n            uint balance1Adjusted = balance1.mul(10000).sub(amount1In.mul(feeRate));\r\n            // console.log(\"amount0In: %d amount1In: %d\", amount0In, amount1In);\r\n            // console.log(\"balanceAdjusted: %d  %d\", balance0Adjusted, balance1Adjusted);\r\n            require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(10000 ** 2), 'DeBankSwap: K1');\r\n        }\r\n\r\n        _update(balance0, balance1, _reserve0, _reserve1);\r\n        \r\n        // 更新挖矿收益\r\n        // _updateCtokenMintPerShare(_lhbTotalBlance());\r\n\r\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\r\n    }\r\n\r\n    function getFee(uint256 amt) public view returns (uint256) {\r\n        return amt.mul(feeRate).div(10000);\r\n    }\r\n\r\n    // x * y = x' * y'   令 x' = x + a; y' = y - b\r\n    // x * y = (x+a) * y'\r\n    // y' = (x*y) / (x+a)\r\n    // b = y - y' = y - (x*y) / (x+a) = a*y/(x+a)\r\n    // b = a*y/(x+a)\r\n    // function _swapWithOutFee(uint256 a, uint256 r0, uint256 r1) private pure returns (uint256) {\r\n    //     return (a * r1) / (a + r0);\r\n    // }\r\n\r\n    // force balances to match reserves\r\n    function skim(address to) external lock {\r\n        address _token0 = cToken0;\r\n        // gas savings\r\n        address _token1 = cToken1;\r\n        // gas savings\r\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\r\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\r\n    }\r\n\r\n    // force reserves to match balances\r\n    function sync() external lock {\r\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\r\n    }\r\n\r\n    function price(address token, uint256 baseDecimal) public view returns (uint256) {\r\n        if ((cToken0 != token && cToken1 != token) || 0 == reserve0 || 0 == reserve1) {\r\n            return 0;\r\n        }\r\n        if (cToken0 == token) {\r\n            return uint256(reserve1).mul(baseDecimal).div(uint256(reserve0));\r\n        } else {\r\n            return uint256(reserve0).mul(baseDecimal).div(uint256(reserve1));\r\n        }\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////// Admin //////////////////////////////////////////////////////////\r\n    // 更新 lpFeeRate 只有 factory 可以更新 lpFeeRate\r\n    function updateLPFeeRate(uint256 _feeRate) external {\r\n        require(msg.sender == factory, 'DeBankSwap: FORBIDDEN');\r\n        lpFeeRate = _feeRate;\r\n    }\r\n\r\n    // 手续费比例\r\n    function updateFeeRate(uint256 _feeRate) external {\r\n        require(msg.sender == factory, 'DeBankSwap: FORBIDDEN');\r\n        require(_feeRate <= 200, \"feeRate too high\");  // 最高不超过 2%\r\n        feeRate = _feeRate;\r\n    }\r\n}\r\n"
    },
    "contracts/swap/library/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity >=0.5.16;\r\n\r\nlibrary SafeMath {\r\n    uint256 constant WAD = 10 ** 18;\r\n    uint256 constant RAY = 10 ** 27;\r\n\r\n    function wad() public pure returns (uint256) {\r\n        return WAD;\r\n    }\r\n\r\n    function ray() public pure returns (uint256) {\r\n        return RAY;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a <= b ? a : b;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function sqrt(uint256 a) internal pure returns (uint256 b) {\r\n        if (a > 3) {\r\n            b = a;\r\n            uint256 x = a / 2 + 1;\r\n            while (x < b) {\r\n                b = x;\r\n                x = (a / x + x) / 2;\r\n            }\r\n        } else if (a != 0) {\r\n            b = 1;\r\n        }\r\n    }\r\n\r\n    function wmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mul(a, b) / WAD;\r\n    }\r\n\r\n    function wmulRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, b), WAD / 2) / WAD;\r\n    }\r\n\r\n    function rmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mul(a, b) / RAY;\r\n    }\r\n\r\n    function rmulRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, b), RAY / 2) / RAY;\r\n    }\r\n\r\n    function wdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(mul(a, WAD), b);\r\n    }\r\n\r\n    function wdivRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, WAD), b / 2) / b;\r\n    }\r\n\r\n    function rdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(mul(a, RAY), b);\r\n    }\r\n\r\n    function rdivRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, RAY), b / 2) / b;\r\n    }\r\n\r\n    function wpow(uint256 x, uint256 n) internal pure returns (uint256) {\r\n        uint256 result = WAD;\r\n        while (n > 0) {\r\n            if (n % 2 != 0) {\r\n                result = wmul(result, x);\r\n            }\r\n            x = wmul(x, x);\r\n            n /= 2;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256) {\r\n        uint256 result = RAY;\r\n        while (n > 0) {\r\n            if (n % 2 != 0) {\r\n                result = rmul(result, x);\r\n            }\r\n            x = rmul(x, x);\r\n            n /= 2;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n"
    },
    "contracts/swap/interface/IERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity ^0.5.16;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n"
    },
    "contracts/swap/interface/IDeBankFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity ^0.5.16;\r\n\r\nimport \"./LErc20DelegatorInterface.sol\";\r\n\r\ninterface IDeBankFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function router() external view returns (address);\r\n\r\n    // function feeToSetter() external view returns (address);\r\n\r\n    function lpFeeRate() external view returns (uint256);\r\n\r\n    // function lErc20DelegatorFactory() external view returns (LErc20DelegatorInterface);\r\n\r\n    function anchorToken() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function allPairs(uint) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB, address ctoken0, address ctoken1) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    // function setFeeToSetter(address) external;\r\n\r\n    function setFeeToRate(uint256) external;\r\n\r\n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, address token1);\r\n\r\n    function pairFor(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function getReserves(address tokenA, address tokenB) external view returns (uint256 reserveA, uint256 reserveB);\r\n\r\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint256 amountB);\r\n\r\n    // function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountOut);\r\n\r\n    // function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountIn);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path, address to) external view returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path, address to) external view returns (uint256[] memory amounts);\r\n\r\n    // function amountToCTokenAmt(address ctoken, uint amountIn) external view returns (uint cAmountIn);\r\n    // function ctokenAmtToAmount(address ctoken, uint cAmountOut) external view returns (uint amountOut);\r\n\r\n    function setPairFeeRate(address pair, uint feeRate) external;\r\n\r\n    function getReservesFeeRate(address tokenA, address tokenB, address to) external view returns (uint reserveA, uint reserveB, uint feeRate, bool outAnchorToken);\r\n\r\n    function getAmountOutFeeRate(uint amountIn, uint reserveIn, uint reserveOut, uint feeRate) external pure returns (uint amountOut);\r\n\r\n    function getAmountInFeeRate(uint amountOut, uint reserveIn, uint reserveOut, uint feeRate) external pure returns (uint amountIn);\r\n\r\n    function getAmountOutFeeRateAnchorToken(uint amountIn, uint reserveIn, uint reserveOut, uint feeRate) external pure returns (uint amountOut);\r\n\r\n    function setAnchorToken(address _token) external;\r\n}\r\n"
    },
    "contracts/swap/interface/IDeBankPair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity ^0.5.16;\r\n\r\ninterface IDeBankPair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    // function ownerAmountOf(address owner) external view returns (uint);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function feeRate() external view returns (uint);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function price0CumulativeLast() external view returns (uint);\r\n\r\n    function price1CumulativeLast() external view returns (uint);\r\n\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    // function mintCToken(address to) external returns (uint liquidity);\r\n\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n\r\n    function swapNoFee(uint amount0Out, uint amount1Out, address to, uint fee) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function price(address token, uint256 baseDecimal) external view returns (uint256);\r\n\r\n    function initialize(address, address, address, address) external;\r\n    function updateFeeRate(uint256 _feeRate) external;\r\n    // initialize ctoken address\r\n    // function initializeCTokenAddress(address, address) external;\r\n\r\n    function getFee(uint256 amt) external view returns (uint256);\r\n\r\n    // function updateFeeRate(_feeRate) external;\r\n}\r\n"
    },
    "contracts/swap/interface/IDeBankRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity ^0.5.16;\r\n\r\ninterface IDeBankRouter {\r\n    function factory() external view returns (address);\r\n\r\n    function WHT() external view returns (address);\r\n\r\n    function allPairFee() external view returns (uint);\r\n\r\n    function allPairFeeLastBlock() external view returns (uint);\r\n\r\n    function reward(uint256 blockNumber) external view returns (uint256);\r\n\r\n    function rewardToken() external view returns (address);\r\n\r\n    function lpDepositAddr() external view returns (address);\r\n    \r\n    function compAddr() external view returns (address);\r\n\r\n    function startBlock() external view returns (uint);\r\n\r\n    function swapMining() external view returns (address);\r\n\r\n    function getBlockRewards(uint256 _lastRewardBlock) external view returns (uint256);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityUnderlying(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETHUnderlying(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityUnderlying(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETHUnderlying(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETHUnderlyingWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForTokensUnderlying(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokensUnderlying(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokensUnderlying(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactETHUnderlying(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETHUnderlying(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n\r\n    function swapETHForExactTokensUnderlying(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    // function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    // external\r\n    // payable\r\n    // returns (uint[] memory amounts);\r\n\r\n    // function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    // external\r\n    // returns (uint[] memory amounts);\r\n\r\n    // function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    // external\r\n    // returns (uint[] memory amounts);\r\n\r\n    // function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    // external\r\n    // payable\r\n    // returns (uint[] memory amounts);\r\n\r\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external view returns (uint256 amountB);\r\n\r\n    // function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountOut);\r\n\r\n    // function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountIn);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path, address to) external view returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path, address to) external view returns (uint256[] memory amounts);\r\n\r\n    // function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n    //     address token,\r\n    //     uint liquidity,\r\n    //     uint amountTokenMin,\r\n    //     uint amountETHMin,\r\n    //     address to,\r\n    //     uint deadline\r\n    // ) external returns (uint amountETH);\r\n\r\n    // function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n    //     address token,\r\n    //     uint liquidity,\r\n    //     uint amountTokenMin,\r\n    //     uint amountETHMin,\r\n    //     address to,\r\n    //     uint deadline,\r\n    //     bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    // ) external returns (uint amountETH);\r\n\r\n    // function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n    //     uint amountIn,\r\n    //     uint amountOutMin,\r\n    //     address[] calldata path,\r\n    //     address to,\r\n    //     uint deadline\r\n    // ) external;\r\n\r\n    // function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n    //     uint amountOutMin,\r\n    //     address[] calldata path,\r\n    //     address to,\r\n    //     uint deadline\r\n    // ) external payable;\r\n\r\n    // function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n    //     uint amountIn,\r\n    //     uint amountOutMin,\r\n    //     address[] calldata path,\r\n    //     address to,\r\n    //     uint deadline\r\n    // ) external;\r\n}\r\n"
    },
    "contracts/swap/heco/PairStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity ^0.5.16;\r\n\r\nimport \"../interface/IDeBankPair.sol\";\r\n\r\ncontract PairStorage is IDeBankPair {\r\n    // uint public MIN_RAMP_TIME = 86400;\r\n    uint public constant MINIMUM_LIQUIDITY = 10 ** 3;\r\n\r\n    address public factory;\r\n    address public token0;\r\n    address public token1;\r\n    address public cToken0;              // 对应 token0 在 lend 池中的 cToken\r\n    address public cToken1;              // 对应 token1 在 lend 池中的 cToken\r\n\r\n    uint112 public reserve0;\r\n    uint112 public reserve1;\r\n\r\n    // uint256 public fee;\r\n    // bool public isStable;                      // 是否是稳定币\r\n    uint256 public feeRate = 30;        // 手续费千三, 万分之三十\r\n    // mapping(address => uint) feeRateOf; // 设置特定账户的手续费\r\n\r\n    uint32 internal blockTimestampLast; // uses single storage slot, accessible via getReserves\r\n\r\n    // uint112 public vReserve0;           // 虚拟的 token0 数量, 因为实际上 token0 已经存入 ctoken 合约中\r\n    // uint112 public vReserve1;           // 虚拟的 token1 数量, 因为实际上 token1 已经存入 ctoken 合约中\r\n    uint256 public lpFeeRate;           // 每个交易对分给LP的手续费比例 0不分\r\n\r\n    uint public price0CumulativeLast;\r\n    uint public price1CumulativeLast;\r\n    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\r\n\r\n    string public constant name = 'LP Token';\r\n    string public constant symbol = 'Dex';\r\n    uint8 public constant decimals = 18;\r\n    uint256 public totalSupply;\r\n\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n    bytes4 internal constant _SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n\r\n    mapping(address => uint) public nonces;\r\n    mapping(address => uint) public balanceOf;\r\n    // mapping(address => uint) public mintOf;\r\n    mapping(address => mapping(address => uint)) public allowance;\r\n\r\n    // 挖矿权\r\n    // 挖矿权与所有权(balanceOf) 分离. 当用户把LP转给compound抵押时, 挖矿权依然归用户\r\n    struct LPReward {\r\n        uint amount;            // LP amount\r\n        uint pendingReward;     // 未付 reward\r\n        uint rewardDebt;        // LP 挖矿 + ctoken 挖矿\r\n        // uint pendingReward;     // 未付 reward\r\n        // uint ctokenRewordDebt;  // \r\n    }\r\n    // 只有 owner 可以 burn, 其他不可以 burn\r\n    mapping(address => LPReward) public mintRewardOf;\r\n    uint public accPerShare;\r\n    // uint public rewards;\r\n    uint public totalFee;\r\n    uint public currentBlock;       // blockFee对应的块数\r\n    uint public blockFee;           // 当前块的手续费, 下一个块的第一笔交易触发计算上个块的reward, 然后重新累计\r\n\r\n    // ctoken 挖矿收益\r\n    // mapping(address => uint) public ctokenMintDebt;\r\n    uint public mintAccPerShare;\r\n    uint public ctokenMintRewards;\r\n    uint public ctokenRewordBlock; // 上一次更新的块数\r\n    uint public mintRewardDebt;    // 给用户转挖矿收益不足的情况\r\n\r\n    // struct OrderItem {\r\n    //     address owner;\r\n    //     uint price;\r\n    //     uint amount;\r\n    //     uint posId;    // 代持合约中杠杆用户的posId\r\n    //   // 通过\r\n    //   // uint next;\r\n    //   // uint prev;\r\n    //   // uint itemId;\r\n    // }\r\n\r\n    // 计算价格的乘数 price = token0 * priceRatio / token1, such as 1e30\r\n    // uint public priceRatio = 1e30; \r\n\r\n    // uint public itemId;\r\n    // mapping(uint => OrderItem) public buyOrders;\r\n    // mapping(uint => OrderItem) public sellOrders;\r\n\r\n    uint private _unlocked = 1;\r\n    modifier lock() {\r\n        require(_unlocked == 1, 'DeBankSwap: LOCKED');\r\n        _unlocked = 0;\r\n        _;\r\n        _unlocked = 1;\r\n    }\r\n\r\n    \r\n}\r\n"
    },
    "contracts/swap/interface/LErc20DelegatorInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.5.16;\r\n// import \"./CTokenInterfaces.sol\";\r\n\r\ncontract LErc20DelegatorInterface {\r\n      function delegateToInitialize(address underlying_,\r\n                address comptroller_,\r\n                address interestRateModel_,\r\n                uint initialExchangeRateMantissa_,\r\n                string memory name_,\r\n                string memory symbol_,\r\n                uint8 decimals_,\r\n                address payable admin_,\r\n                address implementation_,\r\n                bytes memory becomeImplementationData) public {}\r\n\r\n      // get or create ctoken\r\n      function getCTokenAddress(address token) external returns (address cToken);\r\n      function getCTokenAddressPure(address cToken) external view returns (address);\r\n      function getTokenAddress(address cToken) external view returns (address);\r\n}"
    },
    "contracts/swap/heco/SwapMining.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.5.16;\r\n\r\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\r\nimport \"../interface/IERC20.sol\";\r\nimport \"../library/SafeMath.sol\";\r\n\r\nimport \"../interface/IDeBankFactory.sol\";\r\nimport \"../interface/IDeBankPair.sol\";\r\n\r\nimport \"../interface/IMdx.sol\";\r\n\r\ninterface IOracle {\r\n    function update(address tokenA, address tokenB) external;\r\n\r\n    function consult(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut);\r\n}\r\n\r\ncontract SwapMining is Ownable {\r\n    using SafeMath for uint256;\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    EnumerableSet.AddressSet private _whitelist;\r\n\r\n    // MDX tokens created per block\r\n    uint256 public mdxPerBlock;\r\n    // The block number when MDX mining starts.\r\n    uint256 public startBlock;\r\n    // How many blocks are halved\r\n    uint256 public halvingPeriod = 5256000;\r\n    // Total allocation points\r\n    uint256 public totalAllocPoint = 0;\r\n    IOracle public oracle;\r\n    // router address\r\n    address public router;\r\n    // factory address\r\n    IDeBankFactory public factory;\r\n    // mdx token address\r\n    IMdx public mdx;\r\n    // Calculate price based on HUSD\r\n    address public targetToken;\r\n    // pair corresponding pid\r\n    mapping(address => uint256) public pairOfPid;\r\n\r\n    constructor(\r\n        IMdx _mdx,\r\n        IDeBankFactory _factory,\r\n        IOracle _oracle,\r\n        address _router,\r\n        address _targetToken,\r\n        uint256 _mdxPerBlock,\r\n        uint256 _startBlock\r\n    ) public {\r\n        mdx = _mdx;\r\n        factory = _factory;\r\n        oracle = _oracle;\r\n        router = _router;\r\n        targetToken = _targetToken;\r\n        mdxPerBlock = _mdxPerBlock;\r\n        startBlock = _startBlock;\r\n    }\r\n\r\n    struct UserInfo {\r\n        uint256 quantity;       // How many LP tokens the user has provided\r\n        uint256 blockNumber;    // Last transaction block\r\n    }\r\n\r\n    struct PoolInfo {\r\n        address pair;           // Trading pairs that can be mined\r\n        uint256 quantity;       // Current amount of LPs\r\n        uint256 totalQuantity;  // All quantity\r\n        uint256 allocPoint;     // How many allocation points assigned to this pool\r\n        uint256 allocMdxAmount; // How many MDXs\r\n        uint256 lastRewardBlock;// Last transaction block\r\n    }\r\n\r\n    PoolInfo[] public poolInfo;\r\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n\r\n\r\n    function poolLength() public view returns (uint256) {\r\n        return poolInfo.length;\r\n    }\r\n\r\n\r\n    function addPair(uint256 _allocPoint, address _pair, bool _withUpdate) public onlyOwner {\r\n        require(_pair != address(0), \"_pair is the zero address\");\r\n        if (_withUpdate) {\r\n            massMintPools();\r\n        }\r\n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\r\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\r\n        poolInfo.push(PoolInfo({\r\n        pair : _pair,\r\n        quantity : 0,\r\n        totalQuantity : 0,\r\n        allocPoint : _allocPoint,\r\n        allocMdxAmount : 0,\r\n        lastRewardBlock : lastRewardBlock\r\n        }));\r\n        pairOfPid[_pair] = poolLength() - 1;\r\n    }\r\n\r\n    // Update the allocPoint of the pool\r\n    function setPair(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner {\r\n        if (_withUpdate) {\r\n            massMintPools();\r\n        }\r\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\r\n        poolInfo[_pid].allocPoint = _allocPoint;\r\n    }\r\n\r\n    // Set the number of mdx produced by each block\r\n    function setMdxPerBlock(uint256 _newPerBlock) public onlyOwner {\r\n        massMintPools();\r\n        mdxPerBlock = _newPerBlock;\r\n    }\r\n\r\n    // Only tokens in the whitelist can be mined MDX\r\n    function addWhitelist(address _addToken) public onlyOwner returns (bool) {\r\n        require(_addToken != address(0), \"SwapMining: token is the zero address\");\r\n        return EnumerableSet.add(_whitelist, _addToken);\r\n    }\r\n\r\n    function delWhitelist(address _delToken) public onlyOwner returns (bool) {\r\n        require(_delToken != address(0), \"SwapMining: token is the zero address\");\r\n        return EnumerableSet.remove(_whitelist, _delToken);\r\n    }\r\n\r\n    function getWhitelistLength() public view returns (uint256) {\r\n        return EnumerableSet.length(_whitelist);\r\n    }\r\n\r\n    function isWhitelist(address _token) public view returns (bool) {\r\n        return EnumerableSet.contains(_whitelist, _token);\r\n    }\r\n\r\n    function getWhitelist(uint256 _index) public view returns (address){\r\n        require(_index <= getWhitelistLength() - 1, \"SwapMining: index out of bounds\");\r\n        return EnumerableSet.get(_whitelist, _index);\r\n    }\r\n\r\n    function setHalvingPeriod(uint256 _block) public onlyOwner {\r\n        halvingPeriod = _block;\r\n    }\r\n\r\n    function setRouter(address newRouter) public onlyOwner {\r\n        require(newRouter != address(0), \"SwapMining: new router is the zero address\");\r\n        router = newRouter;\r\n    }\r\n\r\n    function setOracle(IOracle _oracle) public onlyOwner {\r\n        require(address(_oracle) != address(0), \"SwapMining: new oracle is the zero address\");\r\n        oracle = _oracle;\r\n    }\r\n\r\n    // At what phase\r\n    function phase(uint256 blockNumber) public view returns (uint256) {\r\n        if (halvingPeriod == 0) {\r\n            return 0;\r\n        }\r\n        if (blockNumber > startBlock) {\r\n            return (blockNumber.sub(startBlock).sub(1)).div(halvingPeriod);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function phase() public view returns (uint256) {\r\n        return phase(block.number);\r\n    }\r\n\r\n    function reward(uint256 blockNumber) public view returns (uint256) {\r\n        uint256 _phase = phase(blockNumber);\r\n        return mdxPerBlock.div(2 ** _phase);\r\n    }\r\n\r\n    function reward() public view returns (uint256) {\r\n        return reward(block.number);\r\n    }\r\n\r\n    // Rewards for the current block\r\n    function getMdxReward(uint256 _lastRewardBlock) public view returns (uint256) {\r\n        require(_lastRewardBlock <= block.number, \"SwapMining: must little than the current block number\");\r\n        uint256 blockReward = 0;\r\n        uint256 n = phase(_lastRewardBlock);\r\n        uint256 m = phase(block.number);\r\n        // If it crosses the cycle\r\n        while (n < m) {\r\n            n++;\r\n            // Get the last block of the previous cycle\r\n            uint256 r = n.mul(halvingPeriod).add(startBlock);\r\n            // Get rewards from previous periods\r\n            blockReward = blockReward.add((r.sub(_lastRewardBlock)).mul(reward(r)));\r\n            _lastRewardBlock = r;\r\n        }\r\n        blockReward = blockReward.add((block.number.sub(_lastRewardBlock)).mul(reward(block.number)));\r\n        return blockReward;\r\n    }\r\n\r\n    // Update all pools Called when updating allocPoint and setting new blocks\r\n    function massMintPools() public {\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            mint(pid);\r\n        }\r\n    }\r\n\r\n    function mint(uint256 _pid) public returns (bool) {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (block.number <= pool.lastRewardBlock) {\r\n            return false;\r\n        }\r\n        uint256 blockReward = getMdxReward(pool.lastRewardBlock);\r\n        if (blockReward <= 0) {\r\n            return false;\r\n        }\r\n        // Calculate the rewards obtained by the pool based on the allocPoint\r\n        uint256 mdxReward = blockReward.mul(pool.allocPoint).div(totalAllocPoint);\r\n        mdx.mint(address(this), mdxReward);\r\n        // Increase the number of tokens in the current pool\r\n        pool.allocMdxAmount = pool.allocMdxAmount.add(mdxReward);\r\n        pool.lastRewardBlock = block.number;\r\n        return true;\r\n    }\r\n\r\n    // swapMining only router\r\n    function swap(address account, address input, address output, uint256 amount) public onlyRouter returns (bool) {\r\n        require(account != address(0), \"SwapMining: taker swap account is the zero address\");\r\n        require(input != address(0), \"SwapMining: taker swap input is the zero address\");\r\n        require(output != address(0), \"SwapMining: taker swap output is the zero address\");\r\n\r\n        if (poolLength() <= 0) {\r\n            return false;\r\n        }\r\n\r\n        if (!isWhitelist(input) || !isWhitelist(output)) {\r\n            return false;\r\n        }\r\n\r\n        address pair = IDeBankFactory(factory).pairFor(input, output);\r\n\r\n        PoolInfo storage pool = poolInfo[pairOfPid[pair]];\r\n        // If it does not exist or the allocPoint is 0 then return\r\n        if (pool.pair != pair || pool.allocPoint <= 0) {\r\n            return false;\r\n        }\r\n\r\n        uint256 quantity = getQuantity(output, amount, targetToken);\r\n        if (quantity <= 0) {\r\n            return false;\r\n        }\r\n\r\n        mint(pairOfPid[pair]);\r\n\r\n        pool.quantity = pool.quantity.add(quantity);\r\n        pool.totalQuantity = pool.totalQuantity.add(quantity);\r\n        UserInfo storage user = userInfo[pairOfPid[pair]][account];\r\n        user.quantity = user.quantity.add(quantity);\r\n        user.blockNumber = block.number;\r\n        return true;\r\n    }\r\n\r\n    // The user withdraws all the transaction rewards of the pool\r\n    function takerWithdraw() public {\r\n        uint256 userSub;\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            PoolInfo storage pool = poolInfo[pid];\r\n            UserInfo storage user = userInfo[pid][msg.sender];\r\n            if (user.quantity > 0) {\r\n                mint(pid);\r\n                // The reward held by the user in this pool\r\n                uint256 userReward = pool.allocMdxAmount.mul(user.quantity).div(pool.quantity);\r\n                pool.quantity = pool.quantity.sub(user.quantity);\r\n                pool.allocMdxAmount = pool.allocMdxAmount.sub(userReward);\r\n                user.quantity = 0;\r\n                user.blockNumber = block.number;\r\n                userSub = userSub.add(userReward);\r\n            }\r\n        }\r\n        if (userSub <= 0) {\r\n            return;\r\n        }\r\n        mdx.transfer(msg.sender, userSub);\r\n    }\r\n\r\n    // Get rewards from users in the current pool\r\n    function getUserReward(uint256 _pid) public view returns (uint256, uint256){\r\n        require(_pid <= poolInfo.length - 1, \"SwapMining: Not find this pool\");\r\n        uint256 userSub;\r\n        PoolInfo memory pool = poolInfo[_pid];\r\n        UserInfo memory user = userInfo[_pid][msg.sender];\r\n        if (user.quantity > 0) {\r\n            uint256 blockReward = getMdxReward(pool.lastRewardBlock);\r\n            uint256 mdxReward = blockReward.mul(pool.allocPoint).div(totalAllocPoint);\r\n            userSub = userSub.add((pool.allocMdxAmount.add(mdxReward)).mul(user.quantity).div(pool.quantity));\r\n        }\r\n        //Mdx available to users, User transaction amount\r\n        return (userSub, user.quantity);\r\n    }\r\n\r\n    // Get details of the pool\r\n    function getPoolInfo(uint256 _pid) public view returns (address, address, uint256, uint256, uint256, uint256){\r\n        require(_pid <= poolInfo.length - 1, \"SwapMining: Not find this pool\");\r\n        PoolInfo memory pool = poolInfo[_pid];\r\n        address token0 = IDeBankPair(pool.pair).token0();\r\n        address token1 = IDeBankPair(pool.pair).token1();\r\n        uint256 mdxAmount = pool.allocMdxAmount;\r\n        uint256 blockReward = getMdxReward(pool.lastRewardBlock);\r\n        uint256 mdxReward = blockReward.mul(pool.allocPoint).div(totalAllocPoint);\r\n        mdxAmount = mdxAmount.add(mdxReward);\r\n        //token0,token1,Pool remaining reward,Total /Current transaction volume of the pool\r\n        return (token0, token1, mdxAmount, pool.totalQuantity, pool.quantity, pool.allocPoint);\r\n    }\r\n\r\n    modifier onlyRouter() {\r\n        require(msg.sender == router, \"SwapMining: caller is not the router\");\r\n        _;\r\n    }\r\n\r\n    function getQuantity(address outputToken, uint256 outputAmount, address anchorToken) public view returns (uint256) {\r\n        uint256 quantity = 0;\r\n        if (outputToken == anchorToken) {\r\n            quantity = outputAmount;\r\n        } else if (IDeBankFactory(factory).getPair(outputToken, anchorToken) != address(0)) {\r\n            quantity = IOracle(oracle).consult(outputToken, outputAmount, anchorToken);\r\n        } else {\r\n            uint256 length = getWhitelistLength();\r\n            for (uint256 index = 0; index < length; index++) {\r\n                address intermediate = getWhitelist(index);\r\n                if (IDeBankFactory(factory).getPair(outputToken, intermediate) != address(0) && IDeBankFactory(factory).getPair(intermediate, anchorToken) != address(0)) {\r\n                    uint256 interQuantity = IOracle(oracle).consult(outputToken, outputAmount, intermediate);\r\n                    quantity = IOracle(oracle).consult(intermediate, interQuantity, anchorToken);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return quantity;\r\n    }\r\n\r\n}\r\n"
    },
    "@openzeppelin/contracts/ownership/Ownable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * As of v2.5.0, only `address` sets are supported.\n *\n * Include with `using EnumerableSet for EnumerableSet.AddressSet;`.\n *\n * _Available since v2.5.0._\n *\n * @author Alberto Cuesta Cañada\n */\nlibrary EnumerableSet {\n\n    struct AddressSet {\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (address => uint256) index;\n        address[] values;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     * Returns false if the value was already in the set.\n     */\n    function add(AddressSet storage set, address value)\n        internal\n        returns (bool)\n    {\n        if (!contains(set, value)){\n            set.index[value] = set.values.push(value);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     * Returns false if the value was not present in the set.\n     */\n    function remove(AddressSet storage set, address value)\n        internal\n        returns (bool)\n    {\n        if (contains(set, value)){\n            uint256 toDeleteIndex = set.index[value] - 1;\n            uint256 lastIndex = set.values.length - 1;\n\n            // If the element we're deleting is the last one, we can just remove it without doing a swap\n            if (lastIndex != toDeleteIndex) {\n                address lastValue = set.values[lastIndex];\n\n                // Move the last value to the index where the deleted value is\n                set.values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set.index[lastValue] = toDeleteIndex + 1; // All indexes are 1-based\n            }\n\n            // Delete the index entry for the deleted value\n            delete set.index[value];\n\n            // Delete the old entry for the moved value\n            set.values.pop();\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value)\n        internal\n        view\n        returns (bool)\n    {\n        return set.index[value] != 0;\n    }\n\n    /**\n     * @dev Returns an array with all values in the set. O(N).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n\n     * WARNING: This function may run out of gas on large sets: use {length} and\n     * {get} instead in these cases.\n     */\n    function enumerate(AddressSet storage set)\n        internal\n        view\n        returns (address[] memory)\n    {\n        address[] memory output = new address[](set.values.length);\n        for (uint256 i; i < set.values.length; i++){\n            output[i] = set.values[i];\n        }\n        return output;\n    }\n\n    /**\n     * @dev Returns the number of elements on the set. O(1).\n     */\n    function length(AddressSet storage set)\n        internal\n        view\n        returns (uint256)\n    {\n        return set.values.length;\n    }\n\n   /** @dev Returns the element stored at position `index` in the set. O(1).\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function get(AddressSet storage set, uint256 index)\n        internal\n        view\n        returns (address)\n    {\n        return set.values[index];\n    }\n}\n"
    },
    "contracts/swap/interface/IMdx.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.5.16;\r\n\r\nimport {IERC20 as SIERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ncontract IMdx is SIERC20 {\r\n    function mint(address to, uint256 amount) external returns (bool);\r\n}\r\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/swap/heco/HecoPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.5.16;\r\n\r\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"../interface/IMdx.sol\";\r\n\r\ninterface IMasterChefHeco {\r\n    function pending(uint256 pid, address user) external view returns (uint256);\r\n\r\n    function deposit(uint256 pid, uint256 amount) external;\r\n\r\n    function withdraw(uint256 pid, uint256 amount) external;\r\n\r\n    function emergencyWithdraw(uint256 pid) external;\r\n}\r\n\r\ncontract HecoPool is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    EnumerableSet.AddressSet private _multLP;\r\n\r\n    // Info of each user.\r\n    struct UserInfo {\r\n        uint256 amount;     // How many LP tokens the user has provided.\r\n        uint256 rewardDebt; // Reward debt.\r\n        uint256 multLpRewardDebt; //multLp Reward debt.\r\n    }\r\n\r\n    // Info of each pool.\r\n    struct PoolInfo {\r\n        IERC20 lpToken;           // Address of LP token contract.\r\n        uint256 allocPoint;       // How many allocation points assigned to this pool. MDXs to distribute per block.\r\n        uint256 lastRewardBlock;  // Last block number that MDXs distribution occurs.\r\n        uint256 accMdxPerShare; // Accumulated MDXs per share, times 1e12.\r\n        uint256 accMultLpPerShare; //Accumulated multLp per share\r\n        uint256 totalAmount;    // Total amount of current pool deposit.\r\n    }\r\n\r\n    // The MDX Token!\r\n    IMdx public mdx;\r\n    // MDX tokens created per block.\r\n    uint256 public mdxPerBlock;\r\n    // Info of each pool.\r\n    PoolInfo[] public poolInfo;\r\n    // Info of each user that stakes LP tokens.\r\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n    // Corresponding to the pid of the multLP pool\r\n    mapping(uint256 => uint256) public poolCorrespond;\r\n    // pid corresponding address\r\n    mapping(address => uint256) public LpOfPid;\r\n    // Control mining\r\n    bool public paused = false;\r\n    // Total allocation points. Must be the sum of all allocation points in all pools.\r\n    uint256 public totalAllocPoint = 0;\r\n    // The block number when MDX mining starts.\r\n    uint256 public startBlock;\r\n    // multLP MasterChef\r\n    address public multLpChef;\r\n    // multLP Token\r\n    address public multLpToken;\r\n    // How many blocks are halved\r\n    uint256 public halvingPeriod = 5256000;\r\n\r\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n\r\n    constructor(\r\n        IMdx _mdx,\r\n        uint256 _mdxPerBlock,\r\n        uint256 _startBlock\r\n    ) public {\r\n        mdx = _mdx;\r\n        mdxPerBlock = _mdxPerBlock;\r\n        startBlock = _startBlock;\r\n    }\r\n\r\n    function setHalvingPeriod(uint256 _block) public onlyOwner {\r\n        halvingPeriod = _block;\r\n    }\r\n\r\n    // Set the number of mdx produced by each block\r\n    function setMdxPerBlock(uint256 _newPerBlock) public onlyOwner {\r\n        massUpdatePools();\r\n        mdxPerBlock = _newPerBlock;\r\n    }\r\n\r\n    function poolLength() public view returns (uint256) {\r\n        return poolInfo.length;\r\n    }\r\n\r\n    function addMultLP(address _addLP) public onlyOwner returns (bool) {\r\n        require(_addLP != address(0), \"LP is the zero address\");\r\n        IERC20(_addLP).approve(multLpChef, uint256(- 1));\r\n        return EnumerableSet.add(_multLP, _addLP);\r\n    }\r\n\r\n    function isMultLP(address _LP) public view returns (bool) {\r\n        return EnumerableSet.contains(_multLP, _LP);\r\n    }\r\n\r\n    function getMultLPLength() public view returns (uint256) {\r\n        return EnumerableSet.length(_multLP);\r\n    }\r\n\r\n    function getMultLPAddress(uint256 _pid) public view returns (address){\r\n        require(_pid <= getMultLPLength() - 1, \"not find this multLP\");\r\n        return EnumerableSet.get(_multLP, _pid);\r\n    }\r\n\r\n    function setPause() public onlyOwner {\r\n        paused = !paused;\r\n    }\r\n\r\n    function setMultLP(address _multLpToken, address _multLpChef) public onlyOwner {\r\n        require(_multLpToken != address(0) && _multLpChef != address(0), \"is the zero address\");\r\n        multLpToken = _multLpToken;\r\n        multLpChef = _multLpChef;\r\n    }\r\n\r\n    function replaceMultLP(address _multLpToken, address _multLpChef) public onlyOwner {\r\n        require(_multLpToken != address(0) && _multLpChef != address(0), \"is the zero address\");\r\n        require(paused == true, \"No mining suspension\");\r\n        multLpToken = _multLpToken;\r\n        multLpChef = _multLpChef;\r\n        uint256 length = getMultLPLength();\r\n        while (length > 0) {\r\n            address dAddress = EnumerableSet.get(_multLP, 0);\r\n            uint256 pid = LpOfPid[dAddress];\r\n            IMasterChefHeco(multLpChef).emergencyWithdraw(poolCorrespond[pid]);\r\n            EnumerableSet.remove(_multLP, dAddress);\r\n            length--;\r\n        }\r\n    }\r\n\r\n    // Add a new lp to the pool. Can only be called by the owner.\r\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\r\n    function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner {\r\n        require(address(_lpToken) != address(0), \"_lpToken is the zero address\");\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\r\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\r\n        poolInfo.push(PoolInfo({\r\n        lpToken : _lpToken,\r\n        allocPoint : _allocPoint,\r\n        lastRewardBlock : lastRewardBlock,\r\n        accMdxPerShare : 0,\r\n        accMultLpPerShare : 0,\r\n        totalAmount : 0\r\n        }));\r\n        LpOfPid[address(_lpToken)] = poolLength() - 1;\r\n    }\r\n\r\n    // Update the given pool's MDX allocation point. Can only be called by the owner.\r\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner {\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\r\n        poolInfo[_pid].allocPoint = _allocPoint;\r\n    }\r\n\r\n    // The current pool corresponds to the pid of the multLP pool\r\n    function setPoolCorr(uint256 _pid, uint256 _sid) public onlyOwner {\r\n        require(_pid <= poolLength() - 1, \"not find this pool\");\r\n        poolCorrespond[_pid] = _sid;\r\n    }\r\n\r\n    function phase(uint256 blockNumber) public view returns (uint256) {\r\n        if (halvingPeriod == 0) {\r\n            return 0;\r\n        }\r\n        if (blockNumber > startBlock) {\r\n            return (blockNumber.sub(startBlock).sub(1)).div(halvingPeriod);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function reward(uint256 blockNumber) public view returns (uint256) {\r\n        uint256 _phase = phase(blockNumber);\r\n        return mdxPerBlock.div(2 ** _phase);\r\n    }\r\n\r\n    function getMdxBlockReward(uint256 _lastRewardBlock) public view returns (uint256) {\r\n        uint256 blockReward = 0;\r\n        uint256 n = phase(_lastRewardBlock);\r\n        uint256 m = phase(block.number);\r\n        while (n < m) {\r\n            n++;\r\n            uint256 r = n.mul(halvingPeriod).add(startBlock);\r\n            blockReward = blockReward.add((r.sub(_lastRewardBlock)).mul(reward(r)));\r\n            _lastRewardBlock = r;\r\n        }\r\n        blockReward = blockReward.add((block.number.sub(_lastRewardBlock)).mul(reward(block.number)));\r\n        return blockReward;\r\n    }\r\n\r\n    // Update reward variables for all pools. Be careful of gas spending!\r\n    function massUpdatePools() public {\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            updatePool(pid);\r\n        }\r\n    }\r\n\r\n    // Update reward variables of the given pool to be up-to-date.\r\n    function updatePool(uint256 _pid) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (block.number <= pool.lastRewardBlock) {\r\n            return;\r\n        }\r\n        uint256 lpSupply;\r\n        if (isMultLP(address(pool.lpToken))) {\r\n            if (pool.totalAmount == 0) {\r\n                pool.lastRewardBlock = block.number;\r\n                return;\r\n            }\r\n            lpSupply = pool.totalAmount;\r\n        } else {\r\n            lpSupply = pool.lpToken.balanceOf(address(this));\r\n            if (lpSupply == 0) {\r\n                pool.lastRewardBlock = block.number;\r\n                return;\r\n            }\r\n        }\r\n        uint256 blockReward = getMdxBlockReward(pool.lastRewardBlock);\r\n        if (blockReward <= 0) {\r\n            return;\r\n        }\r\n        uint256 mdxReward = blockReward.mul(pool.allocPoint).div(totalAllocPoint);\r\n        bool minRet = mdx.mint(address(this), mdxReward);\r\n        if (minRet) {\r\n            pool.accMdxPerShare = pool.accMdxPerShare.add(mdxReward.mul(1e12).div(lpSupply));\r\n        }\r\n        pool.lastRewardBlock = block.number;\r\n    }\r\n\r\n    // View function to see pending MDXs on frontend.\r\n    function pending(uint256 _pid, address _user) external view returns (uint256, uint256){\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (isMultLP(address(pool.lpToken))) {\r\n            (uint256 mdxAmount, uint256 tokenAmount) = pendingMdxAndToken(_pid, _user);\r\n            return (mdxAmount, tokenAmount);\r\n        } else {\r\n            uint256 mdxAmount = pendingMdx(_pid, _user);\r\n            return (mdxAmount, 0);\r\n        }\r\n    }\r\n\r\n    function pendingMdxAndToken(uint256 _pid, address _user) private view returns (uint256, uint256){\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        uint256 accMdxPerShare = pool.accMdxPerShare;\r\n        uint256 accMultLpPerShare = pool.accMultLpPerShare;\r\n        if (user.amount > 0) {\r\n            uint256 TokenPending = IMasterChefHeco(multLpChef).pending(poolCorrespond[_pid], address(this));\r\n            accMultLpPerShare = accMultLpPerShare.add(TokenPending.mul(1e12).div(pool.totalAmount));\r\n            uint256 userPending = user.amount.mul(accMultLpPerShare).div(1e12).sub(user.multLpRewardDebt);\r\n            if (block.number > pool.lastRewardBlock) {\r\n                uint256 blockReward = getMdxBlockReward(pool.lastRewardBlock);\r\n                uint256 mdxReward = blockReward.mul(pool.allocPoint).div(totalAllocPoint);\r\n                accMdxPerShare = accMdxPerShare.add(mdxReward.mul(1e12).div(pool.totalAmount));\r\n                return (user.amount.mul(accMdxPerShare).div(1e12).sub(user.rewardDebt), userPending);\r\n            }\r\n            if (block.number == pool.lastRewardBlock) {\r\n                return (user.amount.mul(accMdxPerShare).div(1e12).sub(user.rewardDebt), userPending);\r\n            }\r\n        }\r\n        return (0, 0);\r\n    }\r\n\r\n    function pendingMdx(uint256 _pid, address _user) private view returns (uint256){\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        uint256 accMdxPerShare = pool.accMdxPerShare;\r\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\r\n        if (user.amount > 0) {\r\n            if (block.number > pool.lastRewardBlock) {\r\n                uint256 blockReward = getMdxBlockReward(pool.lastRewardBlock);\r\n                uint256 mdxReward = blockReward.mul(pool.allocPoint).div(totalAllocPoint);\r\n                accMdxPerShare = accMdxPerShare.add(mdxReward.mul(1e12).div(lpSupply));\r\n                return user.amount.mul(accMdxPerShare).div(1e12).sub(user.rewardDebt);\r\n            }\r\n            if (block.number == pool.lastRewardBlock) {\r\n                return user.amount.mul(accMdxPerShare).div(1e12).sub(user.rewardDebt);\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    // Deposit LP tokens to HecoPool for MDX allocation.\r\n    function deposit(uint256 _pid, uint256 _amount) public notPause {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (isMultLP(address(pool.lpToken))) {\r\n            depositMdxAndToken(_pid, _amount, msg.sender);\r\n        } else {\r\n            depositMdx(_pid, _amount, msg.sender);\r\n        }\r\n    }\r\n\r\n    function depositMdxAndToken(uint256 _pid, uint256 _amount, address _user) private {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        updatePool(_pid);\r\n        if (user.amount > 0) {\r\n            uint256 pendingAmount = user.amount.mul(pool.accMdxPerShare).div(1e12).sub(user.rewardDebt);\r\n            if (pendingAmount > 0) {\r\n                safeMdxTransfer(_user, pendingAmount);\r\n            }\r\n            uint256 beforeToken = IERC20(multLpToken).balanceOf(address(this));\r\n            IMasterChefHeco(multLpChef).deposit(poolCorrespond[_pid], 0);\r\n            uint256 afterToken = IERC20(multLpToken).balanceOf(address(this));\r\n            pool.accMultLpPerShare = pool.accMultLpPerShare.add(afterToken.sub(beforeToken).mul(1e12).div(pool.totalAmount));\r\n            uint256 tokenPending = user.amount.mul(pool.accMultLpPerShare).div(1e12).sub(user.multLpRewardDebt);\r\n            if (tokenPending > 0) {\r\n                IERC20(multLpToken).safeTransfer(_user, tokenPending);\r\n            }\r\n        }\r\n        if (_amount > 0) {\r\n            pool.lpToken.safeTransferFrom(_user, address(this), _amount);\r\n            if (pool.totalAmount == 0) {\r\n                IMasterChefHeco(multLpChef).deposit(poolCorrespond[_pid], _amount);\r\n                user.amount = user.amount.add(_amount);\r\n                pool.totalAmount = pool.totalAmount.add(_amount);\r\n            } else {\r\n                uint256 beforeToken = IERC20(multLpToken).balanceOf(address(this));\r\n                IMasterChefHeco(multLpChef).deposit(poolCorrespond[_pid], _amount);\r\n                uint256 afterToken = IERC20(multLpToken).balanceOf(address(this));\r\n                pool.accMultLpPerShare = pool.accMultLpPerShare.add(afterToken.sub(beforeToken).mul(1e12).div(pool.totalAmount));\r\n                user.amount = user.amount.add(_amount);\r\n                pool.totalAmount = pool.totalAmount.add(_amount);\r\n            }\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accMdxPerShare).div(1e12);\r\n        user.multLpRewardDebt = user.amount.mul(pool.accMultLpPerShare).div(1e12);\r\n        emit Deposit(_user, _pid, _amount);\r\n    }\r\n\r\n    function depositMdx(uint256 _pid, uint256 _amount, address _user) private {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        updatePool(_pid);\r\n        if (user.amount > 0) {\r\n            uint256 pendingAmount = user.amount.mul(pool.accMdxPerShare).div(1e12).sub(user.rewardDebt);\r\n            if (pendingAmount > 0) {\r\n                safeMdxTransfer(_user, pendingAmount);\r\n            }\r\n        }\r\n        if (_amount > 0) {\r\n            pool.lpToken.safeTransferFrom(_user, address(this), _amount);\r\n            user.amount = user.amount.add(_amount);\r\n            pool.totalAmount = pool.totalAmount.add(_amount);\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accMdxPerShare).div(1e12);\r\n        emit Deposit(_user, _pid, _amount);\r\n    }\r\n\r\n    // Withdraw LP tokens from HecoPool.\r\n    function withdraw(uint256 _pid, uint256 _amount) public notPause {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (isMultLP(address(pool.lpToken))) {\r\n            withdrawMdxAndToken(_pid, _amount, msg.sender);\r\n        } else {\r\n            withdrawMdx(_pid, _amount, msg.sender);\r\n        }\r\n    }\r\n\r\n    function withdrawMdxAndToken(uint256 _pid, uint256 _amount, address _user) private {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        require(user.amount >= _amount, \"withdrawMdxAndToken: not good\");\r\n        updatePool(_pid);\r\n        uint256 pendingAmount = user.amount.mul(pool.accMdxPerShare).div(1e12).sub(user.rewardDebt);\r\n        if (pendingAmount > 0) {\r\n            safeMdxTransfer(_user, pendingAmount);\r\n        }\r\n        if (_amount > 0) {\r\n            uint256 beforeToken = IERC20(multLpToken).balanceOf(address(this));\r\n            IMasterChefHeco(multLpChef).withdraw(poolCorrespond[_pid], _amount);\r\n            uint256 afterToken = IERC20(multLpToken).balanceOf(address(this));\r\n            pool.accMultLpPerShare = pool.accMultLpPerShare.add(afterToken.sub(beforeToken).mul(1e12).div(pool.totalAmount));\r\n            uint256 tokenPending = user.amount.mul(pool.accMultLpPerShare).div(1e12).sub(user.multLpRewardDebt);\r\n            if (tokenPending > 0) {\r\n                IERC20(multLpToken).safeTransfer(_user, tokenPending);\r\n            }\r\n            user.amount = user.amount.sub(_amount);\r\n            pool.totalAmount = pool.totalAmount.sub(_amount);\r\n            pool.lpToken.safeTransfer(_user, _amount);\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accMdxPerShare).div(1e12);\r\n        user.multLpRewardDebt = user.amount.mul(pool.accMultLpPerShare).div(1e12);\r\n        emit Withdraw(_user, _pid, _amount);\r\n    }\r\n\r\n    function withdrawMdx(uint256 _pid, uint256 _amount, address _user) private {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        require(user.amount >= _amount, \"withdrawMdx: not good\");\r\n        updatePool(_pid);\r\n        uint256 pendingAmount = user.amount.mul(pool.accMdxPerShare).div(1e12).sub(user.rewardDebt);\r\n        if (pendingAmount > 0) {\r\n            safeMdxTransfer(_user, pendingAmount);\r\n        }\r\n        if (_amount > 0) {\r\n            user.amount = user.amount.sub(_amount);\r\n            pool.totalAmount = pool.totalAmount.sub(_amount);\r\n            pool.lpToken.safeTransfer(_user, _amount);\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accMdxPerShare).div(1e12);\r\n        emit Withdraw(_user, _pid, _amount);\r\n    }\r\n\r\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\r\n    function emergencyWithdraw(uint256 _pid) public notPause {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (isMultLP(address(pool.lpToken))) {\r\n            emergencyWithdrawMdxAndToken(_pid, msg.sender);\r\n        } else {\r\n            emergencyWithdrawMdx(_pid, msg.sender);\r\n        }\r\n    }\r\n\r\n    function emergencyWithdrawMdxAndToken(uint256 _pid, address _user) private {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        uint256 amount = user.amount;\r\n        uint256 beforeToken = IERC20(multLpToken).balanceOf(address(this));\r\n        IMasterChefHeco(multLpChef).withdraw(poolCorrespond[_pid], amount);\r\n        uint256 afterToken = IERC20(multLpToken).balanceOf(address(this));\r\n        pool.accMultLpPerShare = pool.accMultLpPerShare.add(afterToken.sub(beforeToken).mul(1e12).div(pool.totalAmount));\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n        pool.lpToken.safeTransfer(_user, amount);\r\n        pool.totalAmount = pool.totalAmount.sub(amount);\r\n        emit EmergencyWithdraw(_user, _pid, amount);\r\n    }\r\n\r\n    function emergencyWithdrawMdx(uint256 _pid, address _user) private {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        uint256 amount = user.amount;\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n        pool.lpToken.safeTransfer(_user, amount);\r\n        pool.totalAmount = pool.totalAmount.sub(amount);\r\n        emit EmergencyWithdraw(_user, _pid, amount);\r\n    }\r\n\r\n    // Safe MDX transfer function, just in case if rounding error causes pool to not have enough MDXs.\r\n    function safeMdxTransfer(address _to, uint256 _amount) internal {\r\n        uint256 mdxBal = mdx.balanceOf(address(this));\r\n        if (_amount > mdxBal) {\r\n            mdx.transfer(_to, mdxBal);\r\n        } else {\r\n            mdx.transfer(_to, _amount);\r\n        }\r\n    }\r\n\r\n    modifier notPause() {\r\n        require(paused == false, \"Mining has been suspended\");\r\n        _;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.5.5;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following \n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"
    },
    "contracts/compound/lp/Chef.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\r\nimport \"../Governance/LendHub.sol\";\r\n\r\n//\r\n// Note that it's ownable and the owner wields tremendous power. The ownership\r\n// will be transferred to a governance smart contract once LHB is sufficiently\r\n// distributed and the community can show to govern itself.\r\n//\r\n// Have fun reading it. Hopefully it's bug-free. God bless.\r\ncontract Chef is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // Info of each user.\r\n    struct UserInfo {\r\n        uint256 amount;     // How many LP tokens the user has provided.\r\n        uint256 rewardDebt; // Reward debt. See explanation below.\r\n        //\r\n        // We do some fancy math here. Basically, any point in time, the amount of SUSHIs\r\n        // entitled to a user but is pending to be distributed is:\r\n        //\r\n        //   pending reward = (user.amount * pool.accLHBPerShare) - user.rewardDebt\r\n        //\r\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\r\n        //   1. The pool's `accLHBPerShare` (and `lastRewardBlock`) gets updated.\r\n        //   2. User receives the pending reward sent to his/her address.\r\n        //   3. User's `amount` gets updated.\r\n        //   4. User's `rewardDebt` gets updated.\r\n    }\r\n\r\n    // Info of each pool.\r\n    struct PoolInfo {\r\n        IERC20 lpToken;           // Address of LP token contract.\r\n        uint256 allocPoint;       // How many allocation points assigned to this pool. SUSHIs to distribute per block.\r\n        uint256 lastRewardBlock;  // Last block number that SUSHIs distribution occurs.\r\n        uint256 accLHBPerShare; // Accumulated LHB per share, times 1e12. See below.\r\n    }\r\n\r\n    // The LHB TOKEN!\r\n    LendHub public lhb;\r\n    uint256 public userLHBAmount = 0;\r\n    // LHB tokens created per block.\r\n    uint256 public lhbPerBlock;\r\n\r\n    // Info of each pool.\r\n    PoolInfo[] public poolInfo;\r\n    // Info of each user that stakes LP tokens.\r\n    mapping (uint256 => mapping (address => UserInfo)) public userInfo;\r\n    // Total allocation points. Must be the sum of all allocation points in all pools.\r\n    uint256 public totalAllocPoint = 0;\r\n    // The block number when LHB mining starts.\r\n    uint256 public startBlock;\r\n\r\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n\r\n    constructor(\r\n        LendHub _lhb,\r\n        uint256 _lhbPerBlock,\r\n        uint256 _startBlock\r\n    ) public {\r\n        lhb = _lhb;\r\n        lhbPerBlock = _lhbPerBlock;\r\n        startBlock = _startBlock;\r\n    }\r\n\r\n    function poolLength() external view returns (uint256) {\r\n        return poolInfo.length;\r\n    }\r\n\r\n    function updateLHBPerBlock(uint256 _lhbPerBlock) public onlyOwner {\r\n        massUpdatePools();\r\n        lhbPerBlock = _lhbPerBlock;\r\n    }\r\n\r\n    // Add a new lp to the pool. Can only be called by the owner.\r\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\r\n    function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner {\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\r\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\r\n        poolInfo.push(PoolInfo({\r\n            lpToken: _lpToken,\r\n            allocPoint: _allocPoint,\r\n            lastRewardBlock: lastRewardBlock,\r\n            accLHBPerShare: 0\r\n        }));\r\n    }\r\n\r\n    // Update the given pool's LHB allocation point. Can only be called by the owner.\r\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner {\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\r\n        poolInfo[_pid].allocPoint = _allocPoint;\r\n    }\r\n\r\n    // Return reward multiplier over the given _from to _to block.\r\n    function getMultiplier(uint256 _from, uint256 _to) public pure returns (uint256) {\r\n        return _to.sub(_from);\r\n    }\r\n\r\n    // View function to see pending SUSHIs on frontend.\r\n    function pendingLHB(uint256 _pid, address _user) external view returns (uint256) {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        uint256 accLHBPerShare = pool.accLHBPerShare;\r\n        uint256 lpSupply = 0;\r\n        if (address(pool.lpToken) == address(lhb)) {\r\n             lpSupply = userLHBAmount;\r\n        } else {\r\n            lpSupply = pool.lpToken.balanceOf(address(this));\r\n        }\r\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\r\n            uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\r\n            uint256 sushiReward = multiplier.mul(lhbPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\r\n            accLHBPerShare = accLHBPerShare.add(sushiReward.mul(1e12).div(lpSupply));\r\n        }\r\n        return user.amount.mul(accLHBPerShare).div(1e12).sub(user.rewardDebt);\r\n    }\r\n\r\n    // Update reward variables for all pools. Be careful of gas spending!\r\n    function massUpdatePools() public {\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            updatePool(pid);\r\n        }\r\n    }\r\n\r\n    // Update reward variables of the given pool to be up-to-date.\r\n    function updatePool(uint256 _pid) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (block.number <= pool.lastRewardBlock) {\r\n            return;\r\n        }\r\n        uint256 lpSupply = 0;\r\n        if (address(pool.lpToken) == address(lhb)) {\r\n            lpSupply = userLHBAmount;\r\n        } else {\r\n            lpSupply = pool.lpToken.balanceOf(address(this));\r\n        }\r\n        if (lpSupply == 0) {\r\n            pool.lastRewardBlock = block.number;\r\n            return;\r\n        }\r\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\r\n        uint256 sushiReward = multiplier.mul(lhbPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\r\n        pool.accLHBPerShare = pool.accLHBPerShare.add(sushiReward.mul(1e12).div(lpSupply));\r\n        pool.lastRewardBlock = block.number;\r\n    }\r\n\r\n    // Deposit LP tokens to MasterChef for LHB allocation.\r\n    function deposit(uint256 _pid, uint256 _amount) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        updatePool(_pid);\r\n        if (user.amount > 0) {\r\n            uint256 pending = user.amount.mul(pool.accLHBPerShare).div(1e12).sub(user.rewardDebt);\r\n            if(pending > 0) {\r\n                safeLHBTransfer(msg.sender, pending);\r\n            }\r\n        }\r\n        if(_amount > 0) {\r\n            pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\r\n            user.amount = user.amount.add(_amount);\r\n            if (address(pool.lpToken) == address(lhb)) {\r\n                userLHBAmount = userLHBAmount.add(_amount);\r\n            }\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accLHBPerShare).div(1e12);\r\n        emit Deposit(msg.sender, _pid, _amount);\r\n    }\r\n\r\n    // Withdraw LP tokens from MasterChef.\r\n    function withdraw(uint256 _pid, uint256 _amount) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        require(user.amount >= _amount, \"withdraw: not good\");\r\n        updatePool(_pid);\r\n        uint256 pending = user.amount.mul(pool.accLHBPerShare).div(1e12).sub(user.rewardDebt);\r\n        if(pending > 0) {\r\n            safeLHBTransfer(msg.sender, pending);\r\n        }\r\n        if(_amount > 0) {\r\n            user.amount = user.amount.sub(_amount);\r\n            if (address(pool.lpToken) == address(lhb)) {\r\n                userLHBAmount = userLHBAmount.sub(_amount);\r\n            }\r\n            pool.lpToken.safeTransfer(address(msg.sender), _amount);\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accLHBPerShare).div(1e12);\r\n        emit Withdraw(msg.sender, _pid, _amount);\r\n    }\r\n\r\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\r\n    function emergencyWithdraw(uint256 _pid) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        uint256 amount = user.amount;\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n        if (address(pool.lpToken) == address(lhb)) {\r\n            userLHBAmount = userLHBAmount.sub(amount);\r\n        }\r\n        pool.lpToken.safeTransfer(address(msg.sender), amount);\r\n        emit EmergencyWithdraw(msg.sender, _pid, amount);\r\n    }\r\n\r\n    // Safe lhb transfer function, just in case if rounding error causes pool to not have enough LHBs.\r\n    function safeLHBTransfer(address _to, uint256 _amount) internal {\r\n        uint256 lhbBalance = lhb.balanceOf(address(this));\r\n        lhbBalance = lhbBalance.sub(userLHBAmount);\r\n        if (_amount > lhbBalance) {\r\n            lhb.transfer(_to, lhbBalance);\r\n        } else {\r\n            lhb.transfer(_to, _amount);\r\n        }\r\n    }\r\n\r\n    function grantCompInternal(address _to, uint _amount) internal returns (uint) {\r\n        uint lhbBalance = lhb.balanceOf(address(this));\r\n        lhbBalance = lhbBalance.sub(userLHBAmount);\r\n        if (_amount <= lhbBalance) {\r\n            lhb.transfer(_to, _amount);\r\n            return 0;\r\n        }\r\n        return _amount;\r\n    }\r\n\r\n    function _grantComp(address recipient, uint amount) public onlyOwner {\r\n        uint amountLeft = grantCompInternal(recipient, amount);\r\n        require(amountLeft == 0, \"insufficient LHB for grant\");\r\n    }\r\n}\r\n"
    },
    "contracts/compound/Governance/LendHub.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\npragma experimental ABIEncoderV2;\r\n// pragma abicoder v2;\r\n\r\ncontract LendHub {\r\n    /// @notice EIP-20 token name for this token\r\n    string public constant name = \"LendHub\";\r\n\r\n    /// @notice EIP-20 token symbol for this token\r\n    string public constant symbol = \"LHB\";\r\n\r\n    /// @notice EIP-20 token decimals for this token\r\n    uint8 public constant decimals = 18;\r\n\r\n    /// @notice Total number of tokens in circulation\r\n    uint public constant totalSupply = 1000000000e18; // 1 billion LHB\r\n\r\n    // @notice Allowance amounts on behalf of others\r\n    mapping (address => mapping (address => uint96)) internal allowances;\r\n\r\n    // @notice Official record of token balances for each account\r\n    mapping (address => uint96) internal balances;\r\n\r\n    /// @notice A record of each accounts delegate\r\n    mapping (address => address) public delegates;\r\n\r\n    /// @notice A checkpoint for marking number of votes from a given block\r\n    struct Checkpoint {\r\n        uint32 fromBlock;\r\n        uint96 votes;\r\n    }\r\n\r\n    /// @notice A record of votes checkpoints for each account, by index\r\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\r\n\r\n    /// @notice The number of checkpoints for each account\r\n    mapping (address => uint32) public numCheckpoints;\r\n\r\n    /// @notice The EIP-712 typehash for the contract's domain\r\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n\r\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\r\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\r\n\r\n    /// @notice A record of states for signing / validating signatures\r\n    mapping (address => uint) public nonces;\r\n\r\n    /// @notice An event thats emitted when an account changes its delegate\r\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\r\n\r\n    /// @notice An event thats emitted when a delegate account's vote balance changes\r\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\r\n\r\n    /// @notice The standard EIP-20 transfer event\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    /// @notice The standard EIP-20 approval event\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /**\r\n     * @notice Construct a new LendHub token\r\n     * @param account The initial account to grant all the tokens\r\n     */\r\n    constructor(address account) public {\r\n        balances[account] = uint96(totalSupply);\r\n        emit Transfer(address(0), account, totalSupply);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\r\n     * @param account The address of the account holding the funds\r\n     * @param spender The address of the account spending the funds\r\n     * @return The number of tokens approved\r\n     */\r\n    function allowance(address account, address spender) external view returns (uint) {\r\n        return allowances[account][spender];\r\n    }\r\n\r\n    /**\r\n     * @notice Approve `spender` to transfer up to `amount` from `src`\r\n     * @dev This will overwrite the approval amount for `spender`\r\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\r\n     * @param spender The address of the account which may transfer tokens\r\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\r\n     * @return Whether or not the approval succeeded\r\n     */\r\n    function approve(address spender, uint rawAmount) external returns (bool) {\r\n        uint96 amount;\r\n        if (rawAmount == uint(-1)) {\r\n            amount = uint96(-1);\r\n        } else {\r\n            amount = safe96(rawAmount, \"Lend::approve: amount exceeds 96 bits\");\r\n        }\r\n\r\n        allowances[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the number of tokens held by the `account`\r\n     * @param account The address of the account to get the balance of\r\n     * @return The number of tokens held\r\n     */\r\n    function balanceOf(address account) external view returns (uint) {\r\n        return balances[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n     * @param dst The address of the destination account\r\n     * @param rawAmount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transfer(address dst, uint rawAmount) external returns (bool) {\r\n        uint96 amount = safe96(rawAmount, \"Lend::transfer: amount exceeds 96 bits\");\r\n        _transferTokens(msg.sender, dst, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `src` to `dst`\r\n     * @param src The address of the source account\r\n     * @param dst The address of the destination account\r\n     * @param rawAmount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transferFrom(address src, address dst, uint rawAmount) external returns (bool) {\r\n        address spender = msg.sender;\r\n        uint96 spenderAllowance = allowances[src][spender];\r\n        uint96 amount = safe96(rawAmount, \"Lend::approve: amount exceeds 96 bits\");\r\n\r\n        if (spender != src && spenderAllowance != uint96(-1)) {\r\n            uint96 newAllowance = sub96(spenderAllowance, amount, \"Lend::transferFrom: transfer amount exceeds spender allowance\");\r\n            allowances[src][spender] = newAllowance;\r\n\r\n            emit Approval(src, spender, newAllowance);\r\n        }\r\n\r\n        _transferTokens(src, dst, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Delegate votes from `msg.sender` to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     */\r\n    function delegate(address delegatee) public {\r\n        return _delegate(msg.sender, delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates votes from signatory to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     * @param nonce The contract state required to match the signature\r\n     * @param expiry The time at which to expire the signature\r\n     * @param v The recovery byte of the signature\r\n     * @param r Half of the ECDSA signature pair\r\n     * @param s Half of the ECDSA signature pair\r\n     */\r\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {\r\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\r\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\r\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n        address signatory = ecrecover(digest, v, r, s);\r\n        require(signatory != address(0), \"Lend::delegateBySig: invalid signature\");\r\n        require(nonce == nonces[signatory]++, \"Lend::delegateBySig: invalid nonce\");\r\n        // require(now <= expiry, \"Lend::delegateBySig: signature expired\");\r\n        require(block.timestamp <= expiry, \"Lend::delegateBySig: signature expired\");\r\n        return _delegate(signatory, delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current votes balance for `account`\r\n     * @param account The address to get votes balance\r\n     * @return The number of current votes for `account`\r\n     */\r\n    function getCurrentVotes(address account) external view returns (uint96) {\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the prior number of votes for an account as of a block number\r\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\r\n     * @param account The address of the account to check\r\n     * @param blockNumber The block number to get the vote balance at\r\n     * @return The number of votes the account had as of the given block\r\n     */\r\n    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\r\n        require(blockNumber < block.number, \"Lend::getPriorVotes: not yet determined\");\r\n\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        if (nCheckpoints == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // First check most recent balance\r\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\r\n            return checkpoints[account][nCheckpoints - 1].votes;\r\n        }\r\n\r\n        // Next check implicit zero balance\r\n        if (checkpoints[account][0].fromBlock > blockNumber) {\r\n            return 0;\r\n        }\r\n\r\n        uint32 lower = 0;\r\n        uint32 upper = nCheckpoints - 1;\r\n        while (upper > lower) {\r\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\r\n            Checkpoint memory cp = checkpoints[account][center];\r\n            if (cp.fromBlock == blockNumber) {\r\n                return cp.votes;\r\n            } else if (cp.fromBlock < blockNumber) {\r\n                lower = center;\r\n            } else {\r\n                upper = center - 1;\r\n            }\r\n        }\r\n        return checkpoints[account][lower].votes;\r\n    }\r\n\r\n    function _delegate(address delegator, address delegatee) internal {\r\n        address currentDelegate = delegates[delegator];\r\n        uint96 delegatorBalance = balances[delegator];\r\n        delegates[delegator] = delegatee;\r\n\r\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\r\n\r\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\r\n    }\r\n\r\n    function _transferTokens(address src, address dst, uint96 amount) internal {\r\n        require(src != address(0), \"Lend::_transferTokens: cannot transfer from the zero address\");\r\n        require(dst != address(0), \"Lend::_transferTokens: cannot transfer to the zero address\");\r\n\r\n        balances[src] = sub96(balances[src], amount, \"Lend::_transferTokens: transfer amount exceeds balance\");\r\n        balances[dst] = add96(balances[dst], amount, \"Lend::_transferTokens: transfer amount overflows\");\r\n        emit Transfer(src, dst, amount);\r\n\r\n        _moveDelegates(delegates[src], delegates[dst], amount);\r\n    }\r\n\r\n    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\r\n        if (srcRep != dstRep && amount > 0) {\r\n            if (srcRep != address(0)) {\r\n                uint32 srcRepNum = numCheckpoints[srcRep];\r\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\r\n                uint96 srcRepNew = sub96(srcRepOld, amount, \"Lend::_moveVotes: vote amount underflows\");\r\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\r\n            }\r\n\r\n            if (dstRep != address(0)) {\r\n                uint32 dstRepNum = numCheckpoints[dstRep];\r\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\r\n                uint96 dstRepNew = add96(dstRepOld, amount, \"Lend::_moveVotes: vote amount overflows\");\r\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\r\n        uint32 blockNumber = safe32(block.number, \"Lend::_writeCheckpoint: block number exceeds 32 bits\");\r\n\r\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\r\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\r\n        } else {\r\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\r\n            numCheckpoints[delegatee] = nCheckpoints + 1;\r\n        }\r\n\r\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\r\n    }\r\n\r\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\r\n        require(n < 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\r\n        require(n < 2**96, errorMessage);\r\n        return uint96(n);\r\n    }\r\n\r\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\r\n        uint96 c = a + b;\r\n        require(c >= a, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    function getChainId() internal pure returns (uint) {\r\n        uint256 chainId;\r\n        assembly { chainId := chainid() }\r\n        return chainId;\r\n    }\r\n}\r\n"
    },
    "contracts/compound/lens/LendHubLensLHB.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\npragma experimental ABIEncoderV2;\r\n// pragma abicoder v2;\r\n\r\nimport \"../LErc20.sol\";\r\nimport \"../CToken.sol\";\r\nimport \"../PriceOracle.sol\";\r\nimport \"../EIP20Interface.sol\";\r\nimport \"../Governance/LendHub.sol\";\r\nimport \"../SimplePriceOracle.sol\";\r\n\r\ninterface ComptrollerLensInterface {\r\n\r\n    function compSpeeds(address) external view returns (uint);\r\n    function compSupplyState(address) external view returns(uint224, uint32);\r\n    function compBorrowState(address) external view returns(uint224, uint32);\r\n    function compSupplierIndex(address, address) external view returns (uint);\r\n    function compBorrowerIndex(address, address) external view returns (uint);\r\n\r\n    function markets(address) external view returns (bool, uint);\r\n    function oracle() external view returns (PriceOracle);\r\n    function getAccountLiquidity(address) external view returns (uint, uint, uint);\r\n    function getAssetsIn(address) external view returns (CToken[] memory);\r\n    function claimComp(address) external;\r\n    function compAccrued(address) external view returns (uint);\r\n    function getCompAddress() external view returns (address);\r\n}\r\n\r\ncontract LendHubLensLHB is ExponentialNoError {\r\n    struct CTokenLHBData {\r\n        address cToken;\r\n        uint supplyLHBAPY;\r\n        uint borrowLHBAPY;\r\n    }\r\n\r\n    function cTokenLHBMetadata(CToken cToken) view public returns (CTokenLHBData memory) {\r\n        ComptrollerLensInterface comptroller = ComptrollerLensInterface(address(cToken.comptroller()));\r\n        uint speed = comptroller.compSpeeds(address(cToken));\r\n        SimplePriceOracle priceOracle = SimplePriceOracle(address(comptroller.oracle()));\r\n        uint lhbPrice = priceOracle.assetPrices(comptroller.getCompAddress());\r\n        // 24位小数\r\n        uint exchangeRateCurrent = cToken.exchangeRateStored();\r\n        uint totalPrice = cToken.totalSupply() * exchangeRateCurrent * priceOracle.getUnderlyingPrice(cToken);\r\n        uint supplyAPY = 1000000000000000000 * 1000000 * 10512000 * speed * lhbPrice / totalPrice;\r\n        uint totalBorrowPrice = cToken.totalBorrows() * priceOracle.getUnderlyingPrice(cToken);\r\n        uint borrowLHBAPY = 1000000 * 10512000 * speed * lhbPrice / totalBorrowPrice;\r\n\r\n        return CTokenLHBData({\r\n            cToken: address(cToken),\r\n            supplyLHBAPY: supplyAPY,\r\n            borrowLHBAPY: borrowLHBAPY\r\n            });\r\n    }\r\n\r\n    function calcLHBAPYs(CToken[] memory cTokens) public view returns (CTokenLHBData[] memory)  {\r\n        uint cTokenCount = cTokens.length;\r\n        CTokenLHBData[] memory res = new CTokenLHBData[](cTokenCount);\r\n\r\n        for (uint i = 0; i < cTokenCount; i++) {\r\n            CToken cToken = cTokens[i];\r\n            res[i] = cTokenLHBMetadata(cToken);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n"
    },
    "contracts/compound/LErc20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\nimport \"./CToken.sol\";\r\n\r\n/**\r\n * @title LendHub's LErc20 Contract\r\n * @notice CTokens which wrap an EIP-20 underlying\r\n * @author LendHub\r\n */\r\ncontract LErc20 is CToken, CErc20Interface {\r\n    /**\r\n     * @notice Initialize the new money market\r\n     * @param underlying_ The address of the underlying asset\r\n     * @param comptroller_ The address of the Comptroller\r\n     * @param interestRateModel_ The address of the interest rate model\r\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\r\n     * @param name_ ERC-20 name of this token\r\n     * @param symbol_ ERC-20 symbol of this token\r\n     * @param decimals_ ERC-20 decimal precision of this token\r\n     */\r\n    function initialize(address underlying_,\r\n                        ComptrollerInterface comptroller_,\r\n                        InterestRateModel interestRateModel_,\r\n                        uint initialExchangeRateMantissa_,\r\n                        string memory name_,\r\n                        string memory symbol_,\r\n                        uint8 decimals_) public {\r\n        // CToken initialize does the bulk of the work\r\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\r\n        // Set underlying and sanity check it\r\n        underlying = underlying_;\r\n        EIP20Interface(underlying).totalSupply();\r\n    }\r\n\r\n    /*** User Interface ***/\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function mint(uint mintAmount) external returns (uint) {\r\n        (uint err,) = mintInternal(mintAmount);\r\n        return err;\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems cTokens in exchange for the underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemTokens The number of cTokens to redeem into underlying\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeem(uint redeemTokens) external returns (uint) {\r\n        return redeemInternal(redeemTokens);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemAmount The amount of underlying to redeem\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\r\n        return redeemUnderlyingInternal(redeemAmount);\r\n    }\r\n\r\n    /**\r\n      * @notice Sender borrows assets from the protocol to their own address\r\n      * @param borrowAmount The amount of the underlying asset to borrow\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function borrow(uint borrowAmount) external returns (uint) {\r\n        return borrowInternal(borrowAmount);\r\n    }\r\n\r\n    /**\r\n     *  @notice 流动性杠杆借贷, 用户杠杆借款由 margin 合约代持, 并由 margin 合约负责清算\r\n     *          只能由 marignLP 合约调用\r\n     *  @param borrowAmount 要借贷的数量\r\n     */\r\n    function borrowLPMargin(address borrower, uint borrowAmount) external returns (uint) {\r\n        // todo\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     *  @notice swap 杠杆借贷, 用户杠杆借款由 margin 合约代持, 并由 margin 合约负责清算\r\n     *          只能由 marignSWAP 合约调用\r\n     *  @param borrowAmount 要借贷的数量\r\n     */\r\n    function borrowSwapMargin(address borrower, uint borrowAmount) external returns (uint) {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Sender repays their own borrow\r\n     * @param repayAmount The amount to repay\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function repayBorrow(uint repayAmount) external returns (uint) {\r\n        (uint err,) = repayBorrowInternal(repayAmount);\r\n        return err;\r\n    }\r\n\r\n    /**\r\n     * @notice Sender repays a borrow belonging to borrower\r\n     * @param borrower the account with the debt being payed off\r\n     * @param repayAmount The amount to repay\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\r\n        (uint err,) = repayBorrowBehalfInternal(borrower, repayAmount);\r\n        return err;\r\n    }\r\n\r\n    /**\r\n     * @notice The sender liquidates the borrowers collateral.\r\n     *  The collateral seized is transferred to the liquidator.\r\n     * @param borrower The borrower of this cToken to be liquidated\r\n     * @param repayAmount The amount of the underlying borrowed asset to repay\r\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function liquidateBorrow(address borrower,\r\n                        uint repayAmount,\r\n                        CTokenInterface cTokenCollateral) external returns (uint) {\r\n        (uint err,) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\r\n        return err;\r\n    }\r\n\r\n    /**\r\n     * @notice The sender adds to reserves.\r\n     * @param addAmount The amount fo underlying token to add as reserves\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _addReserves(uint addAmount) external returns (uint) {\r\n        return _addReservesInternal(addAmount);\r\n    }\r\n\r\n    /*** Safe Token ***/\r\n\r\n    /**\r\n     * @notice Gets balance of this contract in terms of the underlying\r\n     * @dev This excludes the value of the current message, if any\r\n     * @return The quantity of underlying tokens owned by this contract\r\n     */\r\n    function getCashPrior() internal view returns (uint) {\r\n        EIP20Interface token = EIP20Interface(underlying);\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\r\n     *      This will revert due to insufficient balance or insufficient allowance.\r\n     *      This function returns the actual amount received,\r\n     *      which may be less than `amount` if there is a fee attached to the transfer.\r\n     *\r\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\r\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n     */\r\n    function doTransferIn(address from, uint amount) internal returns (uint) {\r\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\r\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\r\n        console.log('balanceBefore:', EIP20Interface(underlying).balanceOf(from));\r\n        console.log('spender:', address(this));\r\n        console.log('from:', from);\r\n        console.log('allowance:', EIP20Interface(underlying).allowance(from, address(this))); // transferAllowances[from][address(this)], amount);\r\n        token.transferFrom(from, address(this), amount);\r\n\r\n        bool success;\r\n        assembly {\r\n            switch returndatasize()\r\n                case 0 {                       // This is a non-standard ERC-20\r\n                    success := not(0)          // set success to true\r\n                }\r\n                case 32 {                      // This is a compliant ERC-20\r\n                    returndatacopy(0, 0, 32)\r\n                    success := mload(0)        // Set `success = returndata` of external call\r\n                }\r\n                default {                      // This is an excessively non-compliant ERC-20, revert.\r\n                    revert(0, 0)\r\n                }\r\n        }\r\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\r\n\r\n        // Calculate the amount that was *actually* transferred\r\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\r\n        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\r\n        console.log(\"doTransferIn success\");\r\n        return balanceAfter - balanceBefore;   // underflow already checked above, just subtract\r\n    }\r\n\r\n    /**\r\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\r\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\r\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\r\n     *      it is >= amount, this should not revert in normal conditions.\r\n     *\r\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\r\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n     */\r\n    function doTransferOut(address payable to, uint amount) internal {\r\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\r\n        token.transfer(to, amount);\r\n\r\n        bool success;\r\n        assembly {\r\n            switch returndatasize()\r\n                case 0 {                      // This is a non-standard ERC-20\r\n                    success := not(0)          // set success to true\r\n                }\r\n                case 32 {                     // This is a complaint ERC-20\r\n                    returndatacopy(0, 0, 32)\r\n                    success := mload(0)        // Set `success = returndata` of external call\r\n                }\r\n                default {                     // This is an excessively non-compliant ERC-20, revert.\r\n                    revert(0, 0)\r\n                }\r\n        }\r\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\r\n    }\r\n}\r\n"
    },
    "contracts/compound/PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\nimport \"./CToken.sol\";\r\n\r\ncontract PriceOracle {\r\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\r\n    bool public constant isPriceOracle = true;\r\n\r\n    /**\r\n      * @notice Get the underlying price of a cToken asset\r\n      * @param cToken The cToken to get the underlying price of\r\n      * @return The underlying asset price mantissa (scaled by 1e18).\r\n      *  Zero means the price is unavailable.\r\n      */\r\n    function getUnderlyingPrice(CToken cToken) external view returns (uint);\r\n}\r\n"
    },
    "contracts/compound/SimplePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\nimport \"./PriceOracle.sol\";\r\nimport \"./LErc20.sol\";\r\n\r\ncontract SimplePriceOracle is PriceOracle {\r\n    mapping(address => uint) prices;\r\n    uint baseTokenPrice;\r\n    string public baseSymbol;\r\n\r\n    address admin;\r\n    event PricePosted(address asset, uint previousPriceMantissa, uint requestedPriceMantissa, uint newPriceMantissa);\r\n\r\n    constructor(string memory symbol) public {\r\n        admin = msg.sender;\r\n        baseSymbol = symbol;\r\n    }\r\n\r\n    function getUnderlyingPrice(CToken cToken) public view returns (uint) {\r\n        if (compareStrings(cToken.symbol(), baseSymbol)) {\r\n            return baseTokenPrice;\r\n        } else {\r\n            return prices[address(LErc20(address(cToken)).underlying())];\r\n        }\r\n    }\r\n\r\n    function setUnderlyingPrice(CToken cToken, uint underlyingPriceMantissa) public {\r\n        require(msg.sender == admin, \"only the admin may call setUnderlyingPrice\");\r\n        if (compareStrings(cToken.symbol(), baseSymbol)) {\r\n            baseTokenPrice = underlyingPriceMantissa;\r\n        } else {\r\n            address asset = address(LErc20(address(cToken)).underlying());\r\n            emit PricePosted(asset, prices[asset], underlyingPriceMantissa, underlyingPriceMantissa);\r\n            prices[asset] = underlyingPriceMantissa;\r\n        }\r\n    }\r\n\r\n    function setDirectPrice(address asset, uint price) public {\r\n        require(msg.sender == admin, \"only the admin may call setDirectPrice\");\r\n        emit PricePosted(asset, prices[asset], price, price);\r\n        prices[asset] = price;\r\n    }\r\n\r\n    function changeAdmin(address newAdmin) public {\r\n        require(msg.sender == admin, \"only the admin may call changeAdmin\");\r\n        admin = newAdmin;\r\n    }\r\n\r\n    // v1 price oracle interface for use as backing of proxy\r\n    function assetPrices(address asset) external view returns (uint) {\r\n        return prices[asset];\r\n    }\r\n\r\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\r\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\r\n    }\r\n\r\n    function setSymbol(string memory symbol) public {\r\n        require(msg.sender == admin, \"only the admin may call changeAdmin\");\r\n        baseSymbol = symbol;\r\n    }\r\n}\r\n\r\n"
    },
    "contracts/compound/LErc20Immutable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\nimport \"./LErc20.sol\";\r\n\r\n/**\r\n * @title LendHub's CErc20Immutable Contract\r\n * @notice CTokens which wrap an EIP-20 underlying and are immutable\r\n * @author LendHub\r\n */\r\ncontract LErc20Immutable is LErc20 {\r\n    /**\r\n     * @notice Construct La new money market\r\n     * @param underlying_ The address of the underlying asset\r\n     * @param comptroller_ The address of the Comptroller\r\n     * @param interestRateModel_ The address of the interest rate model\r\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\r\n     * @param name_ ERC-20 name of this token\r\n     * @param symbol_ ERC-20 symbol of this token\r\n     * @param decimals_ ERC-20 decimal precision of this token\r\n     * @param admin_ Address of the administrator of this token\r\n     */\r\n    constructor(address underlying_,\r\n                ComptrollerInterface comptroller_,\r\n                InterestRateModel interestRateModel_,\r\n                uint initialExchangeRateMantissa_,\r\n                string memory name_,\r\n                string memory symbol_,\r\n                uint8 decimals_,\r\n                address payable admin_) public {\r\n        // Creator of the contract is admin during initialization\r\n        admin = msg.sender;\r\n\r\n        // Initialize the market\r\n        initialize(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\r\n\r\n        // Set the proper admin now that initialization is done\r\n        admin = admin_;\r\n    }\r\n}\r\n"
    },
    "contracts/compound/LErc20Delegate.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\nimport \"./LErc20.sol\";\r\n\r\n/**\r\n * @title Compound's CErc20Delegate Contract\r\n * @notice CTokens which wrap an EIP-20 underlying and are delegated to\r\n * @author Compound\r\n */\r\ncontract LErc20Delegate is LErc20, CDelegateInterface {\r\n    /**\r\n     * @notice Construct an empty delegate\r\n     */\r\n    constructor() public {}\r\n\r\n    /**\r\n     * @notice Called by the delegator on a delegate to initialize it for duty\r\n     * @param data The encoded bytes data for any initialization\r\n     */\r\n    function _becomeImplementation(bytes memory data) public {\r\n        // Shh -- currently unused\r\n        data;\r\n\r\n        // Shh -- we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            implementation = address(0);\r\n        }\r\n\r\n        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\r\n    }\r\n\r\n    /**\r\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\r\n     */\r\n    function _resignImplementation() public {\r\n        // Shh -- we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            implementation = address(0);\r\n        }\r\n\r\n        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\r\n    }\r\n}\r\n"
    },
    "contracts/compound/lens/LendHubLens.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\npragma experimental ABIEncoderV2;\r\n// pragma abicoder v2;\r\n\r\nimport \"../LErc20.sol\";\r\nimport \"../CToken.sol\";\r\nimport \"../PriceOracle.sol\";\r\nimport \"../EIP20Interface.sol\";\r\nimport \"../Governance/LendHub.sol\";\r\n\r\ninterface ComptrollerLensInterface {\r\n    function markets(address) external view returns (bool, uint);\r\n    function oracle() external view returns (PriceOracle);\r\n    function getAccountLiquidity(address) external view returns (uint, uint, uint);\r\n    function getAssetsIn(address) external view returns (CToken[] memory);\r\n    function claimComp(address) external;\r\n    function compAccrued(address) external view returns (uint);\r\n}\r\n\r\ncontract LendHubLens {\r\n    struct CTokenMetadata {\r\n        address cToken;\r\n        uint exchangeRateCurrent;\r\n        uint supplyRatePerBlock;\r\n        uint borrowRatePerBlock;\r\n        uint reserveFactorMantissa;\r\n        uint totalBorrows;\r\n        uint totalReserves;\r\n        uint totalSupply;\r\n        uint totalCash;\r\n        bool isListed;\r\n        uint collateralFactorMantissa;\r\n        address underlyingAssetAddress;\r\n        uint cTokenDecimals;\r\n        uint underlyingDecimals;\r\n    }\r\n\r\n    function cTokenMetadata(CToken cToken) public returns (CTokenMetadata memory) {\r\n        uint exchangeRateCurrent = cToken.exchangeRateCurrent();\r\n        ComptrollerLensInterface comptroller = ComptrollerLensInterface(address(cToken.comptroller()));\r\n        (bool isListed, uint collateralFactorMantissa) = comptroller.markets(address(cToken));\r\n        address underlyingAssetAddress;\r\n        uint underlyingDecimals;\r\n\r\n        if (compareStrings(cToken.symbol(), \"lHT\")) {\r\n            underlyingAssetAddress = address(0);\r\n            underlyingDecimals = 18;\r\n        } else {\r\n            LErc20 lErc20 = LErc20(address(cToken));\r\n            underlyingAssetAddress = lErc20.underlying();\r\n            underlyingDecimals = EIP20Interface(lErc20.underlying()).decimals();\r\n        }\r\n\r\n        return CTokenMetadata({\r\n            cToken: address(cToken),\r\n            exchangeRateCurrent: exchangeRateCurrent,\r\n            supplyRatePerBlock: cToken.supplyRatePerBlock(),\r\n            borrowRatePerBlock: cToken.borrowRatePerBlock(),\r\n            reserveFactorMantissa: cToken.reserveFactorMantissa(),\r\n            totalBorrows: cToken.totalBorrows(),\r\n            totalReserves: cToken.totalReserves(),\r\n            totalSupply: cToken.totalSupply(),\r\n            totalCash: cToken.getCash(),\r\n            isListed: isListed,\r\n            collateralFactorMantissa: collateralFactorMantissa,\r\n            underlyingAssetAddress: underlyingAssetAddress,\r\n            cTokenDecimals: cToken.decimals(),\r\n            underlyingDecimals: underlyingDecimals\r\n        });\r\n    }\r\n\r\n    function cTokenMetadataAll(CToken[] calldata cTokens) external returns (CTokenMetadata[] memory) {\r\n        uint cTokenCount = cTokens.length;\r\n        CTokenMetadata[] memory res = new CTokenMetadata[](cTokenCount);\r\n        for (uint i = 0; i < cTokenCount; i++) {\r\n            res[i] = cTokenMetadata(cTokens[i]);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    struct CTokenBalances {\r\n        address cToken;\r\n        uint balanceOf;\r\n        uint borrowBalanceCurrent;\r\n        uint balanceOfUnderlying;\r\n        uint tokenBalance;\r\n        uint tokenAllowance;\r\n    }\r\n\r\n    function cTokenBalances(CToken cToken, address payable account) public returns (CTokenBalances memory) {\r\n        uint balanceOf = cToken.balanceOf(account);\r\n        uint borrowBalanceCurrent = cToken.borrowBalanceCurrent(account);\r\n        uint balanceOfUnderlying = cToken.balanceOfUnderlying(account);\r\n        uint tokenBalance;\r\n        uint tokenAllowance;\r\n\r\n        if (compareStrings(cToken.symbol(), \"lHT\")) {\r\n            tokenBalance = account.balance;\r\n            tokenAllowance = account.balance;\r\n        } else {\r\n            LErc20 lErc20 = LErc20(address(cToken));\r\n            EIP20Interface underlying = EIP20Interface(lErc20.underlying());\r\n            tokenBalance = underlying.balanceOf(account);\r\n            tokenAllowance = underlying.allowance(account, address(cToken));\r\n        }\r\n\r\n        return CTokenBalances({\r\n            cToken: address(cToken),\r\n            balanceOf: balanceOf,\r\n            borrowBalanceCurrent: borrowBalanceCurrent,\r\n            balanceOfUnderlying: balanceOfUnderlying,\r\n            tokenBalance: tokenBalance,\r\n            tokenAllowance: tokenAllowance\r\n        });\r\n    }\r\n\r\n    function cTokenBalancesAll(CToken[] calldata cTokens, address payable account) external returns (CTokenBalances[] memory) {\r\n        uint cTokenCount = cTokens.length;\r\n        CTokenBalances[] memory res = new CTokenBalances[](cTokenCount);\r\n        for (uint i = 0; i < cTokenCount; i++) {\r\n            res[i] = cTokenBalances(cTokens[i], account);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    struct CTokenUnderlyingPrice {\r\n        address cToken;\r\n        uint underlyingPrice;\r\n    }\r\n\r\n    function cTokenUnderlyingPrice(CToken cToken) public view returns (CTokenUnderlyingPrice memory) {\r\n        ComptrollerLensInterface comptroller = ComptrollerLensInterface(address(cToken.comptroller()));\r\n        PriceOracle priceOracle = comptroller.oracle();\r\n\r\n        return CTokenUnderlyingPrice({\r\n            cToken: address(cToken),\r\n            underlyingPrice: priceOracle.getUnderlyingPrice(cToken)\r\n        });\r\n    }\r\n\r\n    function cTokenUnderlyingPriceAll(CToken[] calldata cTokens) external view returns (CTokenUnderlyingPrice[] memory) {\r\n        uint cTokenCount = cTokens.length;\r\n        CTokenUnderlyingPrice[] memory res = new CTokenUnderlyingPrice[](cTokenCount);\r\n        for (uint i = 0; i < cTokenCount; i++) {\r\n            res[i] = cTokenUnderlyingPrice(cTokens[i]);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    struct AccountLimits {\r\n        CToken[] markets;\r\n        uint liquidity;\r\n        uint shortfall;\r\n    }\r\n\r\n    function getAccountLimits(ComptrollerLensInterface comptroller, address account) public view returns (AccountLimits memory) {\r\n        (uint errorCode, uint liquidity, uint shortfall) = comptroller.getAccountLiquidity(account);\r\n        require(errorCode == 0);\r\n\r\n        return AccountLimits({\r\n            markets: comptroller.getAssetsIn(account),\r\n            liquidity: liquidity,\r\n            shortfall: shortfall\r\n        });\r\n    }\r\n\r\n    struct CompBalanceMetadata {\r\n        uint balance;\r\n        uint votes;\r\n        address delegate;\r\n    }\r\n\r\n    function getCompBalanceMetadata(LendHub lhb, address account) external view returns (CompBalanceMetadata memory) {\r\n        return CompBalanceMetadata({\r\n            balance: lhb.balanceOf(account),\r\n            votes: uint256(lhb.getCurrentVotes(account)),\r\n            delegate: lhb.delegates(account)\r\n        });\r\n    }\r\n\r\n    struct CompBalanceMetadataExt {\r\n        uint balance;\r\n        uint votes;\r\n        address delegate;\r\n        uint allocated;\r\n    }\r\n\r\n    function getCompBalanceMetadataExt(LendHub lhb, ComptrollerLensInterface comptroller, address account) external returns (CompBalanceMetadataExt memory) {\r\n        uint balance = lhb.balanceOf(account);\r\n        comptroller.claimComp(account);\r\n        uint newBalance = lhb.balanceOf(account);\r\n        uint accrued = comptroller.compAccrued(account);\r\n        uint total = add(accrued, newBalance, \"sum LHB total\");\r\n        uint allocated = sub(total, balance, \"sub allocated\");\r\n\r\n        return CompBalanceMetadataExt({\r\n            balance: balance,\r\n            votes: uint256(lhb.getCurrentVotes(account)),\r\n            delegate: lhb.delegates(account),\r\n            allocated: allocated\r\n        });\r\n    }\r\n\r\n    struct CompVotes {\r\n        uint blockNumber;\r\n        uint votes;\r\n    }\r\n\r\n    function getCompVotes(LendHub lhb, address account, uint32[] calldata blockNumbers) external view returns (CompVotes[] memory) {\r\n        CompVotes[] memory res = new CompVotes[](blockNumbers.length);\r\n        for (uint i = 0; i < blockNumbers.length; i++) {\r\n            res[i] = CompVotes({\r\n                blockNumber: uint256(blockNumbers[i]),\r\n                votes: uint256(lhb.getPriorVotes(account, blockNumbers[i]))\r\n            });\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\r\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\r\n    }\r\n\r\n    function add(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        require(b <= a, errorMessage);\r\n        uint c = a - b;\r\n        return c;\r\n    }\r\n}\r\n"
    },
    "contracts/compound/Reservoir.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\n/**\r\n * @title Reservoir Contract\r\n * @notice Distributes a token to a different contract at a fixed rate.\r\n * @dev This contract must be poked via the `drip()` function every so often.\r\n * @author Compound\r\n */\r\ncontract Reservoir {\r\n\r\n  /// @notice The block number when the Reservoir started (immutable)\r\n  uint public dripStart;\r\n\r\n  /// @notice Tokens per block that to drip to target (immutable)\r\n  uint public dripRate;\r\n\r\n  /// @notice Reference to token to drip (immutable)\r\n  EIP20Interface public token;\r\n\r\n  /// @notice Target to receive dripped tokens (immutable)\r\n  address public target;\r\n\r\n  /// @notice Amount that has already been dripped\r\n  uint public dripped;\r\n\r\n  /**\r\n    * @notice Constructs a Reservoir\r\n    * @param dripRate_ Numer of tokens per block to drip\r\n    * @param token_ The token to drip\r\n    * @param target_ The recipient of dripped tokens\r\n    */\r\n  constructor(uint dripRate_, EIP20Interface token_, address target_) public {\r\n    dripStart = block.number;\r\n    dripRate = dripRate_;\r\n    token = token_;\r\n    target = target_;\r\n    dripped = 0;\r\n  }\r\n\r\n  /**\r\n    * @notice Drips the maximum amount of tokens to match the drip rate since inception\r\n    * @dev Note: this will only drip up to the amount of tokens available.\r\n    * @return The amount of tokens dripped in this call\r\n    */\r\n  function drip() public returns (uint) {\r\n    // First, read storage into memory\r\n    EIP20Interface token_ = token;\r\n    uint reservoirBalance_ = token_.balanceOf(address(this)); // TODO: Verify this is a static call\r\n    uint dripRate_ = dripRate;\r\n    uint dripStart_ = dripStart;\r\n    uint dripped_ = dripped;\r\n    address target_ = target;\r\n    uint blockNumber_ = block.number;\r\n\r\n    // Next, calculate intermediate values\r\n    uint dripTotal_ = mul(dripRate_, blockNumber_ - dripStart_, \"dripTotal overflow\");\r\n    uint deltaDrip_ = sub(dripTotal_, dripped_, \"deltaDrip underflow\");\r\n    uint toDrip_ = min(reservoirBalance_, deltaDrip_);\r\n    uint drippedNext_ = add(dripped_, toDrip_, \"tautological\");\r\n\r\n    // Finally, write new `dripped` value and transfer tokens to target\r\n    dripped = drippedNext_;\r\n    token_.transfer(target_, toDrip_);\r\n\r\n    return toDrip_;\r\n  }\r\n\r\n  /* Internal helper functions for safe math */\r\n\r\n  function add(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    require(c >= a, errorMessage);\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n    require(b <= a, errorMessage);\r\n    uint c = a - b;\r\n    return c;\r\n  }\r\n\r\n  function mul(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint c = a * b;\r\n    require(c / a == b, errorMessage);\r\n    return c;\r\n  }\r\n\r\n  function min(uint a, uint b) internal pure returns (uint) {\r\n    if (a <= b) {\r\n      return a;\r\n    } else {\r\n      return b;\r\n    }\r\n  }\r\n}\r\n\r\nimport \"./EIP20Interface.sol\";\r\n"
    },
    "contracts/compound/LErc20DelegatorFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.5.16;\r\n\r\nimport \"../common/LErc20DelegatorInterface.sol\";\r\nimport \"./LErc20Delegator.sol\";\r\nimport \"./EIP20Interface.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract LErc20DelegatorFactory is LErc20DelegatorInterface {\r\n    \r\n    event NewDelegator(address token,address delegator);\r\n    bytes32 public initCodeHash;\r\n\r\n    /**\r\n     * @notice Construct\r\n     */\r\n    constructor(address _implementation, address comptroller_, address intersetRateModel) public {\r\n        // Creator of the contract is admin during initialization\r\n        admin_ = msg.sender;\r\n        comptroller = ComptrollerInterface(comptroller_);\r\n        implementation_ = _implementation;\r\n        interestRateModel_ = InterestRateModel(intersetRateModel);\r\n        initCodeHash = keccak256(abi.encodePacked(type(LErc20Delegator).creationCode));\r\n\r\n        // bytes32 0x71a762e9b044ae662a0d792ceaa9aaa4bf09c9ecdd90967035ae11e75f841390\r\n        // console.log('LErc20DelegatorFactory initcode:', initCodeHash);\r\n    }\r\n    \r\n    //可以设置\r\n    ComptrollerInterface public comptroller; // = ComptrollerInterface(0x07D7654836ee31D5Dc20c1Ee9716CCF240fC7BD2);\r\n    //可以设置\r\n    InterestRateModel public interestRateModel_; // = InterestRateModel(0x5f75DEB780493f57A82283aDc1Def47de8873E50);\r\n    //?根据小数位数  计算\r\n    uint initialExchangeRateMantissa_ = 20000000000000000000;\r\n    uint8 public decimals_ = 18;\r\n    address payable admin_ = 0x78A3970a965d347AD83c8350ab49eBFa62aC2Dc5;\r\n    // delegate 地址\r\n    address implementation_; // = 0x98872083585Cd54f6dfc2dB9894C5C1B816C3A55;\r\n    //comptroller_ 地址\r\n    bytes  becomeImplementationData ;\r\n    //模拟\r\n     mapping (address => address) public tokenKeyMapping;\r\n     mapping (address => address) public cTokenKeyMapping;\r\n    \r\n    //根据 'token' 获得 'cToken'\r\n    function getCTokenAddress(address token) external returns (address cToken){\r\n        //判断调用方这是否是swap pair 地址\r\n        cToken =  tokenKeyMapping[token];\r\n        //判断comptroller 中有没有 ctoken,有的话直接返回\r\n        if(cToken == address(0)){\r\n            cToken = newDelegator(token);\r\n            console.log('ctoken of %s not exist, create it: %s', token, cToken);\r\n        }\r\n        //没有 则创建并返回\r\n        return cToken;\r\n    }\r\n    \r\n    // 只读 如果不存在 返回 0\r\n    function getCTokenAddressPure(address token) external view returns (address) {\r\n        return tokenKeyMapping[token];\r\n    }\r\n\r\n    // 只读 如果不存在 返回 0\r\n    function getTokenAddress(address cToken) external view returns (address) {\r\n        return cTokenKeyMapping[cToken];\r\n    }\r\n    \r\n    function newDelegator(address token_) public returns (address delegator) {\r\n        require(token_ != address(0), 'ZERO_ADDRESS');\r\n        \r\n       // require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient\r\n        bytes memory bytecode = type(LErc20Delegator).creationCode;\r\n        bytes32 salt = keccak256(abi.encodePacked(token_));\r\n        // console.logBytes32('salt:', salt);\r\n        // console.logBytes(bytecode);\r\n        assembly {\r\n            delegator := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n        }\r\n\r\n        // console.log('delegator:', delegator);\r\n        //获得参数\r\n        EIP20Interface hrc20 = EIP20Interface(token_);\r\n        LErc20DelegatorInterface(delegator).delegateToInitialize(token_,\r\n                comptroller,\r\n                interestRateModel_,\r\n                initialExchangeRateMantissa_,\r\n                strConcat(\"L\", hrc20.name()) ,\r\n                strConcat(\"L\",hrc20.symbol()) ,\r\n                decimals_,\r\n                admin_,\r\n                implementation_,\r\n                becomeImplementationData);\r\n\r\n        addNewCToken(token_, delegator);\r\n        // bytes4(keccak256(bytes('_supportMarket(address)')))\r\n        // solhint-disable-next-line\r\n        address(comptroller).call(abi.encodeWithSelector(bytes4(keccak256(bytes('_supportMarket(address)'))), delegator));\r\n        emit NewDelegator(token_, address(delegator));\r\n        return delegator;\r\n    }\r\n    \r\n    //像comportable 添加新币 对应关系\r\n    function addNewCToken(address token,address cToken) public returns (uint){\r\n        // require(msg.sender == admin_, \"no auth\");\r\n\r\n        comptroller._supportMarket(cToken);\r\n        //包含两个币互相对应关系\r\n        tokenKeyMapping[token] = cToken;\r\n        cTokenKeyMapping[cToken] = token;\r\n    }\r\n    \r\n     function strConcat(string memory _a ,string memory _b) public view returns (string memory){\r\n            bytes memory _ba = bytes(_a);\r\n            bytes memory _bb = bytes(_b);\r\n            string memory ret = new string(_ba.length + _bb.length);\r\n            bytes memory bret = bytes(ret);\r\n            uint k = 0;\r\n            for (uint i = 0; i < _ba.length; i++)bret[k++] = _ba[i];\r\n            for (uint i = 0; i < _bb.length; i++) bret[k++] = _bb[i];\r\n            return string(ret);\r\n       }  \r\n\r\n}\r\n\r\n\r\n"
    },
    "contracts/common/LErc20DelegatorInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.5.16;\r\nimport \"./CTokenInterfaces.sol\";\r\n\r\ncontract LErc20DelegatorInterface {\r\n      function delegateToInitialize(address underlying_,\r\n                ComptrollerInterface comptroller_,\r\n                InterestRateModel interestRateModel_,\r\n                uint initialExchangeRateMantissa_,\r\n                string memory name_,\r\n                string memory symbol_,\r\n                uint8 decimals_,\r\n                address payable admin_,\r\n                address implementation_,\r\n                bytes memory becomeImplementationData) public {}\r\n\r\n      // get or create ctoken\r\n      function getCTokenAddress(address token) external returns (address cToken);\r\n      function getCTokenAddressPure(address cToken) external view returns (address);\r\n      function getTokenAddress(address cToken) external view returns (address);\r\n}"
    },
    "contracts/compound/LErc20Delegator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\nimport \"../common/CTokenInterfaces.sol\";\r\n\r\n/**\r\n * @title Compound's CErc20Delegator Contract\r\n * @notice CTokens which wrap an EIP-20 underlying and delegate to an implementation\r\n * @author Compound\r\n */\r\ncontract LErc20Delegator is CTokenInterface, CErc20Interface, CDelegatorInterface {\r\n    /**\r\n     * @notice Construct a new money market\r\n     * @param underlying_ The address of the underlying asset\r\n     * @param comptroller_ The address of the Comptroller\r\n     * @param interestRateModel_ The address of the interest rate model\r\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\r\n     * @param name_ ERC-20 name of this token\r\n     * @param symbol_ ERC-20 symbol of this token\r\n     * @param decimals_ ERC-20 decimal precision of this token\r\n     * @param admin_ Address of the administrator of this token\r\n     * @param implementation_ The address of the implementation the contract delegates to\r\n     * @param becomeImplementationData The encoded args for becomeImplementation\r\n     */\r\n    function delegateToInitialize(address underlying_,\r\n                ComptrollerInterface comptroller_,\r\n                InterestRateModel interestRateModel_,\r\n                uint initialExchangeRateMantissa_,\r\n                string memory name_,\r\n                string memory symbol_,\r\n                uint8 decimals_,\r\n                address payable admin_,\r\n                address implementation_,\r\n                bytes memory becomeImplementationData) public {\r\n        // Creator of the contract is admin during initialization\r\n        admin = msg.sender;\r\n\r\n        // First delegate gets to initialize the delegator (i.e. storage contract)\r\n        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,address,uint256,string,string,uint8)\",\r\n                                                            underlying_,\r\n                                                            comptroller_,\r\n                                                            interestRateModel_,\r\n                                                            initialExchangeRateMantissa_,\r\n                                                            name_,\r\n                                                            symbol_,\r\n                                                            decimals_));\r\n\r\n        // New implementations always get set via the settor (post-initialize)\r\n        _setImplementation(implementation_, false, becomeImplementationData);\r\n\r\n        // Set the proper admin now that initialization is done\r\n        admin = admin_;\r\n    }\r\n\r\n    /**\r\n     * @notice Called by the admin to update the implementation of the delegator\r\n     * @param implementation_ The address of the new implementation for delegation\r\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\r\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\r\n     */\r\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public {\r\n        require(msg.sender == admin, \"CErc20Delegator::_setImplementation: Caller must be admin\");\r\n\r\n        if (allowResign) {\r\n            delegateToImplementation(abi.encodeWithSignature(\"_resignImplementation()\"));\r\n        }\r\n\r\n        address oldImplementation = implementation;\r\n        implementation = implementation_;\r\n\r\n        delegateToImplementation(abi.encodeWithSignature(\"_becomeImplementation(bytes)\", becomeImplementationData));\r\n\r\n        emit NewImplementation(oldImplementation, implementation);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function mint(uint mintAmount) external returns (uint) {\r\n        mintAmount; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems cTokens in exchange for the underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemTokens The number of cTokens to redeem into underlying\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeem(uint redeemTokens) external returns (uint) {\r\n        redeemTokens; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemAmount The amount of underlying to redeem\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\r\n        redeemAmount; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n      * @notice Sender borrows assets from the protocol to their own address\r\n      * @param borrowAmount The amount of the underlying asset to borrow\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function borrow(uint borrowAmount) external returns (uint) {\r\n        borrowAmount; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    function borrowLPMargin(address borrower, uint borrowAmount) external returns (uint) {\r\n        borrower;\r\n        borrowAmount; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    function borrowSwapMargin(address borrower, uint borrowAmount) external returns (uint) {\r\n        borrower;\r\n        borrowAmount; // Shh\r\n        delegateAndReturn();\r\n    }\r\n    /**\r\n     * @notice Sender repays their own borrow\r\n     * @param repayAmount The amount to repay\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function repayBorrow(uint repayAmount) external returns (uint) {\r\n        repayAmount; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Sender repays a borrow belonging to borrower\r\n     * @param borrower the account with the debt being payed off\r\n     * @param repayAmount The amount to repay\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\r\n        borrower; repayAmount; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice The sender liquidates the borrowers collateral.\r\n     *  The collateral seized is transferred to the liquidator.\r\n     * @param borrower The borrower of this cToken to be liquidated\r\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\r\n     * @param repayAmount The amount of the underlying borrowed asset to repay\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function liquidateBorrow(address borrower, uint repayAmount,\r\n                        CTokenInterface cTokenCollateral) external returns (uint) {\r\n        borrower; repayAmount; cTokenCollateral; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n     * @param dst The address of the destination account\r\n     * @param amount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transfer(address dst, uint amount) external returns (bool) {\r\n        dst; amount; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `src` to `dst`\r\n     * @param src The address of the source account\r\n     * @param dst The address of the destination account\r\n     * @param amount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool) {\r\n        src; dst; amount; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Approve `spender` to transfer up to `amount` from `src`\r\n     * @dev This will overwrite the approval amount for `spender`\r\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\r\n     * @param spender The address of the account which may transfer tokens\r\n     * @param amount The number of tokens that are approved (-1 means infinite)\r\n     * @return Whether or not the approval succeeded\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool) {\r\n        spender; amount; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Get the current allowance from `owner` for `spender`\r\n     * @param owner The address of the account which owns the tokens to be spent\r\n     * @param spender The address of the account which may transfer tokens\r\n     * @return The number of tokens allowed to be spent (-1 means infinite)\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint) {\r\n        owner; spender; // Shh\r\n        delegateToViewAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Get the token balance of the `owner`\r\n     * @param owner The address of the account to query\r\n     * @return The number of tokens owned by `owner`\r\n     */\r\n    function balanceOf(address owner) external view returns (uint) {\r\n        owner; // Shh\r\n        delegateToViewAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Get the underlying balance of the `owner`\r\n     * @dev This also accrues interest in a transaction\r\n     * @param owner The address of the account to query\r\n     * @return The amount of underlying owned by `owner`\r\n     */\r\n    function balanceOfUnderlying(address owner) external returns (uint) {\r\n        owner; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\r\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\r\n     * @param account Address of the account to snapshot\r\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\r\n     */\r\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\r\n        account; // Shh\r\n        delegateToViewAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current per-block borrow interest rate for this cToken\r\n     * @return The borrow interest rate per block, scaled by 1e18\r\n     */\r\n    function borrowRatePerBlock() external view returns (uint) {\r\n        delegateToViewAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current per-block supply interest rate for this cToken\r\n     * @return The supply interest rate per block, scaled by 1e18\r\n     */\r\n    function supplyRatePerBlock() external view returns (uint) {\r\n        delegateToViewAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current total borrows plus accrued interest\r\n     * @return The total borrows with interest\r\n     */\r\n    function totalBorrowsCurrent() external returns (uint) {\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\r\n     * @param account The address whose balance should be calculated after updating borrowIndex\r\n     * @return The calculated balance\r\n     */\r\n    function borrowBalanceCurrent(address account) external returns (uint) {\r\n        account; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Return the borrow balance of account based on stored data\r\n     * @param account The address whose balance should be calculated\r\n     * @return The calculated balance\r\n     */\r\n    function borrowBalanceStored(address account) public view returns (uint) {\r\n        account; // Shh\r\n        delegateToViewAndReturn();\r\n    }\r\n\r\n   /**\r\n     * @notice Accrue interest then return the up-to-date exchange rate\r\n     * @return Calculated exchange rate scaled by 1e18\r\n     */\r\n    function exchangeRateCurrent() public returns (uint) {\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the exchange rate from the underlying to the CToken\r\n     * @dev This function does not accrue interest before calculating the exchange rate\r\n     * @return Calculated exchange rate scaled by 1e18\r\n     */\r\n    function exchangeRateStored() public view returns (uint) {\r\n        delegateToViewAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Get cash balance of this cToken in the underlying asset\r\n     * @return The quantity of underlying asset owned by this contract\r\n     */\r\n    function getCash() external view returns (uint) {\r\n        delegateToViewAndReturn();\r\n    }\r\n\r\n    /**\r\n      * @notice Applies accrued interest to total borrows and reserves.\r\n      * @dev This calculates interest accrued from the last checkpointed block\r\n      *      up to the current block and writes new checkpoint to storage.\r\n      */\r\n    function accrueInterest() public returns (uint) {\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers collateral tokens (this market) to the liquidator.\r\n     * @dev Will fail unless called by another cToken during the process of liquidation.\r\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\r\n     * @param liquidator The account receiving seized collateral\r\n     * @param borrower The account having collateral seized\r\n     * @param seizeTokens The number of cTokens to seize\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint) {\r\n        liquidator; borrower; seizeTokens; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    /**\r\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @param newPendingAdmin New pending admin.\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\r\n        newPendingAdmin; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n      * @notice Sets a new comptroller for the market\r\n      * @dev Admin function to set a new comptroller\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\r\n        newComptroller; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\r\n      * @dev Admin function to accrue interest and set a new reserve factor\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint) {\r\n        newReserveFactorMantissa; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\r\n      * @dev Admin function for pending admin to accept role and update admin\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _acceptAdmin() external returns (uint) {\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Accrues interest and adds reserves by transferring from admin\r\n     * @param addAmount Amount of reserves to add\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _addReserves(uint addAmount) external returns (uint) {\r\n        addAmount; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Accrues interest and reduces reserves by transferring to admin\r\n     * @param reduceAmount Amount of reduction to reserves\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _reduceReserves(uint reduceAmount) external returns (uint) {\r\n        reduceAmount; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Accrues interest and updates the interest rate model using _setInterestRateModelFresh\r\n     * @dev Admin function to accrue interest and update the interest rate model\r\n     * @param newInterestRateModel the new interest rate model to use\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\r\n        newInterestRateModel; // Shh\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @notice Internal method to delegate execution to another contract\r\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\r\n     * @param callee The contract to delegatecall\r\n     * @param data The raw data to delegatecall\r\n     * @return The returned bytes from the delegatecall\r\n     */\r\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\r\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\r\n        assembly {\r\n            if eq(success, 0) {\r\n                revert(add(returnData, 0x20), returndatasize())\r\n            }\r\n        }\r\n        return returnData;\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates execution to the implementation contract\r\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\r\n     * @param data The raw data to delegatecall\r\n     * @return The returned bytes from the delegatecall\r\n     */\r\n    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\r\n        return delegateTo(implementation, data);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates execution to an implementation contract\r\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\r\n     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\r\n     * @param data The raw data to delegatecall\r\n     * @return The returned bytes from the delegatecall\r\n     */\r\n    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\r\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\r\n        assembly {\r\n            if eq(success, 0) {\r\n                revert(add(returnData, 0x20), returndatasize())\r\n            }\r\n        }\r\n        return abi.decode(returnData, (bytes));\r\n    }\r\n\r\n    function delegateToViewAndReturn() private view returns (bytes memory) {\r\n        (bool success, ) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", msg.data));\r\n\r\n        assembly {\r\n            let free_mem_ptr := mload(0x40)\r\n            returndatacopy(free_mem_ptr, 0, returndatasize())\r\n\r\n            switch success\r\n            case 0 { revert(free_mem_ptr, returndatasize()) }\r\n            default { return(add(free_mem_ptr, 0x40), returndatasize()) }\r\n        }\r\n    }\r\n\r\n    function delegateAndReturn() private returns (bytes memory) {\r\n        (bool success, ) = implementation.delegatecall(msg.data);\r\n\r\n        assembly {\r\n            let free_mem_ptr := mload(0x40)\r\n            returndatacopy(free_mem_ptr, 0, returndatasize())\r\n\r\n            switch success\r\n            case 0 { revert(free_mem_ptr, returndatasize()) }\r\n            default { return(free_mem_ptr, returndatasize()) }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates execution to an implementation contract\r\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\r\n     */\r\n    // function () external payable {\r\n    function () external payable {\r\n        require(msg.value == 0, \"LErc20Delegator:fallback: cannot send value to fallback\");\r\n\r\n        // delegate all other functions to current implementation\r\n        delegateAndReturn();\r\n    }\r\n    // receive () external payable {\r\n    //     require(msg.value == 0, \"LErc20Delegator:receive: cannot send value to receive\");\r\n\r\n    //     // delegate all other functions to current implementation\r\n    //     // delegateAndReturn();\r\n    // }\r\n}\r\n"
    },
    "contracts/compound/LHT.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\nimport \"./CToken.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\ninterface ILHT {\r\n    function mint() external payable;\r\n}\r\n\r\n/**\r\n * @title LendHub's LHT Contract\r\n * @notice CToken which wraps HT\r\n * @author LendHub\r\n */\r\ncontract LHT is CToken, ILHT {\r\n    /**\r\n     * @notice Construct a new CEther money market\r\n     * @param comptroller_ The address of the Comptroller\r\n     * @param interestRateModel_ The address of the interest rate model\r\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\r\n     * @param name_ ERC-20 name of this token\r\n     * @param symbol_ ERC-20 symbol of this token\r\n     * @param decimals_ ERC-20 decimal precision of this token\r\n     * @param admin_ Address of the administrator of this token\r\n     */\r\n    constructor(ComptrollerInterface comptroller_,\r\n                InterestRateModel interestRateModel_,\r\n                uint initialExchangeRateMantissa_,\r\n                string memory name_,\r\n                string memory symbol_,\r\n                uint8 decimals_,\r\n                address payable admin_) public {\r\n        // Creator of the contract is admin during initialization\r\n        admin = msg.sender;\r\n\r\n        initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\r\n\r\n        // Set the proper admin now that initialization is done\r\n        admin = admin_;\r\n    }\r\n\r\n\r\n    /*** User Interface ***/\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\r\n     * @dev Reverts upon any failure\r\n     */\r\n    function mint() external payable {\r\n        console.log(\"mint LHT\");\r\n        (uint err,) = mintInternal(msg.value);\r\n        requireNoError(err, \"mint failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems cTokens in exchange for the underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemTokens The number of cTokens to redeem into underlying\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeem(uint redeemTokens) external returns (uint) {\r\n        console.log(\"redeem LHT:\", redeemTokens);\r\n        return redeemInternal(redeemTokens);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemAmount The amount of underlying to redeem\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\r\n        return redeemUnderlyingInternal(redeemAmount);\r\n    }\r\n\r\n    /**\r\n      * @notice Sender borrows assets from the protocol to their own address\r\n      * @param borrowAmount The amount of the underlying asset to borrow\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function borrow(uint borrowAmount) external returns (uint) {\r\n        return borrowInternal(borrowAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender repays their own borrow\r\n     * @dev Reverts upon any failure\r\n     */\r\n    function repayBorrow() external payable {\r\n        (uint err,) = repayBorrowInternal(msg.value);\r\n        requireNoError(err, \"repayBorrow failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice Sender repays a borrow belonging to borrower\r\n     * @dev Reverts upon any failure\r\n     * @param borrower the account with the debt being payed off\r\n     */\r\n    function repayBorrowBehalf(address borrower) external payable {\r\n        (uint err,) = repayBorrowBehalfInternal(borrower, msg.value);\r\n        requireNoError(err, \"repayBorrowBehalf failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice The sender liquidates the borrowers collateral.\r\n     *  The collateral seized is transferred to the liquidator.\r\n     * @dev Reverts upon any failure\r\n     * @param borrower The borrower of this cToken to be liquidated\r\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\r\n     */\r\n    function liquidateBorrow(address borrower, CToken cTokenCollateral) external payable {\r\n        (uint err,) = liquidateBorrowInternal(borrower, msg.value, cTokenCollateral);\r\n        requireNoError(err, \"liquidateBorrow failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice Send Ether to CEther to mint\r\n     */\r\n    // function () external payable {\r\n    function() external payable {\r\n        (uint err,) = mintInternal(msg.value);\r\n        requireNoError(err, \"mint failed\");\r\n    }\r\n\r\n    // receive() external payable {\r\n    //     (uint err,) = mintInternal(msg.value);\r\n    //     requireNoError(err, \"mint failed\");\r\n    // }\r\n    /*** Safe Token ***/\r\n\r\n    /**\r\n     * @notice Gets balance of this contract in terms of Ether, before this message\r\n     * @dev This excludes the value of the current message, if any\r\n     * @return The quantity of Ether owned by this contract\r\n     */\r\n    function getCashPrior() internal view returns (uint) {\r\n        (MathError err, uint startingBalance) = subUInt(address(this).balance, msg.value);\r\n        require(err == MathError.NO_ERROR);\r\n        return startingBalance;\r\n    }\r\n\r\n    /**\r\n     * @notice Perform the actual transfer in, which is a no-op\r\n     * @param from Address sending the Ether\r\n     * @param amount Amount of Ether being sent\r\n     * @return The actual amount of Ether transferred\r\n     */\r\n    function doTransferIn(address from, uint amount) internal returns (uint) {\r\n        // Sanity checks\r\n        require(msg.sender == from, \"sender mismatch\");\r\n        require(msg.value == amount, \"value mismatch\");\r\n        return amount;\r\n    }\r\n\r\n    function doTransferOut(address payable to, uint amount) internal {\r\n        console.log(\"LHT doTransferOut:\", to, amount);\r\n        /* Send the Ether, with minimal gas and revert on failure */\r\n        to.transfer(amount);\r\n    }\r\n\r\n    function requireNoError(uint errCode, string memory message) internal pure {\r\n        if (errCode == uint(Error.NO_ERROR)) {\r\n            return;\r\n        }\r\n\r\n        bytes memory fullMessage = new bytes(bytes(message).length + 5);\r\n        uint i;\r\n\r\n        for (i = 0; i < bytes(message).length; i++) {\r\n            fullMessage[i] = bytes(message)[i];\r\n        }\r\n\r\n        fullMessage[i+0] = byte(uint8(32));\r\n        fullMessage[i+1] = byte(uint8(40));\r\n        fullMessage[i+2] = byte(uint8(48 + ( errCode / 10 )));\r\n        fullMessage[i+3] = byte(uint8(48 + ( errCode % 10 )));\r\n        fullMessage[i+4] = byte(uint8(41));\r\n\r\n        require(errCode == uint(Error.NO_ERROR), string(fullMessage));\r\n    }\r\n}\r\n"
    },
    "contracts/compound/Comptroller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\nimport \"./CToken.sol\";\r\nimport \"./ErrorReporter.sol\";\r\nimport \"./PriceOracle.sol\";\r\nimport \"../common/ComptrollerInterface.sol\";\r\nimport \"./ComptrollerStorage.sol\";\r\nimport \"./Unitroller.sol\";\r\nimport \"./Governance/LendHub.sol\";\r\n\r\n// for debug\r\nimport \"hardhat/console.sol\";\r\n/**\r\n * @title Compound's Comptroller Contract\r\n * @author Compound\r\n */\r\ncontract Comptroller is ComptrollerV5Storage, ComptrollerInterface, ComptrollerErrorReporter, ExponentialNoError {\r\n    /// @notice Emitted when an admin supports a market\r\n    event MarketListed(CToken cToken);\r\n\r\n    /// @notice Emitted when an account enters a market\r\n    event MarketEntered(CToken cToken, address account);\r\n\r\n    /// @notice Emitted when an account exits a market\r\n    event MarketExited(CToken cToken, address account);\r\n\r\n    /// @notice Emitted when close factor is changed by admin\r\n    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\r\n\r\n    /// @notice Emitted when a collateral factor is changed by admin\r\n    event NewCollateralFactor(CToken cToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\r\n\r\n    /// @notice Emitted when liquidation incentive is changed by admin\r\n    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\r\n\r\n    /// @notice Emitted when price oracle is changed\r\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\r\n\r\n    /// @notice Emitted when pause guardian is changed\r\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\r\n\r\n    /// @notice Emitted when an action is paused globally\r\n    event ActionPausedAll(string action, bool pauseState);\r\n\r\n    /// @notice Emitted when an action is paused on a market\r\n    event ActionPaused(CToken cToken, string action, bool pauseState);\r\n\r\n    /// @notice Emitted when market comped status is changed\r\n    event MarketComped(CToken cToken, bool isComped);\r\n\r\n    /// @notice Emitted when LHB rate is changed\r\n    event NewCompRate(uint oldCompRate, uint newCompRate);\r\n\r\n    /// @notice Emitted when a new LHB speed is calculated for a market\r\n    event CompSpeedUpdated(CToken indexed cToken, uint newSpeed);\r\n\r\n    /// @notice Emitted when LHB is distributed to a supplier\r\n    event DistributedSupplierComp(CToken indexed cToken, address indexed supplier, uint compDelta, uint compSupplyIndex);\r\n\r\n    /// @notice Emitted when LHB is distributed to a borrower\r\n    event DistributedBorrowerComp(CToken indexed cToken, address indexed borrower, uint compDelta, uint compBorrowIndex);\r\n\r\n    /// @notice Emitted when borrow cap for a cToken is changed\r\n    event NewBorrowCap(CToken indexed cToken, uint newBorrowCap);\r\n\r\n    /// @notice Emitted when borrow cap guardian is changed\r\n    event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\r\n\r\n    /// @notice Emitted when LHB is granted by admin\r\n    event CompGranted(address recipient, uint amount);\r\n\r\n    /// @notice The threshold above which the flywheel transfers LHB, in wei\r\n    uint public constant compClaimThreshold = 0.001e18;\r\n\r\n    /// @notice The initial LHB index for a market\r\n    uint224 public constant compInitialIndex = 1e36;\r\n\r\n    // closeFactorMantissa must be strictly greater than this value\r\n    uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\r\n\r\n    // closeFactorMantissa must not exceed this value\r\n    uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\r\n\r\n    // No collateralFactorMantissa may exceed this value\r\n    uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\r\n\r\n    constructor() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    /*** Assets You Are In ***/\r\n\r\n    /**\r\n     * @notice Returns the assets an account has entered\r\n     * @param account The address of the account to pull assets for\r\n     * @return A dynamic list with the assets the account has entered\r\n     */\r\n    function getAssetsIn(address account) external view returns (CToken[] memory) {\r\n        CToken[] memory assetsIn = accountAssets[account];\r\n\r\n        return assetsIn;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns whether the given account is entered in the given asset\r\n     * @param account The address of the account to check\r\n     * @param cToken The cToken to check\r\n     * @return True if the account is in the asset, otherwise false.\r\n     */\r\n    function checkMembership(address account, CToken cToken) external view returns (bool) {\r\n        return markets[address(cToken)].accountMembership[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Add assets to be included in account liquidity calculation\r\n     * @param cTokens The list of addresses of the cToken markets to be enabled\r\n     * @return Success indicator for whether each corresponding market was entered\r\n     */\r\n    function enterMarkets(address[] memory cTokens) public returns (uint[] memory) {\r\n        uint len = cTokens.length;\r\n\r\n        uint[] memory results = new uint[](len);\r\n        for (uint i = 0; i < len; i++) {\r\n            CToken cToken = CToken(cTokens[i]);\r\n\r\n            results[i] = uint(addToMarketInternal(cToken, msg.sender));\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\r\n     * @param cToken The market to enter\r\n     * @param borrower The address of the account to modify\r\n     * @return Success indicator for whether the market was entered\r\n     */\r\n    function addToMarketInternal(CToken cToken, address borrower) internal returns (Error) {\r\n        Market storage marketToJoin = markets[address(cToken)];\r\n\r\n        if (!marketToJoin.isListed) {\r\n            // market is not listed, cannot join\r\n            return Error.MARKET_NOT_LISTED;\r\n        }\r\n\r\n        if (marketToJoin.accountMembership[borrower] == true) {\r\n            // already joined\r\n            return Error.NO_ERROR;\r\n        }\r\n\r\n        // survived the gauntlet, add to list\r\n        // NOTE: we store these somewhat redundantly as a significant optimization\r\n        //  this avoids having to iterate through the list for the most common use cases\r\n        //  that is, only when we need to perform liquidity checks\r\n        //  and not whenever we want to check if an account is in a particular market\r\n        marketToJoin.accountMembership[borrower] = true;\r\n        accountAssets[borrower].push(cToken);\r\n\r\n        emit MarketEntered(cToken, borrower);\r\n\r\n        return Error.NO_ERROR;\r\n    }\r\n\r\n    /**\r\n     * @notice Removes asset from sender's account liquidity calculation\r\n     * @dev Sender must not have an outstanding borrow balance in the asset,\r\n     *  or be providing necessary collateral for an outstanding borrow.\r\n     * @param cTokenAddress The address of the asset to be removed\r\n     * @return Whether or not the account successfully exited the market\r\n     */\r\n    function exitMarket(address cTokenAddress) external returns (uint) {\r\n        CToken cToken = CToken(cTokenAddress);\r\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\r\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\r\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\r\n\r\n        /* Fail if the sender has a borrow balance */\r\n        if (amountOwed != 0) {\r\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\r\n        }\r\n\r\n        /* Fail if the sender is not permitted to redeem all of their tokens */\r\n        uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\r\n        }\r\n\r\n        Market storage marketToExit = markets[address(cToken)];\r\n\r\n        /* Return true if the sender is not already ‘in’ the market */\r\n        if (!marketToExit.accountMembership[msg.sender]) {\r\n            return uint(Error.NO_ERROR);\r\n        }\r\n\r\n        /* Set cToken account membership to false */\r\n        delete marketToExit.accountMembership[msg.sender];\r\n\r\n        /* Delete cToken from the account’s list of assets */\r\n        // load into memory for faster iteration\r\n        CToken[] memory userAssetList = accountAssets[msg.sender];\r\n        uint len = userAssetList.length;\r\n        uint assetIndex = len;\r\n        for (uint i = 0; i < len; i++) {\r\n            if (userAssetList[i] == cToken) {\r\n                assetIndex = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // We *must* have found the asset in the list or our redundant data structure is broken\r\n        assert(assetIndex < len);\r\n\r\n        // copy last item in list to location of item to be removed, reduce length by 1\r\n        CToken[] storage storedList = accountAssets[msg.sender];\r\n        storedList[assetIndex] = storedList[storedList.length - 1];\r\n        // storedList.length--;\r\n        storedList.pop();\r\n\r\n        emit MarketExited(cToken, msg.sender);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /*** Policy Hooks ***/\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to mint tokens in the given market\r\n     * @param cToken The market to verify the mint against\r\n     * @param minter The account which would get the minted tokens\r\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\r\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function mintAllowed(address cToken, address minter, uint mintAmount) external returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!mintGuardianPaused[cToken], \"mint is paused\");\r\n\r\n        // Shh - currently unused\r\n        minter;\r\n        mintAmount;\r\n\r\n        // if (!markets[cToken].isListed) {\r\n            // console.log('ctoken %s is NOT listed', cToken);\r\n            // return uint(Error.MARKET_NOT_LISTED);\r\n        // }\r\n\r\n        // Keep the flywheel moving\r\n        updateCompSupplyIndex(cToken);\r\n        distributeSupplierComp(cToken, minter, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates mint and reverts on rejection. May emit logs.\r\n     * @param cToken Asset being minted\r\n     * @param minter The address minting the tokens\r\n     * @param actualMintAmount The amount of the underlying asset being minted\r\n     * @param mintTokens The number of tokens being minted\r\n     */\r\n    function mintVerify(address cToken, address minter, uint actualMintAmount, uint mintTokens) external {\r\n        // Shh - currently unused\r\n        cToken;\r\n        minter;\r\n        actualMintAmount;\r\n        mintTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\r\n     * @param cToken The market to verify the redeem against\r\n     * @param redeemer The account which would redeem the tokens\r\n     * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\r\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) external returns (uint) {\r\n        uint allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);\r\n        if (allowed != uint(Error.NO_ERROR)) {\r\n            return allowed;\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateCompSupplyIndex(cToken);\r\n        distributeSupplierComp(cToken, redeemer, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function redeemAllowedInternal(address cToken, address redeemer, uint redeemTokens) internal view returns (uint) {\r\n        if (!markets[cToken].isListed) {\r\n            console.log(\"token not listed\");\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\r\n        if (!markets[cToken].accountMembership[redeemer]) {\r\n            return uint(Error.NO_ERROR);\r\n        }\r\n\r\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\r\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, CToken(cToken), redeemTokens, 0);\r\n        if (err != Error.NO_ERROR) {\r\n            console.log(\"getHypotheticalAccountLiquidityInternal failed:\", uint(err));\r\n            return uint(err);\r\n        }\r\n        if (shortfall > 0) {\r\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\r\n        }\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates redeem and reverts on rejection. May emit logs.\r\n     * @param cToken Asset being redeemed\r\n     * @param redeemer The address redeeming the tokens\r\n     * @param redeemAmount The amount of the underlying asset being redeemed\r\n     * @param redeemTokens The number of tokens being redeemed\r\n     */\r\n    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) external {\r\n        // Shh - currently unused\r\n        cToken;\r\n        redeemer;\r\n\r\n        // Require tokens is zero or amount is also zero\r\n        if (redeemTokens == 0 && redeemAmount > 0) {\r\n            revert(\"redeemTokens zero\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\r\n     * @param cToken The market to verify the borrow against\r\n     * @param borrower The account which would borrow the asset\r\n     * @param borrowAmount The amount of underlying the account would borrow\r\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) external returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!borrowGuardianPaused[cToken], \"borrow is paused\");\r\n\r\n        if (!markets[cToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        if (!markets[cToken].accountMembership[borrower]) {\r\n            // only cTokens may call borrowAllowed if borrower not in market\r\n            require(msg.sender == cToken, \"sender must be cToken\");\r\n\r\n            // attempt to add borrower to the market\r\n            Error ierr = addToMarketInternal(CToken(msg.sender), borrower);\r\n            if (ierr != Error.NO_ERROR) {\r\n                return uint(ierr);\r\n            }\r\n\r\n            // it should be impossible to break the important invariant\r\n            assert(markets[cToken].accountMembership[borrower]);\r\n        }\r\n\r\n        if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {\r\n            return uint(Error.PRICE_ERROR);\r\n        }\r\n\r\n\r\n        uint borrowCap = borrowCaps[cToken];\r\n        // Borrow cap of 0 corresponds to unlimited borrowing\r\n        if (borrowCap != 0) {\r\n            uint totalBorrows = CToken(cToken).totalBorrows();\r\n            uint nextTotalBorrows = add_(totalBorrows, borrowAmount);\r\n            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\r\n        }\r\n\r\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, CToken(cToken), 0, borrowAmount);\r\n        if (err != Error.NO_ERROR) {\r\n            return uint(err);\r\n        }\r\n        if (shortfall > 0) {\r\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        Exp memory borrowIndex = Exp({mantissa: CToken(cToken).borrowIndex()});\r\n        updateCompBorrowIndex(cToken, borrowIndex);\r\n        distributeBorrowerComp(cToken, borrower, borrowIndex, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates borrow and reverts on rejection. May emit logs.\r\n     * @param cToken Asset whose underlying is being borrowed\r\n     * @param borrower The address borrowing the underlying\r\n     * @param borrowAmount The amount of the underlying asset requested to borrow\r\n     */\r\n    function borrowVerify(address cToken, address borrower, uint borrowAmount) external {\r\n        // Shh - currently unused\r\n        cToken;\r\n        borrower;\r\n        borrowAmount;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n    /**\r\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\r\n     * @param cToken The market to verify the borrow against\r\n     * @param borrower The account which would borrow the asset\r\n     * @param borrowAmount The amount of underlying the account would borrow\r\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function borrowMarginAllowed(address cToken, address borrower, uint borrowAmount) external returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!borrowGuardianPaused[cToken], \"borrow is paused\");\r\n\r\n        if (!markets[cToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        // accountMembership 是用来检查用户质押资产情况的, 杠杆的情况下, 是通过杠杆合约来确保用户资产的, 不需要这里的检查\r\n        // if (!markets[cToken].accountMembership[borrower]) {\r\n        //     // only cTokens may call borrowAllowed if borrower not in market\r\n        //     require(msg.sender == cToken, \"sender must be cToken\");\r\n\r\n        //     // attempt to add borrower to the market\r\n        //     Error ierr = addToMarketInternal(CToken(msg.sender), borrower);\r\n        //     if (ierr != Error.NO_ERROR) {\r\n        //         return uint(ierr);\r\n        //     }\r\n\r\n        //     // it should be impossible to break the important invariant\r\n        //     assert(markets[cToken].accountMembership[borrower]);\r\n        // }\r\n\r\n        // if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {\r\n        //     return uint(Error.PRICE_ERROR);\r\n        // }\r\n\r\n\r\n        uint borrowCap = borrowCaps[cToken];\r\n        // Borrow cap of 0 corresponds to unlimited borrowing\r\n        if (borrowCap != 0) {\r\n            uint totalBorrows = CToken(cToken).totalBorrows();\r\n            uint nextTotalBorrows = add_(totalBorrows, borrowAmount);\r\n            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\r\n        }\r\n\r\n        // 用户的抵押是否够借 杠杆的情况的检查在 MarginLP marginSwap 中进行\r\n        // (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, CToken(cToken), 0, borrowAmount);\r\n        // if (err != Error.NO_ERROR) {\r\n        //     return uint(err);\r\n        // }\r\n        // if (shortfall > 0) {\r\n        //     return uint(Error.INSUFFICIENT_LIQUIDITY);\r\n        // }\r\n\r\n        // Keep the flywheel moving\r\n        Exp memory borrowIndex = Exp({mantissa: CToken(cToken).borrowIndex()});\r\n        updateCompBorrowIndex(cToken, borrowIndex);\r\n        distributeBorrowerComp(cToken, borrower, borrowIndex, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n    \r\n    /**\r\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\r\n     * @param cToken The market to verify the repay against\r\n     * @param payer The account which would repay the asset\r\n     * @param borrower The account which would borrowed the asset\r\n     * @param repayAmount The amount of the underlying asset the account would repay\r\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function repayBorrowAllowed(\r\n        address cToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount) external returns (uint) {\r\n        // Shh - currently unused\r\n        payer;\r\n        borrower;\r\n        repayAmount;\r\n\r\n        if (!markets[cToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        Exp memory borrowIndex = Exp({mantissa: CToken(cToken).borrowIndex()});\r\n        updateCompBorrowIndex(cToken, borrowIndex);\r\n        distributeBorrowerComp(cToken, borrower, borrowIndex, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates repayBorrow and reverts on rejection. May emit logs.\r\n     * @param cToken Asset being repaid\r\n     * @param payer The address repaying the borrow\r\n     * @param borrower The address of the borrower\r\n     * @param actualRepayAmount The amount of underlying being repaid\r\n     */\r\n    function repayBorrowVerify(\r\n        address cToken,\r\n        address payer,\r\n        address borrower,\r\n        uint actualRepayAmount,\r\n        uint borrowerIndex) external {\r\n        // Shh - currently unused\r\n        cToken;\r\n        payer;\r\n        borrower;\r\n        actualRepayAmount;\r\n        borrowerIndex;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the liquidation should be allowed to occur\r\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param repayAmount The amount of underlying being repaid\r\n     */\r\n    function liquidateBorrowAllowed(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount) external returns (uint) {\r\n        // Shh - currently unused\r\n        liquidator;\r\n\r\n        if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        /* The borrower must have shortfall in order to be liquidatable */\r\n        (Error err, , uint shortfall) = getAccountLiquidityInternal(borrower);\r\n        if (err != Error.NO_ERROR) {\r\n            return uint(err);\r\n        }\r\n        if (shortfall == 0) {\r\n            return uint(Error.INSUFFICIENT_SHORTFALL);\r\n        }\r\n\r\n        /* The liquidator may not repay more than what is allowed by the closeFactor */\r\n        uint borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);\r\n        uint maxClose = mul_ScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);\r\n        if (repayAmount > maxClose) {\r\n            return uint(Error.TOO_MUCH_REPAY);\r\n        }\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\r\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param actualRepayAmount The amount of underlying being repaid\r\n     */\r\n    function liquidateBorrowVerify(\r\n        address cTokenBorrowed,\r\n        address cTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint actualRepayAmount,\r\n        uint seizeTokens) external {\r\n        // Shh - currently unused\r\n        cTokenBorrowed;\r\n        cTokenCollateral;\r\n        liquidator;\r\n        borrower;\r\n        actualRepayAmount;\r\n        seizeTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the seizing of assets should be allowed to occur\r\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param seizeTokens The number of collateral tokens to seize\r\n     */\r\n    function seizeAllowed(\r\n        address cTokenCollateral,\r\n        address cTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!seizeGuardianPaused, \"seize is paused\");\r\n\r\n        // Shh - currently unused\r\n        seizeTokens;\r\n\r\n        if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        if (CToken(cTokenCollateral).comptroller() != CToken(cTokenBorrowed).comptroller()) {\r\n            return uint(Error.COMPTROLLER_MISMATCH);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateCompSupplyIndex(cTokenCollateral);\r\n        distributeSupplierComp(cTokenCollateral, borrower, false);\r\n        distributeSupplierComp(cTokenCollateral, liquidator, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates seize and reverts on rejection. May emit logs.\r\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param seizeTokens The number of collateral tokens to seize\r\n     */\r\n    function seizeVerify(\r\n        address cTokenCollateral,\r\n        address cTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external {\r\n        // Shh - currently unused\r\n        cTokenCollateral;\r\n        cTokenBorrowed;\r\n        liquidator;\r\n        borrower;\r\n        seizeTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\r\n     * @param cToken The market to verify the transfer against\r\n     * @param src The account which sources the tokens\r\n     * @param dst The account which receives the tokens\r\n     * @param transferTokens The number of cTokens to transfer\r\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function transferAllowed(address cToken, address src, address dst, uint transferTokens) external returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!transferGuardianPaused, \"transfer is paused\");\r\n\r\n        // Currently the only consideration is whether or not\r\n        //  the src is allowed to redeem this many tokens\r\n        uint allowed = redeemAllowedInternal(cToken, src, transferTokens);\r\n        if (allowed != uint(Error.NO_ERROR)) {\r\n            return allowed;\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateCompSupplyIndex(cToken);\r\n        distributeSupplierComp(cToken, src, false);\r\n        distributeSupplierComp(cToken, dst, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates transfer and reverts on rejection. May emit logs.\r\n     * @param cToken Asset being transferred\r\n     * @param src The account which sources the tokens\r\n     * @param dst The account which receives the tokens\r\n     * @param transferTokens The number of cTokens to transfer\r\n     */\r\n    function transferVerify(address cToken, address src, address dst, uint transferTokens) external {\r\n        // Shh - currently unused\r\n        cToken;\r\n        src;\r\n        dst;\r\n        transferTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /*** Liquidity/Liquidation Calculations ***/\r\n\r\n    /**\r\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\r\n     *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\r\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\r\n     */\r\n    struct AccountLiquidityLocalVars {\r\n        uint sumCollateral;\r\n        uint sumBorrowPlusEffects;\r\n        uint cTokenBalance;\r\n        uint borrowBalance;\r\n        uint exchangeRateMantissa;\r\n        uint oraclePriceMantissa;\r\n        Exp collateralFactor;\r\n        Exp exchangeRate;\r\n        Exp oraclePrice;\r\n        Exp tokensToDenom;\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the current account liquidity wrt collateral requirements\r\n     * @return (possible error code (semi-opaque),\r\n                account liquidity in excess of collateral requirements,\r\n     *          account shortfall below collateral requirements)\r\n     */\r\n    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\r\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\r\n\r\n        return (uint(err), liquidity, shortfall);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the current account liquidity wrt collateral requirements\r\n     * @return (possible error code,\r\n                account liquidity in excess of collateral requirements,\r\n     *          account shortfall below collateral requirements)\r\n     */\r\n    function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\r\n        return getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\r\n     * @param cTokenModify The market to hypothetically redeem/borrow in\r\n     * @param account The account to determine liquidity for\r\n     * @param redeemTokens The number of tokens to hypothetically redeem\r\n     * @param borrowAmount The amount of underlying to hypothetically borrow\r\n     * @return (possible error code (semi-opaque),\r\n                hypothetical account liquidity in excess of collateral requirements,\r\n     *          hypothetical account shortfall below collateral requirements)\r\n     */\r\n    function getHypotheticalAccountLiquidity(\r\n        address account,\r\n        address cTokenModify,\r\n        uint redeemTokens,\r\n        uint borrowAmount) public view returns (uint, uint, uint) {\r\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account,\r\n            CToken(cTokenModify), redeemTokens, borrowAmount);\r\n        return (uint(err), liquidity, shortfall);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\r\n     * @param cTokenModify The market to hypothetically redeem/borrow in\r\n     * @param account The account to determine liquidity for\r\n     * @param redeemTokens The number of tokens to hypothetically redeem\r\n     * @param borrowAmount The amount of underlying to hypothetically borrow\r\n     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\r\n     *  without calculating accumulated interest.\r\n     * @return (possible error code,\r\n                hypothetical account liquidity in excess of collateral requirements,\r\n     *          hypothetical account shortfall below collateral requirements)\r\n     */\r\n    function getHypotheticalAccountLiquidityInternal(\r\n        address account,\r\n        CToken cTokenModify,\r\n        uint redeemTokens,\r\n        uint borrowAmount) internal view returns (Error, uint, uint) {\r\n\r\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\r\n        uint oErr;\r\n\r\n        // For each asset the account is in\r\n        CToken[] memory assets = accountAssets[account];\r\n        for (uint i = 0; i < assets.length; i++) {\r\n            CToken asset = assets[i];\r\n\r\n            // Read the balances and exchange rate from the cToken\r\n            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\r\n            if (oErr != 0) { // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\r\n                return (Error.SNAPSHOT_ERROR, 0, 0);\r\n            }\r\n            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\r\n            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\r\n\r\n            // Get the normalized price of the asset\r\n            // debankex: 这里需要修改 没有价格不能退出 todo\r\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\r\n            if (vars.oraclePriceMantissa == 0) {\r\n                return (Error.PRICE_ERROR, 0, 0);\r\n            }\r\n            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\r\n\r\n            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\r\n            vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\r\n\r\n            // sumCollateral += tokensToDenom * cTokenBalance\r\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.cTokenBalance, vars.sumCollateral);\r\n\r\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\r\n            vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\r\n\r\n            // Calculate effects of interacting with cTokenModify\r\n            if (asset == cTokenModify) {\r\n                // redeem effect\r\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\r\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);\r\n\r\n                // borrow effect\r\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\r\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);\r\n            }\r\n        }\r\n\r\n        // These are safe, as the underflow condition is checked first\r\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\r\n            return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\r\n        } else {\r\n            return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\r\n     * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\r\n     * @param cTokenBorrowed The address of the borrowed cToken\r\n     * @param cTokenCollateral The address of the collateral cToken\r\n     * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\r\n     * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\r\n     */\r\n    function liquidateCalculateSeizeTokens(address cTokenBorrowed,\r\n                                            address cTokenCollateral,\r\n                                            uint actualRepayAmount) external view returns (uint, uint) {\r\n        /* Read oracle prices for borrowed and collateral markets */\r\n        uint priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));\r\n        uint priceCollateralMantissa = oracle.getUnderlyingPrice(CToken(cTokenCollateral));\r\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\r\n            return (uint(Error.PRICE_ERROR), 0);\r\n        }\r\n\r\n        /*\r\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\r\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\r\n         *  seizeTokens = seizeAmount / exchangeRate\r\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\r\n         */\r\n        uint exchangeRateMantissa = CToken(cTokenCollateral).exchangeRateStored(); // Note: reverts on error\r\n        uint seizeTokens;\r\n        Exp memory numerator;\r\n        Exp memory denominator;\r\n        Exp memory ratio;\r\n\r\n        numerator = mul_(Exp({mantissa: liquidationIncentiveMantissa}), Exp({mantissa: priceBorrowedMantissa}));\r\n        denominator = mul_(Exp({mantissa: priceCollateralMantissa}), Exp({mantissa: exchangeRateMantissa}));\r\n        ratio = div_(numerator, denominator);\r\n\r\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\r\n\r\n        return (uint(Error.NO_ERROR), seizeTokens);\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    /**\r\n      * @notice Sets a new price oracle for the comptroller\r\n      * @dev Admin function to set a new price oracle\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\r\n        }\r\n\r\n        // Track the old oracle for the comptroller\r\n        PriceOracle oldOracle = oracle;\r\n\r\n        // Set comptroller's oracle to newOracle\r\n        oracle = newOracle;\r\n\r\n        // Emit NewPriceOracle(oldOracle, newOracle)\r\n        emit NewPriceOracle(oldOracle, newOracle);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets the closeFactor used when liquidating borrows\r\n      * @dev Admin function to set closeFactor\r\n      * @param newCloseFactorMantissa New close factor, scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure\r\n      */\r\n    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\r\n        // Check caller is admin\r\n        require(msg.sender == admin, \"only admin can set close factor\");\r\n\r\n        uint oldCloseFactorMantissa = closeFactorMantissa;\r\n        closeFactorMantissa = newCloseFactorMantissa;\r\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets the collateralFactor for a market\r\n      * @dev Admin function to set per-market collateralFactor\r\n      * @param cToken The market to set the factor on\r\n      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setCollateralFactor(CToken cToken, uint newCollateralFactorMantissa) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\r\n        }\r\n\r\n        // Verify market is listed\r\n        Market storage market = markets[address(cToken)];\r\n        if (!market.isListed) {\r\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\r\n        }\r\n\r\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\r\n\r\n        // Check collateral factor <= 0.9\r\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\r\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\r\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\r\n        }\r\n\r\n        // If collateral factor != 0, fail if price == 0\r\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\r\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\r\n        }\r\n\r\n        // Set market's collateral factor to new collateral factor, remember old value\r\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\r\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\r\n\r\n        // Emit event with asset, old collateral factor, and new collateral factor\r\n        emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets liquidationIncentive\r\n      * @dev Admin function to set liquidationIncentive\r\n      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\r\n        }\r\n\r\n        // Save current value for use in log\r\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\r\n\r\n        // Set liquidation incentive to new incentive\r\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\r\n\r\n        // Emit event with old incentive, new incentive\r\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Add the market to the markets mapping and set it as listed\r\n      * @dev Admin function to set isListed and add support for the market\r\n      * @param cToken The address of the market (token) to list\r\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\r\n      */\r\n    function _supportMarket(address cToken) external returns (uint) {\r\n        // if (msg.sender != admin) {\r\n        //     console.log('msg.sender %s is not admin %s', msg.sender, admin);\r\n        //     return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\r\n        // }\r\n\r\n        // console.log('list ctoken %s to market ....', cToken);\r\n        if (markets[address(cToken)].isListed) {\r\n            // console.log('token isListed');\r\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\r\n        }\r\n\r\n        CToken(cToken).isCToken(); // Sanity check to make sure its really a CToken\r\n\r\n        // console.log('ctoken is CToken verified');\r\n\r\n        // markets[address(cToken)] = Market({isListed: true, isComped: false, collateralFactorMantissa: 0});\r\n        Market storage m = markets[address(cToken)];\r\n        m.isListed = true;\r\n        m.isComped = false;\r\n        m.collateralFactorMantissa = 0;\r\n\r\n        // console.log('before _addMarketInternal');\r\n        _addMarketInternal(address(cToken));\r\n        // console.log('ctoken listed 1:', address(cToken));\r\n\r\n        emit MarketListed(CToken(cToken));\r\n\r\n        // console.log('ctoken listed success');\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _addMarketInternal(address cToken) internal {\r\n        for (uint i = 0; i < allMarkets.length; i ++) {\r\n            // if (allMarkets[i] == CToken(cToken)) {\r\n            //     console.log('ctoken %s exist in market at %d', cToken, i);\r\n            // }\r\n            require(allMarkets[i] != CToken(cToken), \"market already added\");\r\n        }\r\n        allMarkets.push(CToken(cToken));\r\n    }\r\n\r\n\r\n    /**\r\n      * @notice Set the given borrow caps for the given cToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\r\n      * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\r\n      * @param cTokens The addresses of the markets (tokens) to change the borrow caps for\r\n      * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\r\n      */\r\n    function _setMarketBorrowCaps(CToken[] calldata cTokens, uint[] calldata newBorrowCaps) external {\r\n        require(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set borrow caps\");\r\n\r\n        uint numMarkets = cTokens.length;\r\n        uint numBorrowCaps = newBorrowCaps.length;\r\n\r\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\r\n\r\n        for(uint i = 0; i < numMarkets; i++) {\r\n            borrowCaps[address(cTokens[i])] = newBorrowCaps[i];\r\n            emit NewBorrowCap(cTokens[i], newBorrowCaps[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Admin function to change the Borrow Cap Guardian\r\n     * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian\r\n     */\r\n    function _setBorrowCapGuardian(address newBorrowCapGuardian) external {\r\n        require(msg.sender == admin, \"only admin can set borrow cap guardian\");\r\n\r\n        // Save current value for inclusion in log\r\n        address oldBorrowCapGuardian = borrowCapGuardian;\r\n\r\n        // Store borrowCapGuardian with value newBorrowCapGuardian\r\n        borrowCapGuardian = newBorrowCapGuardian;\r\n\r\n        // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\r\n        emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\r\n    }\r\n\r\n    /**\r\n     * @notice Admin function to change the Pause Guardian\r\n     * @param newPauseGuardian The address of the new Pause Guardian\r\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\r\n     */\r\n    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\r\n        }\r\n\r\n        // Save current value for inclusion in log\r\n        address oldPauseGuardian = pauseGuardian;\r\n\r\n        // Store pauseGuardian with value newPauseGuardian\r\n        pauseGuardian = newPauseGuardian;\r\n\r\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\r\n        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _setMintPaused(CToken cToken, bool state) public returns (bool) {\r\n        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\r\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\r\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\r\n\r\n        mintGuardianPaused[address(cToken)] = state;\r\n        emit ActionPaused(cToken, \"Mint\", state);\r\n        return state;\r\n    }\r\n\r\n    function _setBorrowPaused(CToken cToken, bool state) public returns (bool) {\r\n        require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\r\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\r\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\r\n\r\n        borrowGuardianPaused[address(cToken)] = state;\r\n        emit ActionPaused(cToken, \"Borrow\", state);\r\n        return state;\r\n    }\r\n\r\n    function _setTransferPaused(bool state) public returns (bool) {\r\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\r\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\r\n\r\n        transferGuardianPaused = state;\r\n        emit ActionPausedAll(\"Transfer\", state);\r\n        return state;\r\n    }\r\n\r\n    function _setSeizePaused(bool state) public returns (bool) {\r\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\r\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\r\n\r\n        seizeGuardianPaused = state;\r\n        emit ActionPausedAll(\"Seize\", state);\r\n        return state;\r\n    }\r\n\r\n    function _become(Unitroller unitroller) public {\r\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\r\n        require(unitroller._acceptImplementation() == 0, \"change not authorized\");\r\n    }\r\n\r\n    /**\r\n     * @notice Checks caller is admin, or this contract is becoming the new implementation\r\n     */\r\n    function adminOrInitializing() internal view returns (bool) {\r\n        return msg.sender == admin || msg.sender == comptrollerImplementation;\r\n    }\r\n\r\n    /*** LHB Distribution ***/\r\n\r\n    /**\r\n     * @notice Recalculate and update LHB speeds for all LHB markets\r\n     */\r\n    function refreshCompSpeeds() public {\r\n        require(msg.sender == tx.origin, \"only externally owned accounts may refresh speeds\");\r\n        refreshCompSpeedsInternal();\r\n    }\r\n\r\n    function refreshCompSpeedsInternal() internal {\r\n        CToken[] memory allMarkets_ = allMarkets;\r\n\r\n        for (uint i = 0; i < allMarkets_.length; i++) {\r\n            CToken cToken = allMarkets_[i];\r\n            Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});\r\n            updateCompSupplyIndex(address(cToken));\r\n            updateCompBorrowIndex(address(cToken), borrowIndex);\r\n        }\r\n\r\n        Exp memory totalUtility = Exp({mantissa: 0});\r\n        Exp[] memory utilities = new Exp[](allMarkets_.length);\r\n        for (uint i = 0; i < allMarkets_.length; i++) {\r\n            CToken cToken = allMarkets_[i];\r\n            if (markets[address(cToken)].isComped) {\r\n                Exp memory assetPrice = Exp({mantissa: oracle.getUnderlyingPrice(cToken)});\r\n                Exp memory utility = mul_(assetPrice, cToken.totalBorrows());\r\n                utilities[i] = utility;\r\n                totalUtility = add_(totalUtility, utility);\r\n            }\r\n        }\r\n\r\n        for (uint i = 0; i < allMarkets_.length; i++) {\r\n            CToken cToken = allMarkets[i];\r\n            uint newSpeed = totalUtility.mantissa > 0 ? mul_(compRate, div_(utilities[i], totalUtility)) : 0;\r\n            compSpeeds[address(cToken)] = newSpeed;\r\n            emit CompSpeedUpdated(cToken, newSpeed);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue LHB to the market by updating the supply index\r\n     * @param cToken The market whose supply index to update\r\n     */\r\n    function updateCompSupplyIndex(address cToken) internal {\r\n        CompMarketState storage supplyState = compSupplyState[cToken];\r\n        uint supplySpeed = compSpeeds[cToken];\r\n        uint blockNumber = getBlockNumber();\r\n        uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));\r\n        if (deltaBlocks > 0 && supplySpeed > 0) {\r\n            uint supplyTokens = CToken(cToken).totalSupply();\r\n            uint compAccrued = mul_(deltaBlocks, supplySpeed);\r\n            Double memory ratio = supplyTokens > 0 ? fraction(compAccrued, supplyTokens) : Double({mantissa: 0});\r\n            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\r\n            compSupplyState[cToken] = CompMarketState({\r\n                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\r\n                block: safe32(blockNumber, \"block number exceeds 32 bits\")\r\n                });\r\n        } else if (deltaBlocks > 0) {\r\n            supplyState.block = safe32(blockNumber, \"block number exceeds 32 bits\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue LHB to the market by updating the borrow index\r\n     * @param cToken The market whose borrow index to update\r\n     */\r\n    function updateCompBorrowIndex(address cToken, Exp memory marketBorrowIndex) internal {\r\n        CompMarketState storage borrowState = compBorrowState[cToken];\r\n        uint borrowSpeed = compSpeeds[cToken];\r\n        uint blockNumber = getBlockNumber();\r\n        uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));\r\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\r\n            uint borrowAmount = div_(CToken(cToken).totalBorrows(), marketBorrowIndex);\r\n            uint compAccrued = mul_(deltaBlocks, borrowSpeed);\r\n            Double memory ratio = borrowAmount > 0 ? fraction(compAccrued, borrowAmount) : Double({mantissa: 0});\r\n            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\r\n            compBorrowState[cToken] = CompMarketState({\r\n                index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\r\n                block: safe32(blockNumber, \"block number exceeds 32 bits\")\r\n                });\r\n        } else if (deltaBlocks > 0) {\r\n            borrowState.block = safe32(blockNumber, \"block number exceeds 32 bits\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate LHB accrued by a supplier and possibly transfer it to them\r\n     * @param cToken The market in which the supplier is interacting\r\n     * @param supplier The address of the supplier to distribute LHB to\r\n     */\r\n    function distributeSupplierComp(address cToken, address supplier, bool distributeAll) internal {\r\n        CompMarketState storage supplyState = compSupplyState[cToken];\r\n        Double memory supplyIndex = Double({mantissa: supplyState.index});\r\n        Double memory supplierIndex = Double({mantissa: compSupplierIndex[cToken][supplier]});\r\n        compSupplierIndex[cToken][supplier] = supplyIndex.mantissa;\r\n\r\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\r\n            supplierIndex.mantissa = compInitialIndex;\r\n        }\r\n\r\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\r\n        uint supplierTokens = CToken(cToken).balanceOf(supplier);\r\n        uint supplierDelta = mul_(supplierTokens, deltaIndex);\r\n        uint supplierAccrued = add_(compAccrued[supplier], supplierDelta);\r\n        compAccrued[supplier] = transferComp(supplier, supplierAccrued, distributeAll ? 0 : compClaimThreshold);\r\n        emit DistributedSupplierComp(CToken(cToken), supplier, supplierDelta, supplyIndex.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate LHB accrued by a borrower and possibly transfer it to them\r\n     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.\r\n     * @param cToken The market in which the borrower is interacting\r\n     * @param borrower The address of the borrower to distribute LHB to\r\n     */\r\n    function distributeBorrowerComp(address cToken, address borrower, Exp memory marketBorrowIndex, bool distributeAll) internal {\r\n        CompMarketState storage borrowState = compBorrowState[cToken];\r\n        Double memory borrowIndex = Double({mantissa: borrowState.index});\r\n        Double memory borrowerIndex = Double({mantissa: compBorrowerIndex[cToken][borrower]});\r\n        compBorrowerIndex[cToken][borrower] = borrowIndex.mantissa;\r\n\r\n        if (borrowerIndex.mantissa > 0) {\r\n            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\r\n            uint borrowerAmount = div_(CToken(cToken).borrowBalanceStored(borrower), marketBorrowIndex);\r\n            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\r\n            uint borrowerAccrued = add_(compAccrued[borrower], borrowerDelta);\r\n            compAccrued[borrower] = transferComp(borrower, borrowerAccrued, distributeAll ? 0 : compClaimThreshold);\r\n            emit DistributedBorrowerComp(CToken(cToken), borrower, borrowerDelta, borrowIndex.mantissa);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer LHB to the user, if they are above the threshold\r\n     * @dev Note: If there is not enough LHB, we do not perform the transfer all.\r\n     * @param user The address of the user to transfer LHB to\r\n     * @param userAccrued The amount of LHB to (possibly) transfer\r\n     * @return The amount of LHB which was NOT transferred to the user\r\n     */\r\n    function transferComp(address user, uint userAccrued, uint threshold) internal returns (uint) {\r\n        if (userAccrued >= threshold && userAccrued > 0) {\r\n            LendHub lhb = LendHub(getCompAddress());\r\n            uint compRemaining = lhb.balanceOf(address(this));\r\n            if (userAccrued <= compRemaining) {\r\n                lhb.transfer(user, userAccrued);\r\n                return 0;\r\n            }\r\n        }\r\n        return userAccrued;\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all the LHB accrued by holder in all markets\r\n     * @param holder The address to claim LHB for\r\n     */\r\n    function claimComp(address holder) public {\r\n        return claimComp(holder, allMarkets);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all the LHB accrued by holder in the specified markets\r\n     * @param holder The address to claim LHB for\r\n     * @param cTokens The list of markets to claim LHB in\r\n     */\r\n    function claimComp(address holder, CToken[] memory cTokens) public {\r\n        address[] memory holders = new address[](1);\r\n        holders[0] = holder;\r\n        claimComp(holders, cTokens, true, true);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all LHB accrued by the holders\r\n     * @param holders The addresses to claim LHB for\r\n     * @param cTokens The list of markets to claim LHB in\r\n     * @param borrowers Whether or not to claim LHB earned by borrowing\r\n     * @param suppliers Whether or not to claim LHB earned by supplying\r\n     */\r\n    function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {\r\n        for (uint i = 0; i < cTokens.length; i++) {\r\n            CToken cToken = cTokens[i];\r\n            require(markets[address(cToken)].isListed, \"market must be listed\");\r\n            if (borrowers == true) {\r\n                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});\r\n                updateCompBorrowIndex(address(cToken), borrowIndex);\r\n                for (uint j = 0; j < holders.length; j++) {\r\n                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);\r\n                }\r\n            }\r\n            if (suppliers == true) {\r\n                updateCompSupplyIndex(address(cToken));\r\n                for (uint j = 0; j < holders.length; j++) {\r\n                    distributeSupplierComp(address(cToken), holders[j], true);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer LHB to the user\r\n     * @dev Note: If there is not enough LHB, we do not perform the transfer all.\r\n     * @param user The address of the user to transfer LHB to\r\n     * @param amount The amount of LHB to (possibly) transfer\r\n     * @return The amount of LHB which was NOT transferred to the user\r\n     */\r\n    function grantCompInternal(address user, uint amount) internal returns (uint) {\r\n        LendHub lhb = LendHub(getCompAddress());\r\n        uint compRemaining = lhb.balanceOf(address(this));\r\n        if (amount <= compRemaining) {\r\n            lhb.transfer(user, amount);\r\n            return 0;\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    /*** LHB Distribution Admin ***/\r\n\r\n    /**\r\n     * @notice Transfer LHB to the recipient\r\n     * @dev Note: If there is not enough LHB, we do not perform the transfer all.\r\n     * @param recipient The address of the recipient to transfer LHB to\r\n     * @param amount The amount of LHB to (possibly) transfer\r\n     */\r\n    function _grantComp(address recipient, uint amount) public {\r\n        require(adminOrInitializing(), \"only admin can grant LHB\");\r\n        uint amountLeft = grantCompInternal(recipient, amount);\r\n        require(amountLeft == 0, \"insufficient LHB for grant\");\r\n        emit CompGranted(recipient, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the amount of LHB distributed per block\r\n     * @param compRate_ The amount of LHB wei per block to distribute\r\n     */\r\n    function _setCompRate(uint compRate_) public {\r\n        require(adminOrInitializing(), \"only admin can change LHB rate\");\r\n\r\n        uint oldRate = compRate;\r\n        compRate = compRate_;\r\n        emit NewCompRate(oldRate, compRate_);\r\n\r\n        refreshCompSpeedsInternal();\r\n    }\r\n\r\n    /**\r\n     * @notice Add markets to compMarkets, allowing them to earn LHB in the flywheel\r\n     * @param cTokens The addresses of the markets to add\r\n     */\r\n    function _addCompMarkets(address[] memory cTokens) public {\r\n        require(adminOrInitializing(), \"only admin can add LHB market\");\r\n\r\n        for (uint i = 0; i < cTokens.length; i++) {\r\n            _addCompMarketInternal(cTokens[i]);\r\n        }\r\n\r\n        refreshCompSpeedsInternal();\r\n    }\r\n\r\n    function _addCompMarketInternal(address cToken) internal {\r\n        Market storage market = markets[cToken];\r\n        require(market.isListed == true, \"LHB market is not listed\");\r\n        require(market.isComped == false, \"LHB market already added\");\r\n\r\n        market.isComped = true;\r\n        emit MarketComped(CToken(cToken), true);\r\n\r\n        if (compSupplyState[cToken].index == 0 && compSupplyState[cToken].block == 0) {\r\n            compSupplyState[cToken] = CompMarketState({\r\n                index: compInitialIndex,\r\n                block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\r\n                });\r\n        }\r\n\r\n        if (compBorrowState[cToken].index == 0 && compBorrowState[cToken].block == 0) {\r\n            compBorrowState[cToken] = CompMarketState({\r\n                index: compInitialIndex,\r\n                block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\r\n                });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Remove a market from compMarkets, preventing it from earning LHB in the flywheel\r\n     * @param cToken The address of the market to drop\r\n     */\r\n    function _dropCompMarket(address cToken) public {\r\n        require(msg.sender == admin, \"only admin can drop LHB market\");\r\n\r\n        Market storage market = markets[cToken];\r\n        require(market.isComped == true, \"market is not a LHB market\");\r\n\r\n        market.isComped = false;\r\n        emit MarketComped(CToken(cToken), false);\r\n\r\n        refreshCompSpeedsInternal();\r\n    }\r\n\r\n    /**\r\n     * @notice Return all of the markets\r\n     * @dev The automatic getter may be used to access an individual market.\r\n     * @return The list of market addresses\r\n     */\r\n    function getAllMarkets() public view returns (CToken[] memory) {\r\n        return allMarkets;\r\n    }\r\n\r\n    function getBlockNumber() public view returns (uint) {\r\n        return block.number;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the address of the LHB token\r\n     * @return The address of LHB\r\n     */\r\n    function getCompAddress() public pure returns (address) {\r\n        return 0x8F67854497218043E1f72908FFE38D0Ed7F24721;\r\n    }\r\n    \r\n    /**\r\n     * @notice Return the cToken address of the token, if cToken not exist, create it\r\n     * @param token The address of the token to be query\r\n     * @return The address of cToken\r\n     */\r\n    function getCTokenAddress(address token) public view returns (address) {\r\n        // todo\r\n        token;\r\n        return 0x8F67854497218043E1f72908FFE38D0Ed7F24721;\r\n    }\r\n}\r\n"
    },
    "contracts/compound/ComptrollerStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\nimport \"./CToken.sol\";\r\nimport \"./PriceOracle.sol\";\r\n\r\ncontract UnitrollerAdminStorage {\r\n    /**\r\n    * @notice Administrator for this contract\r\n    */\r\n    address public admin;\r\n\r\n    /**\r\n    * @notice Pending administrator for this contract\r\n    */\r\n    address public pendingAdmin;\r\n\r\n    /**\r\n    * @notice Active brains of Unitroller\r\n    */\r\n    address public comptrollerImplementation;\r\n\r\n    /**\r\n    * @notice Pending brains of Unitroller\r\n    */\r\n    address public pendingComptrollerImplementation;\r\n}\r\n\r\ncontract ComptrollerV1Storage is UnitrollerAdminStorage {\r\n\r\n    /**\r\n     * @notice Oracle which gives the price of any given asset\r\n     */\r\n    PriceOracle public oracle;\r\n\r\n    /**\r\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\r\n     */\r\n    uint public closeFactorMantissa;\r\n\r\n    /**\r\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\r\n     */\r\n    uint public liquidationIncentiveMantissa;\r\n\r\n    /**\r\n     * @notice Max number of assets a single account can participate in (borrow or use as collateral)\r\n     */\r\n    uint public maxAssets;\r\n\r\n    /**\r\n     * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\r\n     */\r\n    mapping(address => CToken[]) public accountAssets;\r\n\r\n}\r\n\r\ncontract ComptrollerV2Storage is ComptrollerV1Storage {\r\n    struct Market {\r\n        // @notice Whether or not this market is listed\r\n        bool isListed;\r\n\r\n        /*\r\n         * @notice Multiplier representing the most one can borrow against their collateral in this market.\r\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\r\n         *  Must be between 0 and 1, and stored as a mantissa.\r\n         */\r\n        uint collateralFactorMantissa;\r\n\r\n        // @notice Per-market mapping of \"accounts in this asset\"\r\n        mapping(address => bool) accountMembership;\r\n\r\n        // @notice Whether or not this market receives LHB\r\n        bool isComped;\r\n    }\r\n\r\n    /**\r\n     * @notice Official mapping of cTokens -> Market metadata\r\n     * @dev Used e.g. to determine if a market is supported\r\n     */\r\n    mapping(address => Market) public markets;\r\n\r\n\r\n    /**\r\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\r\n     *  Actions which allow users to remove their own assets cannot be paused.\r\n     *  Liquidation / seizing / transfer can only be paused globally, not by market.\r\n     */\r\n    address public pauseGuardian;\r\n    bool public _mintGuardianPaused;\r\n    bool public _borrowGuardianPaused;\r\n    bool public transferGuardianPaused;\r\n    bool public seizeGuardianPaused;\r\n    mapping(address => bool) public mintGuardianPaused;\r\n    mapping(address => bool) public borrowGuardianPaused;\r\n}\r\n\r\ncontract ComptrollerV3Storage is ComptrollerV2Storage {\r\n    struct CompMarketState {\r\n        // @notice The market's last updated compBorrowIndex or compSupplyIndex\r\n        uint224 index;\r\n\r\n        // @notice The block number the index was last updated at\r\n        uint32 block;\r\n    }\r\n\r\n    /// @notice A list of all markets\r\n    CToken[] public allMarkets;\r\n\r\n    /// @notice The rate at which the flywheel distributes LHB, per block\r\n    uint public compRate;\r\n\r\n    /// @notice The portion of compRate that each market currently receives\r\n    mapping(address => uint) public compSpeeds;\r\n\r\n    /// @notice The LHB market supply state for each market\r\n    mapping(address => CompMarketState) public compSupplyState;\r\n\r\n    /// @notice The LHB market borrow state for each market\r\n    mapping(address => CompMarketState) public compBorrowState;\r\n\r\n    /// @notice The LHB borrow index for each market for each supplier as of the last time they accrued LHB\r\n    mapping(address => mapping(address => uint)) public compSupplierIndex;\r\n\r\n    /// @notice The LHB borrow index for each market for each borrower as of the last time they accrued LHB\r\n    mapping(address => mapping(address => uint)) public compBorrowerIndex;\r\n\r\n    /// @notice The LHB accrued but not yet transferred to each user\r\n    mapping(address => uint) public compAccrued;\r\n}\r\n\r\ncontract ComptrollerV4Storage is ComptrollerV3Storage {\r\n    // @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\r\n    address public borrowCapGuardian;\r\n\r\n    // @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\r\n    mapping(address => uint) public borrowCaps;\r\n}\r\n\r\n// struct Position {\r\n//     address owner;\r\n//     uint256 productionId;  // lend 池中的代币 CToken\r\n//     uint256 debtShare;\r\n// }\r\n\r\ncontract ComptrollerV5Storage is ComptrollerV4Storage {\r\n    address public marginLP;    // 杠杆 LP 地址\r\n    address public marginSwap;  // 杠杆 Swap 地址\r\n}\r\n"
    },
    "contracts/compound/Unitroller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\nimport \"./ErrorReporter.sol\";\r\nimport \"./ComptrollerStorage.sol\";\r\n/**\r\n * @title ComptrollerCore\r\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\r\n * CTokens should reference this contract as their comptroller.\r\n */\r\ncontract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\r\n\r\n    /**\r\n      * @notice Emitted when pendingComptrollerImplementation is changed\r\n      */\r\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\r\n\r\n    /**\r\n      * @notice Emitted when pendingComptrollerImplementation is accepted, which means comptroller implementation is updated\r\n      */\r\n    event NewImplementation(address oldImplementation, address newImplementation);\r\n\r\n    /**\r\n      * @notice Emitted when pendingAdmin is changed\r\n      */\r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n    /**\r\n      * @notice Emitted when pendingAdmin is accepted, which means admin is updated\r\n      */\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n    constructor() public {\r\n        // Set admin to caller\r\n        admin = msg.sender;\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\r\n\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\r\n        }\r\n\r\n        address oldPendingImplementation = pendingComptrollerImplementation;\r\n\r\n        pendingComptrollerImplementation = newPendingImplementation;\r\n\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n    * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation\r\n    * @dev Admin function for new implementation to accept it's role as implementation\r\n    * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n    */\r\n    function _acceptImplementation() public returns (uint) {\r\n        // Check caller is pendingImplementation and pendingImplementation ≠ address(0)\r\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\r\n        }\r\n\r\n        // Save current values for inclusion in log\r\n        address oldImplementation = comptrollerImplementation;\r\n        address oldPendingImplementation = pendingComptrollerImplementation;\r\n\r\n        comptrollerImplementation = pendingComptrollerImplementation;\r\n\r\n        pendingComptrollerImplementation = address(0);\r\n\r\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n\r\n    /**\r\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @param newPendingAdmin New pending admin.\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\r\n        // Check caller = admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\r\n        }\r\n\r\n        // Save current value, if any, for inclusion in log\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store pendingAdmin with value newPendingAdmin\r\n        pendingAdmin = newPendingAdmin;\r\n\r\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\r\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\r\n      * @dev Admin function for pending admin to accept role and update admin\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _acceptAdmin() public returns (uint) {\r\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\r\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\r\n        }\r\n\r\n        // Save current values for inclusion in log\r\n        address oldAdmin = admin;\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store admin with value pendingAdmin\r\n        admin = pendingAdmin;\r\n\r\n        // Clear the pending value\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(oldAdmin, admin);\r\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @dev Delegates execution to an implementation contract.\r\n     * It returns to the external caller whatever the implementation returns\r\n     * or forwards reverts.\r\n     */\r\n    // function () payable external {\r\n    function() external payable {\r\n        // delegate all other functions to current implementation\r\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\r\n\r\n        assembly {\r\n              let free_mem_ptr := mload(0x40)\r\n              returndatacopy(free_mem_ptr, 0, returndatasize())\r\n\r\n              switch success\r\n              case 0 { revert(free_mem_ptr, returndatasize()) }\r\n              default { return(free_mem_ptr, returndatasize()) }\r\n        }\r\n    }\r\n    // receive() external payable {\r\n    //     // delegate all other functions to current implementation\r\n    //     (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\r\n\r\n    //     assembly {\r\n    //           let free_mem_ptr := mload(0x40)\r\n    //           returndatacopy(free_mem_ptr, 0, returndatasize())\r\n\r\n    //           switch success\r\n    //           case 0 { revert(free_mem_ptr, returndatasize()) }\r\n    //           default { return(free_mem_ptr, returndatasize()) }\r\n    //     }\r\n    // }\r\n}\r\n"
    },
    "contracts/common/IMdexFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity ^0.5.16;\r\n\r\nimport \"./LErc20DelegatorInterface.sol\";\r\n\r\ninterface IDeBankFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function router() external view returns (address);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function lpFeeRate() external view returns (uint256);\r\n\r\n    function lErc20DelegatorFactory() external view returns (LErc20DelegatorInterface);\r\n\r\n    function anchorToken() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function allPairs(uint) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n\r\n    function setFeeToRate(uint256) external;\r\n\r\n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, address token1);\r\n\r\n    function pairFor(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function getReserves(address tokenA, address tokenB) external view returns (uint256 reserveA, uint256 reserveB);\r\n\r\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint256 amountB);\r\n\r\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountOut);\r\n\r\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountIn);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\r\n\r\n    function amountToCTokenAmt(address ctoken, uint amountIn) external view returns (uint cAmountIn);\r\n    function ctokenAmtToAmount(address ctoken, uint cAmountOut) external view returns (uint amountOut);\r\n\r\n    function setPairFeeRate(address pair, uint feeRate) external;\r\n\r\n    function getReservesFeeRate(address tokenA, address tokenB) external view returns (uint reserveA, uint reserveB, uint feeRate, bool outAnchorToken);\r\n\r\n    function getAmountOutFeeRate(uint amountIn, uint reserveIn, uint reserveOut, uint feeRate) external pure returns (uint amountOut);\r\n\r\n    function getAmountInFeeRate(uint amountOut, uint reserveIn, uint reserveOut, uint feeRate) external pure returns (uint amountIn);\r\n\r\n    function getAmountOutFeeRateAnchorToken(uint amountIn, uint reserveIn, uint reserveOut, uint feeRate) external pure returns (uint amountOut);\r\n\r\n    function setAnchorToken(address _token) external;\r\n}\r\n\r\ninterface IMdexFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function router() external view returns (address);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function lpFeeRate() external view returns (uint256);\r\n\r\n    function lErc20DelegatorFactory() external view returns (LErc20DelegatorInterface);\r\n\r\n    function anchorToken() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function allPairs(uint) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n\r\n    function setFeeToRate(uint256) external;\r\n\r\n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, address token1);\r\n\r\n    function pairFor(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function getReserves(address tokenA, address tokenB) external view returns (uint256 reserveA, uint256 reserveB);\r\n\r\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint256 amountB);\r\n\r\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountOut);\r\n\r\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountIn);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\r\n\r\n    function amountToCTokenAmt(address ctoken, uint amountIn) external view returns (uint cAmountIn);\r\n    function ctokenAmtToAmount(address ctoken, uint cAmountOut) external view returns (uint amountOut);\r\n\r\n    function setPairFeeRate(address pair, uint feeRate) external;\r\n\r\n    function getReservesFeeRate(address tokenA, address tokenB) external view returns (uint reserveA, uint reserveB, uint feeRate, bool outAnchorToken);\r\n\r\n    function getAmountOutFeeRate(uint amountIn, uint reserveIn, uint reserveOut, uint feeRate) external pure returns (uint amountOut);\r\n\r\n    function getAmountInFeeRate(uint amountOut, uint reserveIn, uint reserveOut, uint feeRate) external pure returns (uint amountIn);\r\n\r\n    function getAmountOutFeeRateAnchorToken(uint amountIn, uint reserveIn, uint reserveOut, uint feeRate) external pure returns (uint amountOut);\r\n\r\n    function setAnchorToken(address _token) external;\r\n}\r\n"
    },
    "contracts/common/Router.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./libraries/SafeMath.sol\";\r\nimport \"./IMdexFactory.sol\";\r\nimport \"./IMdexPair.sol\";\r\n\r\ninterface IMdexRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WHT() external pure returns (address);\r\n\r\n    function swapMining() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external view returns (uint256 amountB);\r\n\r\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountOut);\r\n\r\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) external view returns (uint256 amountIn);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\r\n\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface ISwapMining {\r\n    function swap(address account, address input, address output, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IWHT {\r\n    function deposit() external payable;\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function withdraw(uint) external;\r\n}\r\n\r\ncontract MdexRouter is IMdexRouter, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    address public  factory;\r\n    address public  WHT;\r\n    address public  swapMining;\r\n\r\n    modifier ensure(uint deadline) {\r\n        require(deadline >= block.timestamp, 'DeBankRouter: EXPIRED');\r\n        _;\r\n    }\r\n\r\n    constructor(address _factory, address _WHT) public {\r\n        factory = _factory;\r\n        WHT = _WHT;\r\n    }\r\n\r\n    // receive() external payable {\r\n    //     assert(msg.sender == WHT);\r\n    //     // only accept HT via fallback from the WHT contract\r\n    // }\r\n\r\n    function pairFor(address tokenA, address tokenB) public view returns (address pair){\r\n        pair = IMdexFactory(factory).pairFor(tokenA, tokenB);\r\n    }\r\n\r\n    function setSwapMining(address _swapMininng) public onlyOwner {\r\n        swapMining = _swapMininng;\r\n    }\r\n\r\n    // **** ADD LIQUIDITY ****\r\n    function _addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin\r\n    ) internal returns (uint amountA, uint amountB) {\r\n        // create the pair if it doesn't exist yet\r\n        if (IMdexFactory(factory).getPair(tokenA, tokenB) == address(0)) {\r\n            IMdexFactory(factory).createPair(tokenA, tokenB);\r\n        }\r\n        (uint reserveA, uint reserveB) = IMdexFactory(factory).getReserves(tokenA, tokenB);\r\n        if (reserveA == 0 && reserveB == 0) {\r\n            (amountA, amountB) = (amountADesired, amountBDesired);\r\n        } else {\r\n            uint amountBOptimal = IMdexFactory(factory).quote(amountADesired, reserveA, reserveB);\r\n            if (amountBOptimal <= amountBDesired) {\r\n                require(amountBOptimal >= amountBMin, 'DeBankRouter: INSUFFICIENT_B_AMOUNT');\r\n                (amountA, amountB) = (amountADesired, amountBOptimal);\r\n            } else {\r\n                uint amountAOptimal = IMdexFactory(factory).quote(amountBDesired, reserveB, reserveA);\r\n                assert(amountAOptimal <= amountADesired);\r\n                require(amountAOptimal >= amountAMin, 'DeBankRouter: INSUFFICIENT_A_AMOUNT');\r\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external  ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\r\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\r\n        address pair = pairFor(tokenA, tokenB);\r\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\r\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\r\n        liquidity = IMdexPair(pair).mint(to);\r\n    }\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external  payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\r\n        (amountToken, amountETH) = _addLiquidity(\r\n            token,\r\n            WHT,\r\n            amountTokenDesired,\r\n            msg.value,\r\n            amountTokenMin,\r\n            amountETHMin\r\n        );\r\n        address pair = pairFor(token, WHT);\r\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\r\n        IWHT(WHT).deposit.value(amountETH)();\r\n        assert(IWHT(WHT).transfer(pair, amountETH));\r\n        liquidity = IMdexPair(pair).mint(to);\r\n        // refund dust eth, if any\r\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\r\n    }\r\n\r\n    // **** REMOVE LIQUIDITY ****\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) public  ensure(deadline) returns (uint amountA, uint amountB) {\r\n        address pair = pairFor(tokenA, tokenB);\r\n        IMdexPair(pair).transferFrom(msg.sender, pair, liquidity);\r\n        // send liquidity to pair\r\n        (uint amount0, uint amount1) = IMdexPair(pair).burn(to);\r\n        (address token0,) = IMdexFactory(factory).sortTokens(tokenA, tokenB);\r\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\r\n        require(amountA >= amountAMin, 'DeBankRouter: INSUFFICIENT_A_AMOUNT');\r\n        require(amountB >= amountBMin, 'DeBankRouter: INSUFFICIENT_B_AMOUNT');\r\n    }\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) public  ensure(deadline) returns (uint amountToken, uint amountETH) {\r\n        (amountToken, amountETH) = removeLiquidity(\r\n            token,\r\n            WHT,\r\n            liquidity,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            address(this),\r\n            deadline\r\n        );\r\n        TransferHelper.safeTransfer(token, to, amountToken);\r\n        IWHT(WHT).withdraw(amountETH);\r\n        TransferHelper.safeTransferETH(to, amountETH);\r\n    }\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external  returns (uint amountA, uint amountB) {\r\n        address pair = pairFor(tokenA, tokenB);\r\n        uint value = approveMax ? uint(- 1) : liquidity;\r\n        IMdexPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\r\n    }\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external  returns (uint amountToken, uint amountETH) {\r\n        address pair = pairFor(token, WHT);\r\n        uint value = approveMax ? uint(- 1) : liquidity;\r\n        IMdexPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\r\n    }\r\n\r\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) public  ensure(deadline) returns (uint amountETH) {\r\n        (, amountETH) = removeLiquidity(\r\n            token,\r\n            WHT,\r\n            liquidity,\r\n            amountTokenMin,\r\n            amountETHMin,\r\n            address(this),\r\n            deadline\r\n        );\r\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\r\n        IWHT(WHT).withdraw(amountETH);\r\n        TransferHelper.safeTransferETH(to, amountETH);\r\n    }\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external  returns (uint amountETH) {\r\n        address pair = pairFor(token, WHT);\r\n        uint value = approveMax ? uint(- 1) : liquidity;\r\n        IMdexPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\r\n            token, liquidity, amountTokenMin, amountETHMin, to, deadline\r\n        );\r\n    }\r\n\r\n    // **** SWAP ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal {\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = IMdexFactory(factory).sortTokens(input, output);\r\n            uint amountOut = amounts[i + 1];\r\n            if (swapMining != address(0)) {\r\n                ISwapMining(swapMining).swap(msg.sender, input, output, amountOut);\r\n            }\r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\r\n            address to = i < path.length - 2 ? pairFor(output, path[i + 2]) : _to;\r\n            IMdexPair(pairFor(input, output)).swap(\r\n                amount0Out, amount1Out, to, new bytes(0)\r\n            );\r\n        }\r\n    }\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external  ensure(deadline) returns (uint[] memory amounts) {\r\n        amounts = IMdexFactory(factory).getAmountsOut(amountIn, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'DeBankRouter: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, to);\r\n    }\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external  ensure(deadline) returns (uint[] memory amounts) {\r\n        amounts = IMdexFactory(factory).getAmountsIn(amountOut, path);\r\n        require(amounts[0] <= amountInMax, 'DeBankRouter: EXCESSIVE_INPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, to);\r\n    }\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    \r\n    \r\n    payable\r\n    ensure(deadline)\r\n    returns (uint[] memory amounts)\r\n    {\r\n        require(path[0] == WHT, 'DeBankRouter: INVALID_PATH');\r\n        amounts = IMdexFactory(factory).getAmountsOut(msg.value, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'DeBankRouter: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        IWHT(WHT).deposit.value(amounts[0])();\r\n        assert(IWHT(WHT).transfer(pairFor(path[0], path[1]), amounts[0]));\r\n        _swap(amounts, path, to);\r\n    }\r\n\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    \r\n    \r\n    ensure(deadline)\r\n    returns (uint[] memory amounts)\r\n    {\r\n        require(path[path.length - 1] == WHT, 'DeBankRouter: INVALID_PATH');\r\n        amounts = IMdexFactory(factory).getAmountsIn(amountOut, path);\r\n        require(amounts[0] <= amountInMax, 'DeBankRouter: EXCESSIVE_INPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, address(this));\r\n        IWHT(WHT).withdraw(amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    \r\n    \r\n    ensure(deadline)\r\n    returns (uint[] memory amounts)\r\n    {\r\n        require(path[path.length - 1] == WHT, 'DeBankRouter: INVALID_PATH');\r\n        amounts = IMdexFactory(factory).getAmountsOut(amountIn, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'DeBankRouter: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, address(this));\r\n        IWHT(WHT).withdraw(amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    \r\n    \r\n    payable\r\n    ensure(deadline)\r\n    returns (uint[] memory amounts)\r\n    {\r\n        require(path[0] == WHT, 'DeBankRouter: INVALID_PATH');\r\n        amounts = IMdexFactory(factory).getAmountsIn(amountOut, path);\r\n        require(amounts[0] <= msg.value, 'DeBankRouter: EXCESSIVE_INPUT_AMOUNT');\r\n        IWHT(WHT).deposit.value(amounts[0])();\r\n        assert(IWHT(WHT).transfer(pairFor(path[0], path[1]), amounts[0]));\r\n        _swap(amounts, path, to);\r\n        // refund dust eth, if any\r\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\r\n    }\r\n\r\n    // **** SWAP (supporting fee-on-transfer tokens) ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal {\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = IMdexFactory(factory).sortTokens(input, output);\r\n            IMdexPair pair = IMdexPair(pairFor(input, output));\r\n            uint amountInput;\r\n            uint amountOutput;\r\n            {// scope to avoid stack too deep errors\r\n                (uint reserve0, uint reserve1,) = pair.getReserves();\r\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n                amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\r\n                amountOutput = IMdexFactory(factory).getAmountOut(amountInput, reserveInput, reserveOutput);\r\n            }\r\n            if (swapMining != address(0)) {\r\n                ISwapMining(swapMining).swap(msg.sender, input, output, amountOutput);\r\n            }\r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\r\n            address to = i < path.length - 2 ? pairFor(output, path[i + 2]) : _to;\r\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\r\n        }\r\n    }\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external  ensure(deadline) {\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, pairFor(path[0], path[1]), amountIn\r\n        );\r\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\r\n        _swapSupportingFeeOnTransferTokens(path, to);\r\n        require(\r\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\r\n            'DeBankRouter: INSUFFICIENT_OUTPUT_AMOUNT'\r\n        );\r\n    }\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    )\r\n    external\r\n    \r\n    \r\n    payable\r\n    ensure(deadline)\r\n    {\r\n        require(path[0] == WHT, 'DeBankRouter: INVALID_PATH');\r\n        uint amountIn = msg.value;\r\n        IWHT(WHT).deposit.value(amountIn)();\r\n        assert(IWHT(WHT).transfer(pairFor(path[0], path[1]), amountIn));\r\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\r\n        _swapSupportingFeeOnTransferTokens(path, to);\r\n        require(\r\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\r\n            'DeBankRouter: INSUFFICIENT_OUTPUT_AMOUNT'\r\n        );\r\n    }\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    )\r\n    external\r\n    \r\n    \r\n    ensure(deadline)\r\n    {\r\n        require(path[path.length - 1] == WHT, 'DeBankRouter: INVALID_PATH');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, pairFor(path[0], path[1]), amountIn\r\n        );\r\n        _swapSupportingFeeOnTransferTokens(path, address(this));\r\n        uint amountOut = IERC20(WHT).balanceOf(address(this));\r\n        require(amountOut >= amountOutMin, 'DeBankRouter: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        IWHT(WHT).withdraw(amountOut);\r\n        TransferHelper.safeTransferETH(to, amountOut);\r\n    }\r\n\r\n    // **** LIBRARY FUNCTIONS ****\r\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) public view  returns (uint256 amountB) {\r\n        return IMdexFactory(factory).quote(amountA, reserveA, reserveB);\r\n    }\r\n\r\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) public view  returns (uint256 amountOut){\r\n        return IMdexFactory(factory).getAmountOut(amountIn, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) public view  returns (uint256 amountIn){\r\n        return IMdexFactory(factory).getAmountIn(amountOut, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] memory path) public view  returns (uint256[] memory amounts){\r\n        return IMdexFactory(factory).getAmountsOut(amountIn, path);\r\n    }\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] memory path) public view  returns (uint256[] memory amounts){\r\n        return IMdexFactory(factory).getAmountsIn(amountOut, path);\r\n    }\r\n\r\n}\r\n\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call.value(value)(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n"
    },
    "contracts/common/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.5.16;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    function _msgSender() internal view  returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view  returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view  returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public  onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public  onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n"
    },
    "contracts/common/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity >=0.5.16;\r\n\r\nlibrary SafeMath {\r\n    uint256 constant WAD = 10 ** 18;\r\n    uint256 constant RAY = 10 ** 27;\r\n\r\n    function wad() public pure returns (uint256) {\r\n        return WAD;\r\n    }\r\n\r\n    function ray() public pure returns (uint256) {\r\n        return RAY;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a <= b ? a : b;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function sqrt(uint256 a) internal pure returns (uint256 b) {\r\n        if (a > 3) {\r\n            b = a;\r\n            uint256 x = a / 2 + 1;\r\n            while (x < b) {\r\n                b = x;\r\n                x = (a / x + x) / 2;\r\n            }\r\n        } else if (a != 0) {\r\n            b = 1;\r\n        }\r\n    }\r\n\r\n    function wmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mul(a, b) / WAD;\r\n    }\r\n\r\n    function wmulRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, b), WAD / 2) / WAD;\r\n    }\r\n\r\n    function rmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mul(a, b) / RAY;\r\n    }\r\n\r\n    function rmulRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, b), RAY / 2) / RAY;\r\n    }\r\n\r\n    function wdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(mul(a, WAD), b);\r\n    }\r\n\r\n    function wdivRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, WAD), b / 2) / b;\r\n    }\r\n\r\n    function rdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(mul(a, RAY), b);\r\n    }\r\n\r\n    function rdivRound(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return add(mul(a, RAY), b / 2) / b;\r\n    }\r\n\r\n    function wpow(uint256 x, uint256 n) internal pure returns (uint256) {\r\n        uint256 result = WAD;\r\n        while (n > 0) {\r\n            if (n % 2 != 0) {\r\n                result = wmul(result, x);\r\n            }\r\n            x = wmul(x, x);\r\n            n /= 2;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256) {\r\n        uint256 result = RAY;\r\n        while (n > 0) {\r\n            if (n % 2 != 0) {\r\n                result = rmul(result, x);\r\n            }\r\n            x = rmul(x, x);\r\n            n /= 2;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n"
    },
    "contracts/common/IMdexPair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity ^0.5.16;\r\n\r\ninterface IDeBankPair {\r\n    // event Approval(address indexed owner, address indexed spender, uint value);\r\n    // event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function feeRate() external view returns (uint);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function price0CumulativeLast() external view returns (uint);\r\n\r\n    function price1CumulativeLast() external view returns (uint);\r\n\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    // function mintCToken(address to) external returns (uint liquidity);\r\n\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n\r\n    function swapNoFee(uint amount0Out, uint amount1Out, address to, uint fee) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function price(address token, uint256 baseDecimal) external view returns (uint256);\r\n\r\n    function initialize(address, address) external;\r\n    function updateFeeRate(uint256 _feeRate) external;\r\n    // initialize ctoken address\r\n    function initializeCTokenAddress(address, address) external;\r\n\r\n    function getFee(uint256 amt) external view returns (uint256);\r\n\r\n    // function updateFeeRate(_feeRate) external;\r\n}\r\n\r\n\r\ninterface IMdexPair {\r\n    // event Approval(address indexed owner, address indexed spender, uint value);\r\n    // event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function feeRate() external view returns (uint);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function price0CumulativeLast() external view returns (uint);\r\n\r\n    function price1CumulativeLast() external view returns (uint);\r\n\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    // function mintCToken(address to) external returns (uint liquidity);\r\n\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n\r\n    function swapNoFee(uint amount0Out, uint amount1Out, address to, uint fee) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function price(address token, uint256 baseDecimal) external view returns (uint256);\r\n\r\n    function initialize(address, address) external;\r\n    function updateFeeRate(uint256 _feeRate) external;\r\n    // initialize ctoken address\r\n    function initializeCTokenAddress(address, address) external;\r\n\r\n    function getFee(uint256 amt) external view returns (uint256);\r\n\r\n    // function updateFeeRate(_feeRate) external;\r\n}\r\n\r\n"
    },
    "contracts/compound/WhitePaperInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\nimport \"../common/InterestRateModel.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\n/**\r\n  * @title debankex's WhitePaperInterestRateModel Contract\r\n  * @author debankex\r\n  * @notice The parameterized model described in section 2.4 of the original debankex Protocol whitepaper\r\n  */\r\ncontract WhitePaperInterestRateModel is InterestRateModel {\r\n    using SafeMath for uint;\r\n\r\n    event NewInterestParams(uint baseRatePerBlock, uint multiplierPerBlock);\r\n\r\n    /**\r\n     * @notice The approximate number of blocks per year that is assumed by the interest rate model\r\n     */\r\n    uint public constant blocksPerYear = 10512000;\r\n\r\n    /**\r\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\r\n     */\r\n    uint public multiplierPerBlock;\r\n\r\n    /**\r\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\r\n     */\r\n    uint public baseRatePerBlock;\r\n\r\n    /**\r\n     * @notice Construct an interest rate model\r\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\r\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\r\n     */\r\n    constructor(uint baseRatePerYear, uint multiplierPerYear) public {\r\n        baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\r\n        multiplierPerBlock = multiplierPerYear.div(blocksPerYear);\r\n\r\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\r\n     * @param cash The amount of cash in the market\r\n     * @param borrows The amount of borrows in the market\r\n     * @param reserves The amount of reserves in the market (currently unused)\r\n     * @return The utilization rate as a mantissa between [0, 1e18]\r\n     */\r\n    function utilizationRate(uint cash, uint borrows, uint reserves) public pure returns (uint) {\r\n        // Utilization rate is 0 when there are no borrows\r\n        if (borrows == 0) {\r\n            return 0;\r\n        }\r\n\r\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\r\n     * @param cash The amount of cash in the market\r\n     * @param borrows The amount of borrows in the market\r\n     * @param reserves The amount of reserves in the market\r\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\r\n     */\r\n    function getBorrowRate(uint cash, uint borrows, uint reserves) public view returns (uint) {\r\n        uint ur = utilizationRate(cash, borrows, reserves);\r\n        return ur.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the current supply rate per block\r\n     * @param cash The amount of cash in the market\r\n     * @param borrows The amount of borrows in the market\r\n     * @param reserves The amount of reserves in the market\r\n     * @param reserveFactorMantissa The current reserve factor for the market\r\n     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\r\n     */\r\n    function getSupplyRate(uint cash, uint borrows,\r\n                        uint reserves, uint reserveFactorMantissa) public view returns (uint) {\r\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactorMantissa);\r\n        uint borrowRate = getBorrowRate(cash, borrows, reserves);\r\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\r\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\r\n    }\r\n}\r\n"
    },
    "contracts/compound/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\r\n// Subject to the MIT license.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction underflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n"
    },
    "contracts/swap/heco/Router.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity ^0.5.16;\r\n\r\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\r\nimport \"../library/SafeMath.sol\";\r\nimport \"../interface/IERC20.sol\";\r\nimport \"../interface/IDeBankFactory.sol\";\r\nimport \"../interface/IDeBankPair.sol\";\r\nimport \"../interface/IDeBankRouter.sol\";\r\nimport \"../interface/IWHT.sol\";\r\nimport \"../interface/LErc20DelegatorInterface.sol\";\r\nimport \"../interface/ICToken.sol\";\r\n\r\n// import \"../../compound/LHT.sol\";\r\n// import \"hardhat/console.sol\";\r\n\r\ninterface ILHT {\r\n    function mint() external payable;\r\n}\r\n\r\ninterface ISwapMining {\r\n    function swap(address account, address input, address output, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract DeBankRouter is IDeBankRouter, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    address public factory;\r\n    address public WHT;\r\n    address public swapMining;\r\n    address public cWHT;\r\n    address[] public quoteTokens;\r\n    LErc20DelegatorInterface public ctokenFactory;\r\n\r\n    // 所有交易对产生的手续费收入, 各个交易对根据占比分配收益\r\n    uint public allPairFee;\r\n    // 上一个块的总手续费\r\n    uint public allPairFeeLastBlock;\r\n    // 开始分配收益的块\r\n    uint public startBlock;\r\n    // 记录当前手续费的块数\r\n    uint public currentBlock;\r\n    // tokens created per block to all pair LP\r\n    uint256 public lpPerBlock;      // LP 每块收益\r\n    uint256 public traderPerBlock;  // 交易者每块收益\r\n    address public rewardToken;     // 收益 token\r\n    address public lpDepositAddr;   // compound 流动性抵押\r\n    address public compAddr;        // compound unitroller\r\n    uint256 public feeAlloc;        // 手续费分配方案: 0: 分配给LP; 1: 不分配给LP, 平台收取后兑换为 anchorToken\r\n    // todo How many blocks are halved  182天 应该在 rewardToken 中处理\r\n    uint256 public halvingPeriod = 5256000;\r\n\r\n    modifier ensure(uint deadline) {\r\n        // solhint-disable-next-line\r\n        require(deadline >= block.timestamp, 'DeBankRouter: EXPIRED');\r\n        _;\r\n    }\r\n\r\n    constructor(address _factory, address _wht, address _cwht, address _ctokenFactory) public {\r\n        factory = _factory;\r\n        WHT = _wht;\r\n        cWHT = _cwht;\r\n        ctokenFactory = LErc20DelegatorInterface(_ctokenFactory);\r\n        // startBlock = _startBlock;\r\n        // heco 链上的 usdt\r\n        quoteTokens.push(IDeBankFactory(_factory).anchorToken()); // usdt\r\n        quoteTokens.push(_cwht); // wht\r\n        // quoteTokens.push();  // husd\r\n    }\r\n\r\n    function() external payable {\r\n        assert(msg.sender == WHT || msg.sender == cWHT);\r\n        // only accept HT via fallback from the WHT contract\r\n    }\r\n\r\n    function pairFor(address tokenA, address tokenB) public view returns (address pair) {\r\n        // pair = IDeBankFactory(factory).pairFor(tokenA, tokenB);\r\n        pair = IDeBankFactory(factory).getPair(tokenA, tokenB);\r\n    }\r\n\r\n    function setSwapMining(address _swapMininng) public onlyOwner {\r\n        swapMining = _swapMininng;\r\n    }\r\n\r\n    function resetQuoteTokens(address[] memory tokens) public onlyOwner {\r\n        for (uint i; i < quoteTokens.length; i ++) {\r\n            quoteTokens.pop();\r\n        }\r\n        // quoteTokens.length = 0;\r\n        for (uint i; i < tokens.length; i ++) {\r\n            quoteTokens.push(tokens[i]);\r\n        }\r\n    }\r\n\r\n    function addQuoteToken(address token) public onlyOwner {\r\n        quoteTokens.push(token);\r\n    }\r\n\r\n    function phase(uint256 blockNumber) public view returns (uint256) {\r\n        if (halvingPeriod == 0) {\r\n            return 0;\r\n        }\r\n        if (blockNumber > startBlock) {\r\n            return (blockNumber.sub(startBlock).sub(1)).div(halvingPeriod);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    // 计算块奖励\r\n    function reward(uint256 blockNumber) public view returns (uint256) {\r\n        if (rewardToken == address(0)) {\r\n            return 0;\r\n        }\r\n        // todo totalSupply !!!\r\n        // if (IERC20(rewardToken).totalSupply() > 1e28) {\r\n        //     return 0;\r\n        // }\r\n        uint256 _phase = phase(blockNumber);\r\n        return lpPerBlock.div(2 ** _phase);\r\n    }\r\n\r\n    // todo to be removed\r\n    function getBlockRewards(uint256 _lastRewardBlock) public view returns (uint256) {\r\n        uint256 blockReward = 0;\r\n        uint256 n = phase(_lastRewardBlock);\r\n        uint256 m = phase(block.number);\r\n        while (n < m) {\r\n            n++;\r\n            uint256 r = n.mul(halvingPeriod).add(startBlock);\r\n            blockReward = blockReward.add((r.sub(_lastRewardBlock)).mul(reward(r)));\r\n            _lastRewardBlock = r;\r\n        }\r\n        blockReward = blockReward.add((block.number.sub(_lastRewardBlock)).mul(reward(block.number)));\r\n        return blockReward;\r\n    }\r\n\r\n    function _getOrCreateCtoken(address token) private returns (address ctoken) {\r\n        // ctoken = LErc20DelegatorInterface(IDeBankFactory(factory).lErc20DelegatorFactory()).getCTokenAddress(token);\r\n        ctoken = ctokenFactory.getCTokenAddress(token);\r\n    }\r\n\r\n    function _getCtoken(address token) private view returns (address ctoken) {\r\n        // ctoken = LErc20DelegatorInterface(IDeBankFactory(factory).lErc20DelegatorFactory()).getCTokenAddressPure(token);\r\n        ctoken = ctokenFactory.getCTokenAddressPure(token);\r\n    }\r\n\r\n    function _getTokenByCtoken(address ctoken) private view returns (address token) {\r\n        // token = LErc20DelegatorInterface(IDeBankFactory(factory).lErc20DelegatorFactory()).getTokenAddress(ctoken);\r\n        token = ctokenFactory.getTokenAddress(ctoken);\r\n    }\r\n\r\n    // function _safeTransferCtoken(address token, address from, address to, uint amt) private {\r\n    //     TransferHelper.safeTransferFrom(_getCtoken(token), from, to, amt);\r\n    // }\r\n\r\n    // **** ADD LIQUIDITY ****\r\n\r\n    struct LiquidityLocalVars {\r\n        // uint amountToken;\r\n        // uint amountEth;\r\n        uint camountDesiredA;\r\n        uint camountDesiredB;\r\n        uint camountMinA;\r\n        uint camountMinB;\r\n\r\n        uint rateA;\r\n        uint rateB;\r\n        uint rateEth;\r\n        uint camountA;\r\n        uint camountB;\r\n        uint camountEth;\r\n\r\n        address tokenA;\r\n        address tokenB;\r\n        address ctokenA;\r\n        address ctokenB;\r\n    }\r\n\r\n    // tokenA tokenB 都是 cToken\r\n    function _addLiquidity(\r\n        address ctokenA,\r\n        address ctokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin\r\n    ) internal returns (uint amountA, uint amountB) {\r\n        // console.log(\"_addLiquidity\", factory);\r\n        address tokenA = _getTokenByCtoken(ctokenA);\r\n        address tokenB = _getTokenByCtoken(ctokenB);\r\n        // create the pair if it doesn't exist yet\r\n        if (IDeBankFactory(factory).getPair(tokenA, tokenB) == address(0)) {\r\n            IDeBankFactory(factory).createPair(tokenA, tokenB, ctokenA, ctokenB);\r\n        }\r\n        // console.log(\"_addLiquidity getReserves\");\r\n        (uint reserveA, uint reserveB) = IDeBankFactory(factory).getReserves(tokenA, tokenB);\r\n        if (reserveA == 0 && reserveB == 0) {\r\n            (amountA, amountB) = (amountADesired, amountBDesired);\r\n        } else {\r\n            uint amountBOptimal = IDeBankFactory(factory).quote(amountADesired, reserveA, reserveB);\r\n            // console.log(\"_addLiquidity: reserveA=%d  reserveB=%d\", reserveA, reserveB);\r\n            if (amountBOptimal <= amountBDesired) {\r\n                // console.log(\"_addLiquidity: amountBOptimal=%d  amountBDesired=%d  amountADesired=%d\",\r\n                //       amountBOptimal, amountBDesired, amountADesired);\r\n                require(amountBOptimal >= amountBMin, 'AddLiquidity: INSUFFICIENT_B_AMOUNT');\r\n                (amountA, amountB) = (amountADesired, amountBOptimal);\r\n            } else {\r\n                uint amountAOptimal = IDeBankFactory(factory).quote(amountBDesired, reserveB, reserveA);\r\n                // console.log(\"_addLiquidity: amountAOptimal=%d  amountADesired=%d  amountBDesired=%d\",\r\n                //       amountAOptimal, amountADesired, amountBDesired);\r\n                assert(amountAOptimal <= amountADesired);\r\n                require(amountAOptimal >= amountAMin, 'AddLiquidity: INSUFFICIENT_A_AMOUNT');\r\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\r\n            }\r\n        }\r\n    }\r\n\r\n    // tokenA tokenB 都是 cToken, amount 均为 ctoken 的 amount\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\r\n        // console.log(tokenA, tokenB);\r\n        // console.log(\"amountDesired:\", amountADesired, amountBDesired);\r\n        // console.log(\"amountMin:\", amountAMin, amountBMin);\r\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\r\n        address pair = pairFor(tokenA, tokenB);\r\n        // console.log(\"pair: %s\", pair);\r\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\r\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\r\n        // _safeTransferCtoken(tokenA, msg.sender, pair, amountA);\r\n        // _safeTransferCtoken(tokenB, msg.sender, pair, amountB);\r\n        liquidity = IDeBankPair(pair).mint(to);\r\n    }\r\n\r\n    function _cTokenExchangeRate(address ctoken) private view returns(uint) {\r\n        uint rate = ICToken(ctoken).exchangeRateStored();\r\n        uint256 supplyRate = ICToken(ctoken).supplyRatePerBlock();\r\n        uint256 prevBlock = ICToken(ctoken).accrualBlockNumber();\r\n        rate += rate.mul(supplyRate).mul(block.number - prevBlock);\r\n        return rate;\r\n    }\r\n\r\n    // 0. 计算需要多少amount\r\n    // 1. transfer token from msg.sender to router\r\n    // 2. mint ctoken\r\n    // 3. transfer ctoken to pair\r\n    // amt 是 Ctoken 流动性需要的 amount\r\n    function _mintTransferCToken(address token, address ctoken, address pair, uint amt) private {\r\n        // uint er = _cTokenExchangeRate(ctoken);\r\n        // uint amt = camt * er / 10**18;\r\n\r\n        TransferHelper.safeTransferFrom(token, msg.sender, address(this), amt);\r\n        uint b0 = ICToken(ctoken).balanceOf(address(this));\r\n        // mint 之前需要 approve\r\n        ICToken(token).approve(address(ctoken), amt);\r\n        uint ret = ICToken(ctoken).mint(amt);\r\n        ICToken(ctoken).approve(address(ctoken), 0);\r\n        require(ret == 0, \"mint failed\");\r\n        uint b1 = ICToken(ctoken).balanceOf(address(this));\r\n        uint mintCAmt = b1 - b0;\r\n\r\n        // console.log(\"_mintTransferCToken:\", amt, mintCAmt);\r\n\r\n        TransferHelper.safeTransferFrom(ctoken, address(this), pair, mintCAmt);\r\n    }\r\n\r\n    function _mintTransferEth(address pair, uint amt) private {\r\n        uint b0 = ICToken(cWHT).balanceOf(address(this));\r\n        // todo\r\n        ILHT(cWHT).mint.value(amt)();\r\n        // require(ret == 0, \"mint failed\");\r\n        uint b1 = ICToken(cWHT).balanceOf(address(this));\r\n        uint mintCAmt = b1 - b0;\r\n        TransferHelper.safeTransferFrom(cWHT, address(this), pair, mintCAmt);\r\n    }\r\n\r\n\r\n    function _amount2CAmount(uint amt, uint rate) private pure returns (uint) {\r\n        return amt.mul(10**18).div(rate);\r\n    }\r\n\r\n    function _camount2Amount(uint camt, uint rate) private pure returns (uint) {\r\n        return camt.mul(rate).div(10**18);\r\n    }\r\n\r\n    // tokenA tokenB 都是 token\r\n    // 6/23 如果 ctoken 不存在, 需要创建 ctoken\r\n    function addLiquidityUnderlying(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\r\n        LiquidityLocalVars memory vars;\r\n\r\n        vars.ctokenA = _getOrCreateCtoken(tokenA);\r\n        vars.ctokenB = _getOrCreateCtoken(tokenB);\r\n        vars.rateA = _cTokenExchangeRate(vars.ctokenA);\r\n        vars.rateB = _cTokenExchangeRate(vars.ctokenB);\r\n        vars.camountDesiredA = _amount2CAmount(amountADesired, vars.rateA);\r\n        vars.camountDesiredB = _amount2CAmount(amountBDesired, vars.rateB);\r\n        vars.camountMinA = _amount2CAmount(amountAMin, vars.rateA);\r\n        vars.camountMinB = _amount2CAmount(amountBMin, vars.rateB);\r\n\r\n        (vars.camountA, vars.camountB) = _addLiquidity(vars.ctokenA,\r\n                vars.ctokenB,\r\n                vars.camountDesiredA,\r\n                vars.camountDesiredB,\r\n                vars.camountMinA,\r\n                vars.camountMinB);\r\n        address pair = pairFor(tokenA, tokenB);\r\n        // mint token 得到 ctoken\r\n        amountA = _camount2Amount(vars.camountA, vars.rateA);\r\n        amountB = _camount2Amount(vars.camountB, vars.rateB);\r\n        // console.log(\"amountA: %d amountB: %d\", amountA, amountB);\r\n        _mintTransferCToken(tokenA, vars.ctokenA, pair, amountA);\r\n        _mintTransferCToken(tokenB, vars.ctokenB, pair, amountB);\r\n        // TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\r\n        // TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\r\n        // _safeTransferCtoken(tokenA, msg.sender, pair, amountA);\r\n        // _safeTransferCtoken(tokenB, msg.sender, pair, amountB);\r\n        // console.log('addLiquidityUnderlying: pair=%s', pair);\r\n        liquidity = IDeBankPair(pair).mint(to);\r\n    }\r\n\r\n    // token 是 token 而不是 ctoken\r\n    // 这个函数应该不能直接被调用了, 如果是 ctoken, 直接调用上面的函数；如果是 token, 需要调用 todo\r\n    function addLiquidityETHUnderlying(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\r\n        address ctoken = _getOrCreateCtoken(token);\r\n        LiquidityLocalVars memory vars;\r\n        vars.rateA = _cTokenExchangeRate(ctoken);\r\n        vars.rateB = _cTokenExchangeRate(cWHT);\r\n        vars.camountDesiredA = _amount2CAmount(amountTokenDesired, vars.rateA);\r\n        vars.camountDesiredB = _amount2CAmount(msg.value, vars.rateB);\r\n        vars.camountMinA = _amount2CAmount(amountTokenMin, vars.rateA);\r\n        vars.camountMinB = _amount2CAmount(amountETHMin, vars.rateB);\r\n        (uint amountCToken, uint amountCETH) = _addLiquidity(\r\n            ctoken,\r\n            cWHT,\r\n            vars.camountDesiredA,\r\n            vars.camountDesiredB,\r\n            vars.camountMinA,\r\n            vars.camountMinB\r\n        );\r\n        address pair = pairFor(token, WHT);\r\n\r\n        amountToken = _camount2Amount(amountCToken, vars.rateA);\r\n        amountETH = _camount2Amount(amountCETH, vars.rateB);\r\n        _mintTransferCToken(token, ctoken, pair, amountToken);\r\n        // TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\r\n        // _safeTransferCtoken(token, msg.sender, pair, amountToken);\r\n        // IWHT(WHT).deposit.value(amountETH)();\r\n        _mintTransferEth(pair, amountETH);\r\n        // cWHT.value(amountETH).mint();\r\n        // assert(IWHT(WHT).transfer(pair, amountETH));\r\n        liquidity = IDeBankPair(pair).mint(to);\r\n        // refund dust eth, if any\r\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\r\n    }\r\n\r\n    // **** REMOVE LIQUIDITY ****\r\n    // tokenA tokenB 都是 ctoken\r\n    function removeLiquidity(\r\n        address ctokenA,\r\n        address ctokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) public ensure(deadline) returns (uint amountA, uint amountB) {\r\n        address pair = pairFor(ctokenA, ctokenB);\r\n        IDeBankPair(pair).transferFrom(msg.sender, pair, liquidity);\r\n        // console.log(\"transfer Liquidity success\");\r\n        // send liquidity to pair\r\n        (uint amount0, uint amount1) = IDeBankPair(pair).burn(to);\r\n        address tokenA = _getTokenByCtoken(ctokenA);\r\n        address tokenB = _getTokenByCtoken(ctokenB);\r\n        (address token0,) = IDeBankFactory(factory).sortTokens(tokenA, tokenB);\r\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\r\n        require(amountA >= amountAMin, 'RemoveLiquidity: INSUFFICIENT_A_AMOUNT');\r\n        require(amountB >= amountBMin, 'RemoveLiquidity: INSUFFICIENT_B_AMOUNT');\r\n    }\r\n\r\n    // 赎回 ctoken\r\n    function _redeemCToken(address ctoken, address token, uint camt) private returns (uint) {\r\n        uint b0 = IERC20(token).balanceOf(address(this));\r\n        uint err = ICToken(ctoken).redeem(camt);\r\n        require(err == 0, \"redeem failed\");\r\n        uint b1 = IERC20(token).balanceOf(address(this));\r\n        // console.log(b1, b0);\r\n        // require(b1 >= b0, \"redeem failed\");\r\n        return b1.sub(b0);\r\n    }\r\n\r\n    // 赎回 ctoken\r\n    function _redeemCEth(uint camt) private returns (uint) {\r\n        uint b0 = IERC20(WHT).balanceOf(address(this));\r\n        uint err = ICToken(cWHT).redeem(camt);\r\n        require(err == 0, \"redeem failed\");\r\n        uint b1 = IERC20(WHT).balanceOf(address(this));\r\n        return b1.sub(b0);\r\n    }\r\n\r\n    function _redeemCTokenTransfer(address ctoken, address token, address to, uint camt) private returns (uint)  {\r\n        uint amt = _redeemCToken(ctoken, token, camt);\r\n        // console.log(\"redeem amt: %d\", camt, amt);\r\n        if (amt > 0) {\r\n            TransferHelper.safeTransfer(token, to, amt);\r\n        }\r\n        return amt;\r\n    }\r\n\r\n    function _redeemCETHTransfer(address to, uint camt) private returns (uint) {\r\n        uint amt = _redeemCEth(camt);\r\n        if (amt > 0) {\r\n            TransferHelper.safeTransferETH(to, amt);\r\n        }\r\n        return amt;\r\n    }\r\n\r\n    // tokenA tokenB 都是 token amount都是 token 的 amount\r\n    // 从 ctoken redeem token 可能会失败(额度不足), 因此, \r\n    // 在调用之前, 前端必须校验借贷池余额是否足够！！！\r\n    function removeLiquidityUnderlying(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) public ensure(deadline) returns (uint amountA, uint amountB) {\r\n        address pair = pairFor(tokenA, tokenB);\r\n        // 确保只有owner可以移除流动性\r\n        // require(IDeBankPair(pair).ownerAmountOf(to) >= liquidity, \"not owner or not enough\");\r\n\r\n        IDeBankPair(pair).transferFrom(msg.sender, pair, liquidity);\r\n        LiquidityLocalVars memory vars;\r\n        {\r\n            vars.tokenA = tokenA;\r\n            vars.tokenB = tokenB;\r\n            //  先把 ctoken 发送给 router\r\n            (uint camount0, uint camount1) = IDeBankPair(pair).burn(address(this));\r\n            (address token0,) = IDeBankFactory(factory).sortTokens(vars.tokenA, vars.tokenB);\r\n            (vars.camountA, vars.camountB) = tokenA == token0 ? (camount0, camount1) : (camount1, camount0);\r\n        }\r\n        // console.log(\"camountA: %d camountB: %d\", vars.camountA, vars.camountB);\r\n        amountA = _redeemCTokenTransfer(_getCtoken(tokenA), tokenA, to, vars.camountA);\r\n        amountB = _redeemCTokenTransfer(_getCtoken(tokenB), tokenB, to, vars.camountB);\r\n\r\n        // console.log(\"amountA: %d amountB: %d\", amountA, amountB);\r\n        // TransferHelper.safeTransfer(tokenA, to, amountA);\r\n        // TransferHelper.safeTransfer(tokenB, to, amountB);\r\n        // address ctokenB = _getCtoken(tokenB);\r\n        // ICToken(ctokenA).redeem(camountA);\r\n        // ICToken(ctokenB).redeem(camountB);\r\n\r\n        require(amountA >= amountAMin, 'RemoveLiquidityUnderlying: INSUFFICIENT_A_AMOUNT');\r\n        require(amountB >= amountBMin, 'RemoveLiquidityUnderlying: INSUFFICIENT_B_AMOUNT');\r\n    }\r\n\r\n    // 在调用之前, 前端必须校验借贷池余额是否足够！！！\r\n    function removeLiquidityETHUnderlying(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) public ensure(deadline) returns (uint amountToken, uint amountETH) {\r\n        LiquidityLocalVars memory vars;\r\n        vars.ctokenA = _getCtoken(token);\r\n        vars.rateA = _cTokenExchangeRate(vars.ctokenA);\r\n        vars.rateEth = _cTokenExchangeRate(cWHT);\r\n        uint camountTokenMin = _amount2CAmount(amountTokenMin, vars.rateA);\r\n        uint camountETHMin = _amount2CAmount(amountETHMin, vars.rateEth);\r\n        uint amountCToken;\r\n        uint amountCETH;\r\n        \r\n        (amountCToken, amountCETH) = removeLiquidity(\r\n            vars.ctokenA,\r\n            cWHT,\r\n            liquidity,\r\n            camountTokenMin,\r\n            camountETHMin,\r\n            address(this),\r\n            deadline\r\n        );\r\n        \r\n        amountToken = _redeemCTokenTransfer(vars.ctokenA, token, to, amountCToken);\r\n        // TransferHelper.safeTransfer(token, to, amountToken);\r\n        // IWHT(WHT).withdraw(amountETH);\r\n        amountETH = _redeemCETHTransfer(to, amountCETH);\r\n        // to.transfer(amountETH);\r\n        // TransferHelper.safeTransferETH(to, amountETH);\r\n    }\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB) {\r\n        address pair = pairFor(tokenA, tokenB);\r\n        uint value = approveMax ? uint(- 1) : liquidity;\r\n        IDeBankPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\r\n    }\r\n\r\n    function removeLiquidityETHUnderlyingWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH) {\r\n        address pair = pairFor(token, WHT);\r\n        uint value = approveMax ? uint(- 1) : liquidity;\r\n        IDeBankPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n        (amountToken, amountETH) = removeLiquidityETHUnderlying(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\r\n    }\r\n\r\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\r\n    // function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n    //     address token,\r\n    //     uint liquidity,\r\n    //     uint amountTokenMin,\r\n    //     uint amountETHMin,\r\n    //     address to,\r\n    //     uint deadline\r\n    // ) public ensure(deadline) returns (uint amountETH) {\r\n    //     (, amountETH) = removeLiquidity(\r\n    //         token,\r\n    //         WHT,\r\n    //         liquidity,\r\n    //         amountTokenMin,\r\n    //         amountETHMin,\r\n    //         address(this),\r\n    //         deadline\r\n    //     );\r\n    //     TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\r\n    //     IWHT(WHT).withdraw(amountETH);\r\n    //     TransferHelper.safeTransferETH(to, amountETH);\r\n    // }\r\n\r\n    // function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n    //     address token,\r\n    //     uint liquidity,\r\n    //     uint amountTokenMin,\r\n    //     uint amountETHMin,\r\n    //     address to,\r\n    //     uint deadline,\r\n    //     bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    // ) external returns (uint amountETH) {\r\n    //     address pair = pairFor(token, WHT);\r\n    //     uint value = approveMax ? uint(- 1) : liquidity;\r\n    //     IDeBankPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n    //     amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\r\n    //         token, liquidity, amountTokenMin, amountETHMin, to, deadline\r\n    //     );\r\n    // }\r\n\r\n    // 兑换手续费, 不收手续费\r\n    function _swapFee(address pair, uint feeIn, address feeTo) internal returns (uint feeOut) {\r\n        (uint reserve0, uint reserve1, ) = IDeBankPair(pair).getReserves();\r\n        feeOut = feeIn.mul(reserve1).div(reserve0.add(feeIn));\r\n        IDeBankPair(pair).swapNoFee(0, feeOut, feeTo, feeOut);\r\n    }\r\n\r\n    // 将收到的手续费 token 转换为 anchorToken\r\n    // input 为 token\r\n    // swap后得到的是 canchorToken, cUSDT\r\n    function _swapToCAnchorToken(address input, address pair, address anchorToken) internal returns (uint fee) {\r\n        address feeTo = IDeBankFactory(factory).feeTo();\r\n        require(feeTo != address(0), \"feeTo is zero\");\r\n\r\n        uint amountIn = IERC20(_getCtoken(input)).balanceOf(pair);    // 输入转入\r\n        uint feeIn = IDeBankPair(pair).getFee(amountIn);\r\n        // console.log(\"amountIn: %d  feeIn: %d\", amountIn, feeIn);\r\n\r\n        if (input == anchorToken) {\r\n            // 直接收\r\n            fee = feeIn;\r\n            // feeTotal = feeTotal.add(feeIn);\r\n        } else {\r\n            // 兑换成 anchorToken\r\n            // uint fee = _swapToCAnchorToken(input, amountIn);\r\n            for (uint i; i < quoteTokens.length; i ++) {\r\n                address token = quoteTokens[i];\r\n                address tPair = IDeBankFactory(factory).getPair(input, token);\r\n\r\n                // console.log(\"_swapToCAnchorToken: input=%s token=%s pair=%s\", input, token, tPair);\r\n                if (tPair != address(0)) {\r\n                    if (token == anchorToken) {\r\n                        // 兑换成功\r\n                        IERC20(tPair).transfer(tPair, feeIn);\r\n                        fee = _swapFee(tPair, feeIn, feeTo);\r\n                    } else {\r\n                        // 需要两步兑换\r\n                        // 第一步, 兑换为中间币种 例如ht husd btc\r\n                        address pair2 = IDeBankFactory(factory).getPair(token, anchorToken);\r\n                        require(pair2 != address(0), \"quote coin has no pair to anchorToken\");\r\n                        IERC20(tPair).transfer(tPair, feeIn);\r\n                        uint fee1 = _swapFee(tPair, feeIn, pair2);\r\n                        // 第二步\r\n                        fee = _swapFee(pair2, fee1, feeTo);\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // console.log(\"_swapToCAnchorToken: input: %s  fee: %d  \", input, fee);\r\n        // IERC20(anchorToken).transfer(feeTo, fee);\r\n        return fee;\r\n    }\r\n\r\n    function _updatePairFee(uint fee) private {\r\n        // 更新所有交易对的手续费\r\n        if (currentBlock == block.number) {\r\n            allPairFee += fee;\r\n        } else {\r\n            //\r\n            allPairFeeLastBlock = allPairFee;\r\n            allPairFee = fee;\r\n            currentBlock = block.number;\r\n        }\r\n    }\r\n\r\n    // **** SWAP ****\r\n    // amounts 为 ctoken 的 amount\r\n    // path 中的 token 均为 token, 调用前请转换！！！\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal {\r\n        // uint feeTotal;  // by anchorToken\r\n        address anchorToken = IDeBankFactory(factory).anchorToken();\r\n        // address[] memory path = _cpath2path(cpath);\r\n\r\n        // console.log(\"_swap ....\");\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = IDeBankFactory(factory).sortTokens(input, output);\r\n            address pair = IDeBankFactory(factory).getPair(path[i], path[i + 1]);\r\n            // address feeTo = IDeBankFactory(factory).feeTo();\r\n            // uint feeRate = IDeBankPair(pair).feeRate();\r\n            uint amountOut = amounts[i + 1];\r\n            // uint amountIn = IERC20(pair).balanceOf(pair);    // 输入转入\r\n            // uint feeIn = IDeBankPair(pair).getFee(amountIn);\r\n\r\n            // feeTotal = feeTotal.add();\r\n            // if (feeTotal > 0) {\r\n            //     // 分配LP手续费奖励\r\n            // }\r\n\r\n            if (swapMining != address(0)) {\r\n                // 交易挖矿\r\n                ISwapMining(swapMining).swap(msg.sender, input, output, amountOut);\r\n            }\r\n            \r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\r\n            address to = i < path.length - 2 ? pairFor(output, path[i + 2]) : _to;\r\n            if (feeAlloc == 1) {\r\n                // 收手续费, 并将手续费兑换为 canchorToken(cUSDT)\r\n                uint fee = _swapToCAnchorToken(input, pair, anchorToken);\r\n                if (fee > 0) {\r\n                    _updatePairFee(fee);\r\n                }\r\n\r\n                IDeBankPair(pairFor(input, output)).swapNoFee(\r\n                    amount0Out, amount1Out, to, fee\r\n                );\r\n            } else {\r\n                IDeBankPair(pairFor(input, output)).swap(\r\n                    amount0Out, amount1Out, to, new bytes(0)\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    function _path2cpath(address[] memory path) private view returns (address[] memory) {\r\n        address[] memory cpath = new address[](path.length);\r\n        for (uint i = 0; i < path.length; i ++) {\r\n            cpath[i] = _getCtoken(path[i]);\r\n        }\r\n        return cpath;\r\n    }\r\n\r\n    function _cpath2path(address[] memory cpath) private view returns (address[] memory) {\r\n        address[] memory path = new address[](cpath.length);\r\n        for (uint i = 0; i < cpath.length; i ++) {\r\n            path[i] = _getTokenByCtoken(cpath[i]);\r\n        }\r\n        return path;\r\n    }\r\n\r\n    // amount token 均为 ctoken\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata cpath,\r\n        address to,\r\n        uint deadline\r\n    ) external ensure(deadline) returns (uint[] memory amounts) {\r\n        // console.log('swapExactTokensForTokens ....');\r\n        address[] memory path = _cpath2path(cpath);\r\n        amounts = IDeBankFactory(factory).getAmountsOut(amountIn, path, to);\r\n        // console.log(amounts[0], amounts[1]);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        // _safeTransferCtoken(\r\n        //     path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\r\n        // );\r\n        TransferHelper.safeTransferFrom(cpath[0], msg.sender, pairFor(path[0], path[1]), amounts[0]);\r\n        _swap(amounts, path, to);\r\n    }\r\n\r\n    // amount token 均为 ctoken\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata cpath,\r\n        address to,\r\n        uint deadline\r\n    ) external ensure(deadline) returns (uint[] memory amounts) {\r\n        // console.log('swapTokensForExactTokens ....');\r\n        address[] memory path = _cpath2path(cpath);\r\n        amounts = IDeBankFactory(factory).getAmountsIn(amountOut, path, to);\r\n        require(amounts[0] <= amountInMax, 'Router: EXCESSIVE_INPUT_AMOUNT');\r\n        // _safeTransferCtoken(\r\n        //     path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\r\n        // );\r\n        TransferHelper.safeTransferFrom(cpath[0], msg.sender, pairFor(path[0], path[1]), amounts[0]);\r\n        _swap(amounts, path, to);\r\n    }\r\n\r\n\r\n    function _swapExactTokensForTokensUnderlying(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] memory path,\r\n        address to,\r\n        uint deadline,\r\n        bool ethIn,\r\n        bool ethOut\r\n    ) private ensure(deadline) returns (uint[] memory amounts) {\r\n        // console.log('_swapExactTokensForTokensUnderlying ....');\r\n        address[] memory cpath = _path2cpath(path);\r\n        SwapLocalVars memory vars;\r\n        vars.amountIn = amountIn;\r\n        vars.rate0 = _cTokenExchangeRate(cpath[0]);\r\n        vars.rate1 = _cTokenExchangeRate(cpath[0]);\r\n        uint camtIn = _amount2CAmount(amountIn, vars.rate0);\r\n        uint[] memory camounts = IDeBankFactory(factory).getAmountsOut(camtIn, path, to);\r\n        // console.log(camounts[0], camounts[1]);\r\n        vars.amountOut = _camount2Amount(camounts[camounts.length - 1], vars.rate1);\r\n        require(vars.amountOut >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        // _safeTransferCtoken(\r\n        //     path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\r\n        // );\r\n        if (ethIn) {\r\n            _mintTransferEth(pairFor(path[0], path[1]), amountIn);\r\n        } else {\r\n            _mintTransferCToken(path[0], cpath[0], pairFor(path[0], path[1]), vars.amountIn);\r\n        }\r\n\r\n        // TransferHelper.safeTransferFrom(path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]);\r\n        // 先将 ctoken 转给 router\r\n        _swap(camounts, path, address(this));\r\n        uint idx = path.length - 1;\r\n        if (ethOut) {\r\n            _redeemCETHTransfer(to, camounts[idx]);\r\n        } else {\r\n            _redeemCTokenTransfer(cpath[idx], path[idx], to, camounts[idx]);\r\n        }\r\n\r\n        amounts = new uint[](path.length);\r\n        amounts[0] = amountIn;\r\n        amounts[idx] = vars.amountOut;\r\n    }\r\n\r\n    // amount token 均为 token\r\n    // 调用者需要验证借贷池中的 path[path.length-1] 的资金足够！！！\r\n    function swapExactTokensForTokensUnderlying(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external ensure(deadline) returns (uint[] memory amounts) {\r\n        // console.log('swapExactTokensForTokensUnderlying ....');\r\n        amounts = _swapExactTokensForTokensUnderlying(amountIn, amountOutMin, path, to, deadline, false, false);\r\n        // address[] memory cpath = _path2cpath(path);\r\n        // uint rate0 = _cTokenExchangeRate(cpath[0]);\r\n        // uint rate1 = _cTokenExchangeRate(cpath[0]);\r\n        // uint camtIn = _amount2CAmount(amountIn, rate0);\r\n        // uint[] memory camounts = IDeBankFactory(factory).getAmountsOut(camtIn, path);\r\n        // console.log(camounts[0], camounts[1]);\r\n        // uint amountOut = _camount2Amount(camounts[camounts.length - 1], rate1);\r\n        // require(amountOut >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        // // _safeTransferCtoken(\r\n        // //     path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\r\n        // // );\r\n        // _mintTransferCToken(path[0], cpath[0], pairFor(path[0], path[1]), amountIn);\r\n        // // TransferHelper.safeTransferFrom(path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]);\r\n        // _swap(camounts, path, to);\r\n        // uint idx = path.length - 1;\r\n        // _redeemCTokenTransfer(cpath[idx], path[idx], to, camounts[idx]);\r\n\r\n        // amounts = new uint[](path.length);\r\n        // amounts[0] = amountIn;\r\n        // amounts[idx] = amountOut;\r\n    }\r\n\r\n    struct SwapLocalVars {\r\n        uint rate0;\r\n        uint rate1;\r\n        uint amountIn;\r\n        uint amountOut;\r\n    }\r\n\r\n    function _swapTokensForExactTokensUnderlying(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] memory path,\r\n        address to,\r\n        uint deadline,\r\n        bool ethIn,\r\n        bool ethOut\r\n    ) private ensure(deadline) returns (uint[] memory amounts) {\r\n        // console.log('_swapTokensForExactTokensUnderlying ....');\r\n        address[] memory cpath = _path2cpath(path);\r\n        SwapLocalVars memory vars;\r\n\r\n        vars.rate0 = _cTokenExchangeRate(cpath[0]);\r\n        vars.rate1 = _cTokenExchangeRate(cpath[path.length-1]);\r\n        uint camtOut = _amount2CAmount(amountOut, vars.rate1);\r\n        uint[] memory camounts = IDeBankFactory(factory).getAmountsIn(camtOut, path, to);\r\n        // console.log(\"camounts:\", camounts[0], camounts[1], camtOut);\r\n        \r\n        vars.amountIn = _camount2Amount(camounts[0], vars.rate0);\r\n        // 上一步中舍去的 1\r\n        vars.amountIn = vars.amountIn.add(1);\r\n        // console.log(\"amountIn:\", vars.amountIn);\r\n        require(vars.amountIn <= amountInMax, 'Router: EXCESSIVE_INPUT_AMOUNT');\r\n        // _safeTransferCtoken(\r\n        //     path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\r\n        // );\r\n        if (ethIn) {\r\n            _mintTransferEth(pairFor(path[0], path[1]), vars.amountIn);\r\n        } else {\r\n            _mintTransferCToken(path[0], cpath[0], pairFor(path[0], path[1]), vars.amountIn);\r\n        }\r\n        // TransferHelper.safeTransferFrom(path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]);\r\n        // 先转给 router, 再由 router redeem 后, 转给 to\r\n        _swap(camounts, path, address(this));\r\n        uint idx = path.length - 1;\r\n        if (ethOut) {\r\n            _redeemCETHTransfer(to, camounts[idx]);\r\n        } else {\r\n            _redeemCTokenTransfer(cpath[idx], path[idx], to, camounts[idx]);\r\n        }\r\n\r\n        amounts = new uint[](path.length);\r\n        amounts[0] = vars.amountIn;\r\n        amounts[idx] = amountOut;\r\n    }\r\n\r\n    // amount token 均为 ctoken\r\n    function swapTokensForExactTokensUnderlying(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external ensure(deadline) returns (uint[] memory amounts) {\r\n        // console.log('swapTokensForExactTokensUnderlying ....');\r\n        amounts = _swapTokensForExactTokensUnderlying(amountOut, amountInMax, path, to, deadline, false, false);\r\n        // address[] memory cpath = _path2cpath(path);\r\n        // uint rate0 = _cTokenExchangeRate(cpath[0]);\r\n        // uint rate1 = _cTokenExchangeRate(cpath[0]);\r\n        // uint camtOut = _amount2CAmount(amountOut, rate1);\r\n        // uint[] memory camounts = IDeBankFactory(factory).getAmountsIn(camtOut, path);\r\n        \r\n        // uint amountIn = _camount2Amount(camounts[0], rate0);\r\n        // require(amountIn <= amountInMax, 'Router: EXCESSIVE_INPUT_AMOUNT');\r\n        // // _safeTransferCtoken(\r\n        // //     path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\r\n        // // );\r\n        // _mintTransferCToken(path[0], cpath[0], pairFor(path[0], path[1]), amountIn);\r\n        // // TransferHelper.safeTransferFrom(path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]);\r\n        // _swap(camounts, path, to);\r\n        // uint idx = path.length - 1;\r\n        // _redeemCTokenTransfer(cpath[idx], path[idx], to, camounts[idx]);\r\n\r\n        // amounts = new uint[](path.length);\r\n        // amounts[0] = amountIn;\r\n        // amounts[idx] = amountOut;\r\n    }\r\n\r\n    function swapExactETHForTokensUnderlying(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        // console.log('swapExactETHForTokensUnderlying ....');\r\n        require(path[0] == WHT, 'Router: INVALID_PATH');\r\n        amounts = _swapExactTokensForTokensUnderlying(msg.value, amountOutMin, path, to, deadline, true, false);\r\n        // amounts = IDeBankFactory(factory).getAmountsOut(msg.value, path);\r\n        // require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        // IWHT(WHT).deposit.value(amounts[0])();\r\n        // assert(IWHT(WHT).transfer(pairFor(path[0], path[1]), amounts[0]));\r\n        // _swap(amounts, path, to);\r\n    }\r\n\r\n    function swapTokensForExactETHUnderlying(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        // console.log('swapTokensForExactETH ....');\r\n        require(path[path.length - 1] == WHT, 'Router: INVALID_PATH');\r\n        amounts = _swapTokensForExactTokensUnderlying(amountOut, amountInMax, path, to, deadline, false, true);\r\n        // amounts = IDeBankFactory(factory).getAmountsIn(amountOut, path);\r\n        // require(amounts[0] <= amountInMax, 'Router: EXCESSIVE_INPUT_AMOUNT');\r\n        // _safeTransferCtoken(\r\n        //     path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\r\n        // );\r\n        // _swap(amounts, path, address(this));\r\n        // IWHT(WHT).withdraw(amounts[amounts.length - 1]);\r\n        // TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n\r\n    function swapExactTokensForETHUnderlying(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        // console.log('swapExactTokensForETHUnderlying ....');\r\n        require(path[path.length - 1] == WHT, 'Router: INVALID_PATH');\r\n        amounts = _swapExactTokensForTokensUnderlying(amountIn, amountOutMin, path, to, deadline, false, true);\r\n        // amounts = IDeBankFactory(factory).getAmountsOut(amountIn, path);\r\n        // require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        // _safeTransferCtoken(\r\n        //     path[0], msg.sender, pairFor(path[0], path[1]), amounts[0]\r\n        // );\r\n        // _swap(amounts, path, address(this));\r\n        // IWHT(WHT).withdraw(amounts[amounts.length - 1]);\r\n        // TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n\r\n    function swapETHForExactTokensUnderlying(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        // console.log('swapETHForExactTokensUnderlying ....');\r\n        require(path[0] == WHT, 'Router: INVALID_PATH');\r\n        amounts = _swapTokensForExactTokensUnderlying(amountOut, msg.value, path, to, deadline, true, false);\r\n        // amounts = IDeBankFactory(factory).getAmountsIn(amountOut, path);\r\n        // require(amounts[0] <= msg.value, 'Router: EXCESSIVE_INPUT_AMOUNT');\r\n        // IWHT(WHT).deposit{value : amounts[0]}();\r\n        // assert(IWHT(WHT).transfer(pairFor(path[0], path[1]), amounts[0]));\r\n        // _swap(amounts, path, to);\r\n        // // refund dust eth, if any\r\n        // if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\r\n    }\r\n\r\n    function adminTransfer(address token, address to, uint amt) external onlyOwner {\r\n        if (token == address(0)) {\r\n          TransferHelper.safeTransferETH(to, amt);\r\n        } else {\r\n          TransferHelper.safeTransferFrom(token, address(this), to, amt);\r\n        }\r\n    }\r\n    // **** SWAP (supporting fee-on-transfer tokens) ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    // function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal {\r\n    //     for (uint i; i < path.length - 1; i++) {\r\n    //         (address input, address output) = (path[i], path[i + 1]);\r\n    //         (address token0,) = IDeBankFactory(factory).sortTokens(input, output);\r\n    //         IDeBankPair pair = IDeBankPair(pairFor(input, output));\r\n    //         uint amountInput;\r\n    //         uint amountOutput;\r\n    //         {// scope to avoid stack too deep errors\r\n    //             (uint reserve0, uint reserve1,) = pair.getReserves();\r\n    //             (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    //             amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\r\n    //             amountOutput = IDeBankFactory(factory).getAmountOut(amountInput, reserveInput, reserveOutput);\r\n    //         }\r\n    //         if (swapMining != address(0)) {\r\n    //             ISwapMining(swapMining).swap(msg.sender, input, output, amountOutput);\r\n    //         }\r\n    //         (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\r\n    //         address to = i < path.length - 2 ? pairFor(output, path[i + 2]) : _to;\r\n    //         pair.swap(amount0Out, amount1Out, to, new bytes(0));\r\n    //     }\r\n    // }\r\n\r\n    // function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n    //     uint amountIn,\r\n    //     uint amountOutMin,\r\n    //     address[] calldata path,\r\n    //     address to,\r\n    //     uint deadline\r\n    // ) external ensure(deadline) {\r\n    //     TransferHelper.safeTransferFrom(\r\n    //         path[0], msg.sender, pairFor(path[0], path[1]), amountIn\r\n    //     );\r\n    //     uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\r\n    //     _swapSupportingFeeOnTransferTokens(path, to);\r\n    //     require(\r\n    //         IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\r\n    //         'Router: INSUFFICIENT_OUTPUT_AMOUNT'\r\n    //     );\r\n    // }\r\n\r\n    // function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n    //     uint amountOutMin,\r\n    //     address[] calldata path,\r\n    //     address to,\r\n    //     uint deadline\r\n    // )\r\n    // external\r\n    // payable\r\n    // ensure(deadline)\r\n    // {\r\n    //     require(path[0] == WHT, 'Router: INVALID_PATH');\r\n    //     uint amountIn = msg.value;\r\n    //     IWHT(WHT).deposit.value(amountIn)();\r\n    //     assert(IWHT(WHT).transfer(pairFor(path[0], path[1]), amountIn));\r\n    //     uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\r\n    //     _swapSupportingFeeOnTransferTokens(path, to);\r\n    //     require(\r\n    //         IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\r\n    //         'Router: INSUFFICIENT_OUTPUT_AMOUNT'\r\n    //     );\r\n    // }\r\n\r\n    // function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n    //     uint amountIn,\r\n    //     uint amountOutMin,\r\n    //     address[] calldata path,\r\n    //     address to,\r\n    //     uint deadline\r\n    // )\r\n    // external\r\n    // ensure(deadline)\r\n    // {\r\n    //     require(path[path.length - 1] == WHT, 'Router: INVALID_PATH');\r\n    //     TransferHelper.safeTransferFrom(\r\n    //         path[0], msg.sender, pairFor(path[0], path[1]), amountIn\r\n    //     );\r\n    //     _swapSupportingFeeOnTransferTokens(path, address(this));\r\n    //     uint amountOut = IERC20(WHT).balanceOf(address(this));\r\n    //     require(amountOut >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n    //     IWHT(WHT).withdraw(amountOut);\r\n    //     TransferHelper.safeTransferETH(to, amountOut);\r\n    // }\r\n\r\n    // **** LIBRARY FUNCTIONS ****\r\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) public view returns (uint256 amountB) {\r\n        return IDeBankFactory(factory).quote(amountA, reserveA, reserveB);\r\n    }\r\n\r\n    // function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) public view returns (uint256 amountOut){\r\n    //     return IDeBankFactory(factory).getAmountOut(amountIn, reserveIn, reserveOut);\r\n    // }\r\n\r\n    // function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) public view returns (uint256 amountIn){\r\n    //     return IDeBankFactory(factory).getAmountIn(amountOut, reserveIn, reserveOut);\r\n    // }\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] memory path, address to) public view returns (uint256[] memory amounts){\r\n        return IDeBankFactory(factory).getAmountsOut(amountIn, path, to);\r\n    }\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] memory path, address to) public view returns (uint256[] memory amounts){\r\n        return IDeBankFactory(factory).getAmountsIn(amountOut, path, to);\r\n    }\r\n\r\n}\r\n\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success,) = to.call.value(value)(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n"
    },
    "contracts/swap/interface/IWHT.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity ^0.5.16;\r\n\r\ninterface IWHT {\r\n    function deposit() external payable;\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function withdraw(uint) external;\r\n}"
    },
    "contracts/swap/interface/ICToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\ninterface ICToken {\r\n\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n\r\n    function transfer(address dst, uint amount) external returns (bool);\r\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function balanceOfUnderlying(address owner) external returns (uint);\r\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\r\n    function borrowRatePerBlock() external view returns (uint);\r\n    function supplyRatePerBlock() external view returns (uint);\r\n    function totalBorrowsCurrent() external returns (uint);\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function borrowBalanceStored(address account) external view returns (uint);\r\n    function exchangeRateCurrent() external returns (uint);\r\n    function exchangeRateStored() external view returns (uint);\r\n    function getCash() external view returns (uint);\r\n    function accrueInterest() external returns (uint);\r\n    function accrualBlockNumber() external view returns (uint);\r\n    // function getCash() virtual external view returns (uint);\r\n    // function accrueInterest() virtual public returns (uint);\r\n    // function seize(address liquidator, address borrower, uint seizeTokens) virtual external returns (uint);\r\n\r\n}\r\n"
    },
    "contracts/swap/heco/Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity ^0.5.16;\r\n\r\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\r\n\r\nimport \"../library/SafeMath.sol\";\r\nimport \"../interface/IERC20.sol\";\r\nimport \"../interface/IDeBankFactory.sol\";\r\nimport \"../interface/IDeBankPair.sol\";\r\nimport \"../interface/IDeBankRouter.sol\";\r\n\r\nimport \"../interface/LErc20DelegatorInterface.sol\";\r\nimport \"../interface/ICToken.sol\";\r\n\r\nimport \"./Pair.sol\";\r\n\r\n// import \"hardhat/console.sol\";\r\n\r\ncontract DeBankFactory is IDeBankFactory, Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint;\r\n    address public feeTo;       \r\n    // address public feeToSetter;\r\n    uint256 public lpFeeRate = 0;    // 分配给LP的比例: 0: 0; n: (n/(n+1))\r\n    // address public anchorUnderlying;\r\n    address public anchorToken;           // 手续费锚定币种\r\n    address public router;                // 在 pair 中使用\r\n    bytes32 public initCodeHash;\r\n\r\n    // lend controller address. should be unitroller address, which is proxy of comptroller\r\n    // LErc20DelegatorInterface public lErc20DelegatorFactory;\r\n    // address public owner;\r\n\r\n    // 由于0值与不存在无法区分，因此，设置的时候都在原值的基础上+1\r\n    mapping(address => uint) public feeRateOf; // 用于设定特定用户的费率\r\n    mapping(address => mapping(address => address)) public getPair;\r\n    address[] public allPairs;\r\n\r\n    // event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    // 创建时需要设置 LERC20 factory 地址 --- 改在router中设置, factory 创建 pair 时需要提供 两个token地址 两个ctoken地址\r\n    // constructor(address _ctokenFacotry, address _anchorToken) public {\r\n    constructor(address _anchorToken) public {\r\n        // owner = msg.sender;\r\n        // feeToSetter = _feeToSetter;\r\n        // lErc20DelegatorFactory = LErc20DelegatorInterface(_ctokenFacotry);\r\n        initCodeHash = keccak256(abi.encodePacked(type(DeBankPair).creationCode));\r\n\r\n        // anchorUnderlying = _anchorToken;\r\n        anchorToken = _anchorToken; // lErc20DelegatorFactory.getCTokenAddressPure(_anchorToken);\r\n        require(anchorToken != address(0), \"cToken of anchorToken is 0\");\r\n    }\r\n\r\n    function allPairsLength() external view returns (uint) {\r\n        return allPairs.length;\r\n    }\r\n\r\n    // function setAnchorToken(address _anchorToken) external {\r\n    //     require(msg.sender == owner, \"No auth\");\r\n    //     anchorUnderlying = _anchorToken;\r\n    //     anchorToken = _anchorToken; // lErc20DelegatorFactory.getCTokenAddressPure(_anchorToken);\r\n    //     require(anchorToken != address(0), \"cToken of anchorToken is 0\");\r\n    // }\r\n\r\n    // 创建交易对\r\n    // tokenA tokenB 都不能是 cToken\r\n    function createPair(address tokenA, address tokenB, address ctoken0, address ctoken1) external returns (address pair) {\r\n        require(tokenA != tokenB, 'SwapFactory: IDENTICAL_ADDRESSES');\r\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'SwapFactory: ZERO_ADDRESS');\r\n        require(getPair[token0][token1] == address(0), 'SwapFactory: PAIR_EXISTS');\r\n        \r\n        // guotie\r\n        // token0 token1 不能是 cToken\r\n        // (address ctoken0, address ctoken1) = _checkOrCreateCToken(token0, token1);\r\n\r\n        // single check is sufficient\r\n        bytes memory bytecode = type(DeBankPair).creationCode;\r\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\r\n        assembly {\r\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n        }\r\n        IDeBankPair(pair).initialize(token0, token1, ctoken0, ctoken1);\r\n\r\n        // guotie\r\n        // set compound ctoken address\r\n        // IDeBankPair(pair).initializeCTokenAddress(ctoken0, ctoken1);\r\n\r\n        getPair[token0][token1] = pair;\r\n        getPair[token1][token0] = pair;\r\n        getPair[ctoken0][ctoken1] = pair;\r\n        getPair[ctoken1][ctoken0] = pair;\r\n        // populate mapping in the reverse direction\r\n        allPairs.push(pair);\r\n        emit PairCreated(token0, token1, pair, allPairs.length);\r\n    }\r\n\r\n    function setFeeTo(address _feeTo) external onlyOwner {\r\n        // require(msg.sender == feeToSetter, 'SwapFactory: FORBIDDEN');\r\n        feeTo = _feeTo;\r\n    }\r\n\r\n    // function setFeeToSetter(address _feeToSetter) external onlyOwner {\r\n    //     // require(msg.sender == feeToSetter, 'SwapFactory: FORBIDDEN');\r\n    //     require(_feeToSetter != address(0), \"DeBankSwapFactory: FeeToSetter is zero address\");\r\n    //     feeToSetter = _feeToSetter;\r\n    // }\r\n\r\n    // 设置用户费率 所有交易对生效\r\n    // 获取时，真实的费率-1\r\n    function setUserFeeRate(address user, uint feeRate) external onlyOwner {\r\n        // require(msg.sender == feeToSetter, 'SwapFactory: FORBIDDEN');\r\n        feeRateOf[user] = feeRate + 1;\r\n    }\r\n\r\n    function setFeeToRate(uint256 _rate) external onlyOwner {\r\n        // require(msg.sender == feeToSetter, 'SwapFactory: FORBIDDEN');\r\n        require(_rate > 0, \"DeBankSwapFactory: FEE_TO_RATE_OVERFLOW\");\r\n        lpFeeRate = _rate.sub(1);\r\n    }\r\n    \r\n    function setPairFeeRate(address pair, uint feeRate) external onlyOwner {\r\n        // require(msg.sender == feeToSetter, 'SwapFactory: FORBIDDEN');\r\n        // 最高手续费不得高于2%\r\n        require(feeRate <= 200, \"SwapFactory: feeRate too high\");\r\n        IDeBankPair(pair).updateFeeRate(feeRate);\r\n    }\r\n\r\n    function setRouter(address _router) external onlyOwner {\r\n        // require(msg.sender == owner, \"SwapFactory: FORBIDDEN\");\r\n        router = _router;\r\n    }\r\n    \r\n    function setAnchorToken(address _token) external onlyOwner {\r\n        anchorToken = _token;\r\n    }\r\n\r\n    // // 原来的owner设置新的owner\r\n    // function changeOwner(address _owner) external {\r\n    //     // require(msg.sender == owner, \"SwapFactory: FORBIDDEN\");\r\n    //     owner = _owner;\r\n    // }\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(address tokenA, address tokenB) public pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'SwapFactory: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'SwapFactory: ZERO_ADDRESS');\r\n    }\r\n\r\n    // guotie\r\n    // 检查 token 不是 cToken\r\n    // function _checkTokenIsNotCToken(address token0, address token1) private view returns (uint) {\r\n    //     address ctoken0 = lErc20DelegatorFactory.getCTokenAddressPure(token0);\r\n    //     if (ctoken0 == address(0)) {\r\n    //         return 1;\r\n    //     }\r\n\r\n    //     address ctoken1 = lErc20DelegatorFactory.getCTokenAddressPure(token1);\r\n    //     if (ctoken1 == address(0)) {\r\n    //         return 2;\r\n    //     }\r\n\r\n    //     if(ctoken0 == ctoken1) {\r\n    //         return 3;\r\n    //     }\r\n    //     return 0;\r\n    // }\r\n\r\n    // function _checkOrCreateCToken(address token0, address token1) private returns (address ctoken0, address ctoken1) {\r\n    //     ctoken0 = lErc20DelegatorFactory.getCTokenAddress(token0);\r\n    //     require(ctoken0 != address(0), 'SwapFactory: cToken is 0');\r\n    //     ctoken1 = lErc20DelegatorFactory.getCTokenAddress(token1);\r\n    //     require(ctoken1 != address(0), 'SwapFactory: cToken is 0');\r\n\r\n    //     require(ctoken0 != ctoken1, 'SwapFactory: Dup cToken');\r\n    // }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(address tokenA, address tokenB) public view returns (address pair) {\r\n        pair = getPair[tokenA][tokenB];\r\n        // // guotie 这里不关心顺序\r\n        // uint err = _checkTokenIsNotCToken(tokenA, tokenB);\r\n        // require(err == 0, \"check token failed\");\r\n\r\n        // (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        // pair = address(uint(keccak256(abi.encodePacked(\r\n        //         hex'ff',\r\n        //         address(this),\r\n        //         keccak256(abi.encodePacked(token0, token1)),\r\n        //         initCodeHash\r\n        //     ))));\r\n    }\r\n\r\n    // token 都是 token 而非 ctoken !!!\r\n    // fetches and sorts the reserves for a pair\r\n    function getReserves(address tokenA, address tokenB) public view returns (uint reserveA, uint reserveB) {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        (uint reserve0, uint reserve1,) = IDeBankPair(pairFor(tokenA, tokenB)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n\r\n    // fetches and sorts the reserves for a pair\r\n\r\n    // token 都是 token 而非 ctoken !!!\r\n    function getReservesFeeRate(address tokenA, address tokenB, address to) public view \r\n            returns (uint reserveA, uint reserveB, uint feeRate, bool outAnchorToken) {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        address pair = pairFor(tokenA, tokenB);\r\n        (uint reserve0, uint reserve1,) = IDeBankPair(pair).getReserves();\r\n        feeRate = feeRateOf[to];\r\n        if (feeRate == 0) {\r\n            feeRate = IDeBankPair(pair).feeRate();\r\n        } else {\r\n            feeRate = feeRate - 1;\r\n        }\r\n\r\n        // 输出货币是否是 锚定货币\r\n\r\n        outAnchorToken = tokenA == token0 ? tokenB == anchorToken : tokenA == anchorToken;\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n        // console.log(\"tokenA: %s tokenB: %s anchorToken: %s\", tokenA, tokenB, anchorToken);\r\n        // console.log(\"reserveA: %d reserveB: %d feeRate: %d\", reserveA, reserveB, feeRate);\r\n    }\r\n\r\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\r\n    function quote(uint amountA, uint reserveA, uint reserveB) public pure returns (uint amountB) {\r\n        require(amountA > 0, 'SwapFactory: INSUFFICIENT_AMOUNT');\r\n        require(reserveA > 0 && reserveB > 0, 'SwapFactory: INSUFFICIENT_LIQUIDITY');\r\n        amountB = amountA.mul(reserveB) / reserveA;\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    // function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) public view returns (uint amountOut) {\r\n    //     require(amountIn > 0, 'SwapFactory: INSUFFICIENT_INPUT_AMOUNT');\r\n    //     require(reserveIn > 0 && reserveOut > 0, 'SwapFactory: INSUFFICIENT_LIQUIDITY');\r\n    //     uint amountInWithFee = amountIn.mul(997);\r\n    //     uint numerator = amountInWithFee.mul(reserveOut);\r\n    //     uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n    //     amountOut = numerator / denominator;\r\n    // }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOutFeeRate(uint amountIn, uint reserveIn, uint reserveOut, uint feeRate) public pure returns (uint amountOut) {\r\n        require(amountIn > 0, 'SwapFactory: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'SwapFactory: INSUFFICIENT_LIQUIDITY');\r\n        uint amountInWithFee = amountIn.mul(10000-feeRate);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(10000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // amountOut 是锚定货币的情况, 需要将 amountIn 的手续费部分转换为锚定货币\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    // x*y = x'*y'\r\n    // a = x' - x  输入\r\n    // b = y - y'\r\n    // xfee = a*0.003\r\n    // 将 xfee 兑换为 yfee: yfee = (xfee*y)/(x+xfee)\r\n    // 兑换后: \r\n    // a' = a - xfee\r\n    // x = x+xfee   y = y-yfee\r\n    // b = a' * y/(x+a') = a'*(y-yfee)/(x+xfee+a')=(a-xfee)*(y-yfee)/(x+xfee+a-xfee)=(a-xfee)*(y-yfee)/(x+a)\r\n    // 最终: b = (a-xfee)*(y-yfee)/(x+a)\r\n    // 对比: b = (a-xfee)*y/(x+a-xfee)\r\n    function getAmountOutFeeRateAnchorToken(uint amountIn, uint reserveIn, uint reserveOut, uint feeRate) public pure returns (uint amountOut) {\r\n        require(amountIn > 0, 'SwapFactory: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'SwapFactory: INSUFFICIENT_LIQUIDITY');\r\n        uint amountInWithFee = amountIn.mul(10000-feeRate);\r\n        uint amountInFee = amountIn.mul(10000) - amountInWithFee;\r\n        // 这部分转换不收手续费\r\n        uint amountOutFee = amountInFee.mul(reserveOut) / reserveIn.mul(10000).add(amountInFee);\r\n\r\n        // amountOutFee 被截断, 可能造成 reserveOut + 1, 因此这里 -1\r\n        reserveOut = reserveOut - amountOutFee - 1;\r\n        reserveIn = reserveIn - amountInFee.div(10000);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.add(amountIn).mul(10000);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    // function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut, address to) public view returns (uint amountIn) {\r\n    //     require(amountOut > 0, 'SwapFactory: INSUFFICIENT_OUTPUT_AMOUNT');\r\n    //     require(reserveIn > 0 && reserveOut > 0, 'SwapFactory: INSUFFICIENT_LIQUIDITY');\r\n    //     uint numerator = reserveIn.mul(amountOut).mul(1000);\r\n    //     uint denominator = reserveOut.sub(amountOut).mul(997);\r\n    //     amountIn = (numerator / denominator).add(1);\r\n    // }\r\n\r\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    // 正常计算逻辑:\r\n    // x*y = x'*y'\r\n    // a = x' - x  输入\r\n    // b = y - y'\r\n    // b = 997*a*y/(997*a+1000*x)\r\n    // a = 1000xb/997(y-b)\r\n    function getAmountInFeeRate(uint amountOut, uint reserveIn, uint reserveOut, uint feeRate) public pure returns (uint amountIn) {\r\n        require(amountOut > 0, 'SwapFactory: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'SwapFactory: INSUFFICIENT_LIQUIDITY');\r\n        uint numerator = reserveIn.mul(amountOut).mul(10000);\r\n        uint denominator = reserveOut.sub(amountOut).mul(10000-feeRate);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    // xfee = 0.003a\r\n    // (x+0.997a)(y-b) = (x+xfee)(y-(fy/(x+f))) = xy\r\n    // function getAmountInFeeRateAnchorToken(uint amountOut, uint reserveIn, uint reserveOut, uint feeRate) public pure override\r\n    //     returns (uint amountIn) {\r\n    //     require(amountOut > 0, 'SwapFactory: INSUFFICIENT_OUTPUT_AMOUNT');\r\n    //     require(reserveIn > 0 && reserveOut > 0, 'SwapFactory: INSUFFICIENT_LIQUIDITY');\r\n    //     uint numerator = reserveIn.mul(amountOut).mul(10000);\r\n    //     uint denominator = reserveOut.sub(amountOut).mul(10000-feeRate);\r\n    //     amountIn = (numerator / denominator).add(1);\r\n    // }\r\n\r\n    // 调用前确保已经是最新的 exchangeRate\r\n    // ctokenAmt = amt / exchangeRate\r\n    // function amountToCTokenAmt(address ctoken, uint amountIn) external view returns (uint cAmountIn) {\r\n    //     uint exchangeRate = ICToken(ctoken).exchangeRateStored();\r\n    //     return amountIn.mul(1e18).div(exchangeRate);\r\n    // }\r\n\r\n    // 调用前确保已经是最新的 exchangeRate\r\n    // ctoken amount 转换为 token amt\r\n    // tokenAmt = ctokenAmt * exchangeRate\r\n    // function ctokenAmtToAmount(address ctoken, uint cAmountOut) external view returns (uint amountOut) {\r\n    //     uint exchangeRate = ICToken(ctoken).exchangeRateStored();\r\n    //     return cAmountOut.mul(exchangeRate).div(1e18);\r\n    // }\r\n\r\n    // path 中的 address 应该都是 token, 因为 sortToken 用的是 token\r\n    // performs chained getAmountOut calculations on any number of pairs\r\n    function getAmountsOut(uint amountIn, address[] memory path, address to) public view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'SwapFactory: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (uint reserveIn, uint reserveOut, uint feeRate, bool outAnchorToken) = getReservesFeeRate(path[i], path[i + 1], to);\r\n            if (outAnchorToken) {\r\n                amounts[i + 1] = getAmountOutFeeRateAnchorToken(amounts[i], reserveIn, reserveOut, feeRate);\r\n            } else {\r\n                amounts[i + 1] = getAmountOutFeeRate(amounts[i], reserveIn, reserveOut, feeRate);\r\n            }\r\n        }\r\n    }\r\n\r\n    // path 中的 address 应该都是 token, 因为 sortToken 用的是 token\r\n    // performs chained getAmountIn calculations on any number of pairs\r\n    function getAmountsIn(uint amountOut, address[] memory path, address to) public view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'SwapFactory: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[amounts.length - 1] = amountOut;\r\n        for (uint i = path.length - 1; i > 0; i--) {\r\n            (uint reserveIn, uint reserveOut, uint feeRate, ) = getReservesFeeRate(path[i - 1], path[i], to);\r\n            amounts[i - 1] = getAmountInFeeRate(amounts[i], reserveIn, reserveOut, feeRate);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n"
    },
    "contracts/swap/heco/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.5.16;\r\n\r\n// import \"./Context.sol\";\r\nimport \"../interface/IERC20.sol\";\r\nimport \"../library/SafeMath.sol\";\r\n\r\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n     * a default value of 18.\r\n     *\r\n     * To select a different value for {decimals}, use {_setupDecimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name_, string memory symbol_) public {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = 18;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets {decimals} to a value other than the default one of 18.\r\n     *\r\n     * WARNING: This function should only be called from the constructor. Most\r\n     * applications that interact with token contracts will not expect\r\n     * {decimals} to ever change, and may work incorrectly if it does.\r\n     */\r\n    function _setupDecimals(uint8 decimals_) internal {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal { }\r\n}\r\n"
    },
    "contracts/swap/heco/MdxTokenHeco.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\n// import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"./ERC20.sol\";\r\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\r\n\r\ncontract DelegateERC20 is ERC20 {\r\n    using SafeMath for uint256;\r\n    // @notice A record of each accounts delegate\r\n    mapping (address => address) internal _delegates;\r\n\r\n    string private _name;\r\n    /// @notice A checkpoint for marking number of votes from a given block\r\n    struct Checkpoint {\r\n        uint32 fromBlock;\r\n        uint256 votes;\r\n    }\r\n\r\n    /// @notice A record of votes checkpoints for each account, by index\r\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\r\n\r\n    /// @notice The number of checkpoints for each account\r\n    mapping (address => uint32) public numCheckpoints;\r\n\r\n    /// @notice The EIP-712 typehash for the contract's domain\r\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n\r\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\r\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\r\n\r\n    /// @notice A record of states for signing / validating signatures\r\n    mapping (address => uint) public nonces;\r\n\r\n\r\n    // support delegates mint\r\n    function _mint(address account, uint256 amount) internal {\r\n        super._mint(account, amount);\r\n\r\n        // add delegates to the minter\r\n        _moveDelegates(address(0), _delegates[account], amount);\r\n    }\r\n\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        super._transfer(sender, recipient, amount);\r\n        _moveDelegates(_delegates[sender], _delegates[recipient], amount);\r\n    }\r\n\r\n\r\n    /**\r\n    * @notice Delegate votes from `msg.sender` to `delegatee`\r\n    * @param delegatee The address to delegate votes to\r\n    */\r\n    function delegate(address delegatee) external {\r\n        return _delegate(msg.sender, delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates votes from signatory to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     * @param nonce The contract state required to match the signature\r\n     * @param expiry The time at which to expire the signature\r\n     * @param v The recovery byte of the signature\r\n     * @param r Half of the ECDSA signature pair\r\n     * @param s Half of the ECDSA signature pair\r\n     */\r\n    function delegateBySig(\r\n        address delegatee,\r\n        uint nonce,\r\n        uint expiry,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n    external\r\n    {\r\n        bytes32 domainSeparator = keccak256(\r\n            abi.encode(\r\n                DOMAIN_TYPEHASH,\r\n                keccak256(bytes(name())),\r\n                getChainId(),\r\n                address(this)\r\n            )\r\n        );\r\n\r\n        bytes32 structHash = keccak256(\r\n            abi.encode(\r\n                DELEGATION_TYPEHASH,\r\n                delegatee,\r\n                nonce,\r\n                expiry\r\n            )\r\n        );\r\n\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                domainSeparator,\r\n                structHash\r\n            )\r\n        );\r\n\r\n        address signatory = ecrecover(digest, v, r, s);\r\n        require(signatory != address(0), \"MdxToken::delegateBySig: invalid signature\");\r\n        require(nonce == nonces[signatory]++, \"MdxToken::delegateBySig: invalid nonce\");\r\n        require(block.timestamp <= expiry, \"MdxToken::delegateBySig: signature expired\");\r\n        return _delegate(signatory, delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current votes balance for `account`\r\n     * @param account The address to get votes balance\r\n     * @return The number of current votes for `account`\r\n     */\r\n    function getCurrentVotes(address account)\r\n    external\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the prior number of votes for an account as of a block number\r\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\r\n     * @param account The address of the account to check\r\n     * @param blockNumber The block number to get the vote balance at\r\n     * @return The number of votes the account had as of the given block\r\n     */\r\n    function getPriorVotes(address account, uint blockNumber)\r\n    external\r\n    view\r\n    returns (uint256)\r\n    {\r\n        require(blockNumber < block.number, \"MdxToken::getPriorVotes: not yet determined\");\r\n\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        if (nCheckpoints == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // First check most recent balance\r\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\r\n            return checkpoints[account][nCheckpoints - 1].votes;\r\n        }\r\n\r\n        // Next check implicit zero balance\r\n        if (checkpoints[account][0].fromBlock > blockNumber) {\r\n            return 0;\r\n        }\r\n\r\n        uint32 lower = 0;\r\n        uint32 upper = nCheckpoints - 1;\r\n        while (upper > lower) {\r\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\r\n            Checkpoint memory cp = checkpoints[account][center];\r\n            if (cp.fromBlock == blockNumber) {\r\n                return cp.votes;\r\n            } else if (cp.fromBlock < blockNumber) {\r\n                lower = center;\r\n            } else {\r\n                upper = center - 1;\r\n            }\r\n        }\r\n        return checkpoints[account][lower].votes;\r\n    }\r\n\r\n    function _delegate(address delegator, address delegatee)\r\n    internal\r\n    {\r\n        address currentDelegate = _delegates[delegator];\r\n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying balances (not scaled);\r\n        _delegates[delegator] = delegatee;\r\n\r\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\r\n\r\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\r\n    }\r\n\r\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\r\n        if (srcRep != dstRep && amount > 0) {\r\n            if (srcRep != address(0)) {\r\n                // decrease old representative\r\n                uint32 srcRepNum = numCheckpoints[srcRep];\r\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\r\n                uint256 srcRepNew = srcRepOld.sub(amount);\r\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\r\n            }\r\n\r\n            if (dstRep != address(0)) {\r\n                // increase new representative\r\n                uint32 dstRepNum = numCheckpoints[dstRep];\r\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\r\n                uint256 dstRepNew = dstRepOld.add(amount);\r\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _writeCheckpoint(\r\n        address delegatee,\r\n        uint32 nCheckpoints,\r\n        uint256 oldVotes,\r\n        uint256 newVotes\r\n    )\r\n    internal\r\n    {\r\n        uint32 blockNumber = safe32(block.number, \"MdxToken::_writeCheckpoint: block number exceeds 32 bits\");\r\n\r\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\r\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\r\n        } else {\r\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\r\n            numCheckpoints[delegatee] = nCheckpoints + 1;\r\n        }\r\n\r\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\r\n    }\r\n\r\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\r\n        require(n < 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function getChainId() internal pure returns (uint) {\r\n        uint256 chainId;\r\n        assembly { chainId := chainid() }\r\n\r\n        return chainId;\r\n    }\r\n\r\n    /// @notice An event thats emitted when an account changes its delegate\r\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\r\n\r\n    /// @notice An event thats emitted when a delegate account's vote balance changes\r\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\r\n\r\n}\r\n\r\ncontract MdxToken is DelegateERC20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private constant preMineSupply = 200000000 * 1e18;\r\n    uint256 private constant maxSupply = 1000000000 * 1e18;     // the total supply\r\n\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    EnumerableSet.AddressSet private _minters;\r\n\r\n    constructor() ERC20(\"MDX Token\", \"MDX\") public {\r\n        _mint(msg.sender, preMineSupply);\r\n    }\r\n\r\n    // mint with max supply\r\n    function mint(address _to, uint256 _amount) public onlyMinter returns (bool) {\r\n        if (_amount.add(totalSupply()) > maxSupply) {\r\n            return false;\r\n        }\r\n        _mint(_to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function addMinter(address _addMinter) public onlyOwner returns (bool) {\r\n        require(_addMinter != address(0), \"MdxToken: _addMinter is the zero address\");\r\n        return EnumerableSet.add(_minters, _addMinter);\r\n    }\r\n\r\n    function delMinter(address _delMinter) public onlyOwner returns (bool) {\r\n        require(_delMinter != address(0), \"MdxToken: _delMinter is the zero address\");\r\n        return EnumerableSet.remove(_minters, _delMinter);\r\n    }\r\n\r\n    function getMinterLength() public view returns (uint256) {\r\n        return EnumerableSet.length(_minters);\r\n    }\r\n\r\n    function isMinter(address account) public view returns (bool) {\r\n        return EnumerableSet.contains(_minters, account);\r\n    }\r\n\r\n    function getMinter(uint256 _index) public view onlyOwner returns (address){\r\n        require(_index <= getMinterLength() - 1, \"MdxToken: index out of bounds\");\r\n        return EnumerableSet.get(_minters, _index);\r\n    }\r\n\r\n    // modifier for mint function\r\n    modifier onlyMinter() {\r\n        require(isMinter(msg.sender), \"caller is not the minter\");\r\n        _;\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/common/Timelock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\npragma solidity ^0.5.16;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\n\r\ncontract Timelock {\r\n    using SafeMath for uint;\r\n\r\n    event NewAdmin(address indexed newAdmin);\r\n    event NewPendingAdmin(address indexed newPendingAdmin);\r\n    event NewDelay(uint indexed newDelay);\r\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\r\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\r\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\r\n\r\n    uint public constant GRACE_PERIOD = 14 days;\r\n    uint public constant MINIMUM_DELAY = 2 days;\r\n    uint public constant MAXIMUM_DELAY = 30 days;\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    uint public delay;\r\n\r\n    mapping(bytes32 => bool) public queuedTransactions;\r\n\r\n\r\n    constructor(address admin_, uint delay_) public {\r\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\r\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\r\n\r\n        admin = admin_;\r\n        delay = delay_;\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n    function setDelay(uint delay_) public {\r\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\r\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\r\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\r\n        delay = delay_;\r\n\r\n        emit NewDelay(delay);\r\n    }\r\n\r\n    function acceptAdmin() public {\r\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\r\n        admin = msg.sender;\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(admin);\r\n    }\r\n\r\n    function setPendingAdmin(address pendingAdmin_) public {\r\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\r\n        pendingAdmin = pendingAdmin_;\r\n\r\n        emit NewPendingAdmin(pendingAdmin);\r\n    }\r\n\r\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\r\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\r\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        queuedTransactions[txHash] = true;\r\n\r\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\r\n        return txHash;\r\n    }\r\n\r\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\r\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        queuedTransactions[txHash] = false;\r\n\r\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\r\n    }\r\n\r\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\r\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\r\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\r\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\r\n\r\n        queuedTransactions[txHash] = false;\r\n\r\n        bytes memory callData;\r\n\r\n        if (bytes(signature).length == 0) {\r\n            callData = data;\r\n        } else {\r\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\r\n        }\r\n\r\n        // solium-disable-next-line security/no-call-value\r\n        (bool success, bytes memory returnData) = target.call.value(value)(callData);\r\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\r\n\r\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\r\n\r\n        return returnData;\r\n    }\r\n\r\n    function getBlockTimestamp() internal view returns (uint) {\r\n        // solium-disable-next-line security/no-block-members\r\n        return block.timestamp;\r\n    }\r\n}\r\n"
    },
    "contracts/common/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.5.16;\r\n\r\nimport \"./Context.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\n\r\n// import \"hardhat/console.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n     * a default value of 18.\r\n     *\r\n     * To select a different value for {decimals}, use {_setupDecimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name_, string memory symbol_, uint8 decimals_) public {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        // console.log('approve msg.sender: %s', _msgSender());\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets {decimals} to a value other than the default one of 18.\r\n     *\r\n     * WARNING: This function should only be called from the constructor. Most\r\n     * applications that interact with token contracts will not expect\r\n     * {decimals} to ever change, and may work incorrectly if it does.\r\n     */\r\n    function _setupDecimals(uint8 decimals_) internal {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal {\r\n        from;\r\n        to;\r\n        amount;\r\n    }\r\n}\r\n"
    },
    "contracts/common/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.5.16;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    function _msgSender() internal view returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n"
    },
    "contracts/common/Token.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.16;\r\n\r\nimport \"./ERC20.sol\";\r\n\r\ncontract Token is ERC20 {\r\n  constructor(\r\n              string memory name_,\r\n              string memory symbol_,\r\n              uint totalSupply_,\r\n              address holder_,\r\n              uint8 decimals_\r\n            )\r\n            public\r\n            ERC20(name_, symbol_, decimals_) {\r\n    // _setupDecimals(8);\r\n    _mint(holder_, totalSupply_);\r\n  }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}